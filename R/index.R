#' Model Quantity Index Table
#'
#' Make an index table to enumerate model quantity labels by category. These
#' objects generalize and wrap \code{\link{data.frame}}s, where each column is a
#' label category and each row is an index. Indices must contain
#' only letters, numbers, and underscores. Blank empty string entries are
#' allowed, but missing values (`NA`s) are not.
#'
#' For example, the following index table describes the state variables of the
#' model:
#' ```{r}
#' sir = mp_index(Epi = c("S", "I", "R"))
#' print(sir)
#' ```
#' Here, the column `Epi` denotes that the category of these labels is
#' epidemiological. There is nothing special about this specific choice of
#' category name; we could have also used another name like `Compartment`.
#'
#' However, in more complicated models, it is good to think carefully about
#' choosing descriptive category names. For example, in an age-structured SIR
#' model, we could add an `Age` column to generate an index table as follows:
#' ```{r}
#' sir_age = mp_index(
#'  Epi = rep(c("S", "I", "R"), 2),
#'  Age = rep(c("young", "old"), each = 3)
#' )
#' print(sir_age)
#' ```
#' Here, having the first column in the index table labeled `Compartment` would
#' be somewhat misleading, as the compartments aren't actually just "S", "I",
#' and "R", they are each of the epidemiological states stratified by the age
#' groups "young" and "old".
#'
#' This index table could also be generated by first specifying individual index
#' tables for the `Epi` and `Age` columns, and then using a `macpan2` product
#' function that combines the tables into a single index table:
#' ```{r}
#' sir = mp_index(Epi = c("S", "I", "R"))
#' age = mp_index(Age = c("young", "old"))
#' prod = mp_cartesian(sir, age)
#' prod
#' ```
#' The [mp_cartesian()] function will produce a table with entries that are all
#' possible combinations of the individual index tables. The "See Also" section
#' of the [mp_cartesian()] help page catalogues all available product functions.
#'
#' We can produce the full labels of model quantities, which are simply
#' dot-concatenated indices, one for each entry in the index table, using the
#' `labels()` function:
#' ```{r, echo = FALSE}
#' labels(prod)
#' ```
#'
#' Dots are not allowed in indices so that the labels can be inverted to
#' reproduce the original index table (provided that the column names can be
#' retrieved).
#'
#' It is recommended to use UpperCamelCase for the columns of index tables
#' and single uppercase characters ("S", "I"), all lowercase character
#' strings ("gamma"), and/or snake_case strings ("aging_rate") for indices. This
#' convention helps when reading code that contains references to both column
#' names and indices.
#'
#' @param ... Character vectors to combine to produce an index. Alternatively,
#'   any number of data frames of character-valued columns. If data frames are
#'   supplied, their rows will be bound and the result converted to an index if
#'   possible.
#' @param labelling_column_names A \code{\link{character}} vector of the names
#'   of the index that will be used to label the model components (i.e. rows)
#'   being described. The \code{labelling_column_names} cannot have duplicates
#'   and must contain at least one name. The index given by the
#'   \code{labelling_column_names} must uniquely identify each row.
#'   The default \code{NULL} gives the set of columns, in order starting with
#'   the first column, that are required to uniquely identify each row.
#'
#' @examples
#' state = mp_index(
#'   Epi = c("S", "I", "S", "I"),
#'   Age = c("young", "young", "old", "old")
#' )
#' print(state)
#' labels(state)
#' mp_cartesian(state, mp_index(City = c("hamilton", "toronto")))
#'
#' @family indexes
#'
#' @seealso [mp_vector()]
#' @seealso [mp_set_numbers()]
#'
#' @export
mp_index = function(..., labelling_column_names) UseMethod("mp_index")


#' Index
#'
#' @param partition A data frame (or data frame-like) object containing
#'   definitions of the index. This object can be a \code{\link{data.frame}},
#'   \code{\link{Partition}}, or another \code{\link{Index}} object.
#' @param vector_name An optional \code{\link{character}} string giving the
#' name of the vector being indexed.
#' @param labelling_column_names A \code{\link{character}} vector of the names of the
#'   index that will be used to label the model components (i.e. rows) being
#'   described. The \code{labelling_column_names} cannot have duplicates and must
#'   contain at least one name. The index given by the \code{labelling_column_names}
#'   must uniquely identify each row. The default \code{NULL} uses the minimal
#'   number of
#' @param reference_index (Advanced) An optional partition to use when
#'        computing subset indices.
#' @param x \code{Index} object.
#' @param ... For consistency with existing S3 methods.
#'
#' @seealso [mp_index()]
#' @noRd
#' @keywords internal
#' @export
Index = function(partition
    , vector_name = NULL
    , labelling_column_names = NULL
    , reference_index = NULL
  ) {
  UseMethod("Index")
}

#' @export
Index.Partition = function(partition
    , vector_name = NULL
    , labelling_column_names = NULL
    , reference_index = NULL
  ) {

  if (is.null(labelling_column_names)) {
    labelling_column_names = infer_labelling_columns(partition)
  }

  self = Base()

  ## Args
  self$partition = partition
  self$vector_name = vector_name
  self$labelling_column_names = to_names(labelling_column_names)

  ## Private Arg
  self$.reference_index = reference_index

  ## Getters and Setters
  self$reference_index = function() {
    if (is.null(self$.reference_index)) return(self)
    self$.reference_index
  }
  self$set_reference_index = function(index) {
    self$.reference_index = index
  }
  self$reset_reference_index = function() self$.reference_index = NULL

  ## Standard Methods
  self$labels = function() self$partition$select(self$labelling_column_names)$labels()
  self$partial_labels = function(...) self$partition$partial_labels(...)
  self$reference_labels = function() {
    self$reference_index()$partial_labels(self$labelling_column_names)
  }
  self$reference_positions = function(zero_based = FALSE) {
    i = match(self$reference_labels(), self$labels())
    if (zero_based) i = i - 1L
    i
  }
  self$positions = function(zero_based = FALSE) {
    i = match(self$labels(), self$reference_labels())
    if (zero_based) i = i - 1L
    i
  }

  return_object(self, "Index")
}

#' @export
Index.data.frame = function(partition
    , vector_name = NULL
    , labelling_column_names = NULL
    , reference_index = NULL
  ) {
  (partition 
   |> Partition() 
   |> Index(
        labelling_column_names = labelling_column_names
      , reference_index = reference_index
    )
  )
}

#' @export
Index.Index = function(partition
    , vector_name = NULL
    , labelling_column_names = NULL
    , reference_index = NULL
  ) {
  (partition$partition 
   |> Index(
        labelling_column_names = labelling_column_names
      , reference_index = reference_index
    )
  )
}

#' @describeIn mp_index Print an index.
#' @export
print.Index = function(x, ...) print(x$partition)

#' @describeIn mp_index Get the names of the columns of an index.
#' @export
names.Index = function(x) x$partition$names()

#' @export
as.data.frame.Index = function(x, row.names = NULL, optional = FALSE, ...) {
  x$partition$frame()
}

#' @export
labelling_column_names = function(x) UseMethod("labelling_column_names")

#' @describeIn mp_index Retrieve the \code{labelling_column_names} of
#' an index. These are the names of the columns that are used to label
#' the model components.
#' @export
labelling_column_names.Index = function(x) x$labelling_column_names

#' @describeIn mp_index Convert an index into
#' a character vector giving labels associated with each model component
#' (i.e. row) being described.
#' @export
to_labels.Index = function(x) x$labels()

#' @describeIn mp_index Convert an index into
#' a character vector giving labels associated with each model component
#' (i.e. row) being described.
#' @export
labels.Index = function(x, ...) x$labels()


#' @export
mp_index.character = function(..., labelling_column_names) {
  f = data.frame(...)
  if (missing(labelling_column_names)) labelling_column_names = names(f)
  Index(f, labelling_column_names = to_names(labelling_column_names))
}

#' @export
mp_index.data.frame = function(..., labelling_column_names) {
  f = list(...) |> bind_rows()
  if (missing(labelling_column_names)) labelling_column_names = names(f)
  Index(f, labelling_column_names = to_names(labelling_column_names))
}


#' @export
mp_catalogue = function(name, ..., labelling_column_names) {
  l = list(...)
  for (i in seq_along(l)) {
    args = setNames(l[i], name)
    if (!missing(labelling_column_names)) {
      args = c(args, list(labelling_column_names = labelling_column_names))
    }
    l[[i]] = do.call(mp_index, args)
  }
  l
}


# compute the incremental contribution of each column in a partition
# to uniquely identifying each row
info_curve = function(partition) {
  nms = names(partition)
  get_nrows = function(i) nrow(partition$select(nms[1:i])$frame())
  (nms
    |> seq_along()
    |> vapply(get_nrows, integer(1L))
    |> setNames(nms)
  )
}

# return minimal set of columns, in order starting with the first column,
# that are required to uniquely identify each row.
infer_labelling_columns = function(partition) {
  names(partition)[seq_len(which.max(info_curve(partition)))]
}
