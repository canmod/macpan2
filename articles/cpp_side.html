<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<title>The C++ Side • macpan2</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><link href="../deps/font-awesome-6.5.2/css/all.min.css" rel="stylesheet">
<link href="../deps/font-awesome-6.5.2/css/v4-shims.min.css" rel="stylesheet">
<script src="../deps/headroom-0.11.0/headroom.min.js"></script><script src="../deps/headroom-0.11.0/jQuery.headroom.min.js"></script><script src="../deps/bootstrap-toc-1.0.1/bootstrap-toc.min.js"></script><script src="../deps/clipboard.js-2.0.11/clipboard.min.js"></script><script src="../deps/search-1.0.0/autocomplete.jquery.min.js"></script><script src="../deps/search-1.0.0/fuse.min.js"></script><script src="../deps/search-1.0.0/mark.min.js"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="The C++ Side">
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>


    <nav class="navbar navbar-expand-lg fixed-top bg-light" data-bs-theme="light" aria-label="Site navigation"><div class="container">

    <a class="navbar-brand me-2" href="../index.html">macpan2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.15.0</small>


    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item"><a class="nav-link" href="../reference/index.html">Reference</a></li>
<li class="active nav-item dropdown">
  <button class="nav-link dropdown-toggle" type="button" id="dropdown-articles" data-bs-toggle="dropdown" aria-expanded="false" aria-haspopup="true">Articles</button>
  <ul class="dropdown-menu" aria-labelledby="dropdown-articles">
<li><a class="dropdown-item" href="../articles/quickstart.html">Quickstart</a></li>
    <li><a class="dropdown-item" href="../articles/example_models.html">Example Models</a></li>
    <li><a class="dropdown-item" href="../articles/calibration.html">Calibrating Compartmental Models to Data</a></li>
    <li><a class="dropdown-item" href="../articles/real_data.html">Fitting to Real Data</a></li>
    <li><a class="dropdown-item" href="../articles/state_updaters.html">ODE Solvers, Process Error, and Difference Equations</a></li>
    <li><a class="dropdown-item" href="../articles/options.html">Options</a></li>
    <li><hr class="dropdown-divider"></li>
    <li><a class="dropdown-item" href="../articles/index.html">More articles...</a></li>
  </ul>
</li>
<li class="nav-item"><a class="nav-link" href="../news/index.html">Changelog</a></li>
      </ul>
<ul class="navbar-nav">
<li class="nav-item"><form class="form-inline" role="search">
 <input class="form-control" type="search" name="search-input" id="search-input" autocomplete="off" aria-label="Search site" placeholder="Search for" data-search-index="../search.json">
</form></li>
<li class="nav-item"><a class="external-link nav-link" href="https://github.com/canmod/macpan2/" aria-label="GitHub"><span class="fa fab fa-github fa-lg"></span></a></li>
      </ul>
</div>


  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">

      <h1>The C++ Side</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/canmod/macpan2/blob/main/vignettes/cpp_side.Rmd" class="external-link"><code>vignettes/cpp_side.Rmd</code></a></small>
      <div class="d-none name"><code>cpp_side.Rmd</code></div>
    </div>

    
    
<p><a href="https://canmod.github.io/macpan2/articles/vignette-status#stable"><img src="https://img.shields.io/badge/status-stable-green" alt="status"></a></p>
<div class="section level2">
<h2 id="prerequisites">Prerequisites<a class="anchor" aria-label="anchor" href="#prerequisites"></a>
</h2>
<p>This document assumes a solid understanding of <a href="https://kaskr.github.io/adcomp/_book/Introduction.html" class="external-link">template
model builder</a>.</p>
</div>
<div class="section level2">
<h2 id="matrices">Matrices<a class="anchor" aria-label="anchor" href="#matrices"></a>
</h2>
<p>A list of numerical scalars, vectors, and matrices are passed as
input variables from R to C++. Scalars are passed as 1-by-1 matrices and
vectors as n-by-1, so that all of these numerical variables are actually
matrices.</p>
<p>Treating all numerical objects as matrices might seem strange, but it
is similar to how R treats all numerical objects as vectors. In this
way, R matrices are vectors with dimensions. We are just extending this
logic and requiring that all vectors have dimensions. We are more
restrictive than R however by not allowing multidimensional arrays.</p>
<p>Missing values are not allowed in any matrix. On the R side these
variables are all associated with a unique name, and on the C++ side
each of these names is associated with a 0-based index. All indices in
this spec are 0-based.</p>
<p>All matrices must have zero or more rows and columns. Any matrix with
either zero rows or zero columns is an empty matrix. Empty matrices
allow for placeholders for matrices that will be defined during
simulations.</p>
<p>These matrices are passed in using the <code>DATA_STRUCT(mats)</code>
TMB macro, with an associated C++ <code>struct</code> for extracting the
component matrices by index.</p>
</div>
<div class="section level2">
<h2 id="parameters">Parameters<a class="anchor" aria-label="anchor" href="#parameters"></a>
</h2>
<p>Two vectors of parameters are passed to C++.</p>
<ul>
<li>
<code>PARAMETER_VECTOR(params)</code> – this vector becomes the
argument of the objective function, and can therefore be optimized using
a non-linear optimizer or simulated using MCMC</li>
<li>
<code>PARAMETER_VECTOR(random)</code> – this vector becomes the
random effects that will be integrated out of the objective function
using a Laplace approximation</li>
</ul>
<p>The values in these parameter vectors are used to update certain
elements in the matrix-valued variables within <code>mats</code>. The
elements to be updated are described on the R side by two data frames
with one row for every matrix element to be replaced. These data frames
are constructed in R and passed to C++. The columns for the data frame
associated with <code>params</code> are the following.</p>
<ul>
<li>
<code>DATA_IVECTOR(p_par_id)</code> – indices into the
<code>params</code> vector giving the parameter to use when updating
each element in <code>mats</code> that is to be updated</li>
<li>
<code>DATA_IVECTOR(p_mat_id)</code> – indices into <code>mats</code>
giving the matrices with elements to be replaced by parameters</li>
<li>
<code>DATA_IVECTOR(p_row_id)</code> – indices of the rows within
each matrix associated with an element to be replaced by parameters</li>
<li>
<code>DATA_IVECTOR(p_col_id)</code> – indices of the columns within
each matrix associated with an element to be replaced by parameters</li>
</ul>
<p>After these vectors are read into C++, a loop is executed over the
rows of this table that replaces the associated <code>mats</code>
elements with <code>params</code> elements.</p>
<p>The <code>random</code> vector is treated similarly to
<code>params</code> in that it is associated with a data frame
describing what elements in <code>mats</code> should be replaced. The
names of the columns of this table are:</p>
<ul>
<li><code>DATA_IVECTOR(r_par_id)</code></li>
<li><code>DATA_IVECTOR(r_mat_id)</code></li>
<li><code>DATA_IVECTOR(r_row_id)</code></li>
<li><code>DATA_IVECTOR(r_col_id)</code></li>
</ul>
<p>Our implied convention is that <code>p</code> stands for ‘fixed
Parameters’ and <code>r</code> for ‘Random parameters’.</p>
</div>
<div class="section level2">
<h2 id="trajectory-simulation">Trajectory Simulation<a class="anchor" aria-label="anchor" href="#trajectory-simulation"></a>
</h2>
<p>After the input matrices in <code>mats</code> are updated using
<code>params</code> and <code>random</code>, these matrices can be
modified. We refer to this process of modification as trajectory
simulation. There are three phases to the trajectory simulation
process.</p>
<ol style="list-style-type: decimal">
<li>Before the simulation loop</li>
<li>During the simulation loop</li>
<li>After the simulation loop</li>
</ol>
<p>Simulation time is measured in dimensionless iterations, and is
indexed by an integer, <code>t</code>, such that
<code>0 &lt;= t &lt;= T+1</code>, where <code>T</code> is the number of
iterations of the loop. The value of each matrix at <code>t = 0</code>
is the value of that matrix just before the first iteration of the
simulation loop begins. The value of each matrix at
<code>0 &lt; t &lt; T+1</code> is the value of the matrix at the very
end of the <code>t</code>th iteration of the simulation loop. The value
of each matrix at <code>t = T+1</code> is the value of the matrix at the
end of the simulation.</p>
<p>This time-indexing system is used for two purposes.</p>
<ol style="list-style-type: decimal">
<li>To optionally return the simulation history to the user</li>
<li>For matrix modifications that depend on past values</li>
</ol>
<p>The user can opt in and out of these uses on a per-matrix basis, by
specifying two vectors that have one element per matrix.</p>
<ul>
<li>
<code>DATA_IVECTOR(mats_save_hist)</code>
<ul>
<li>Equals <code>0</code> if the matrix is overwritten at each
simulation iteration, <code>t</code>
</li>
<li>Equals <code>1</code> if all computed values of the matrix are
saved</li>
</ul>
</li>
<li>
<code>DATA_IVECTOR(mats_return)</code>
<ul>
<li>Equals <code>0</code> if the matrix is not returned to the R side at
the end of the simulation</li>
<li>Equals <code>1</code> otherwise</li>
</ul>
</li>
</ul>
<p>The number of iterations, <code>T</code>, is passed to TMB as
<code>DATA_INTEGER(time_steps)</code>.</p>
</div>
<div class="section level2">
<h2 id="expressions">Expressions<a class="anchor" aria-label="anchor" href="#expressions"></a>
</h2>
<p>The mathematical details of how matrices are modified during the
simulation process is controlled on the R side by supplying expressions.
Each expression is the right-hand-side of an R formula involving the
following three types of objects.</p>
<ul>
<li>Names of matrices in <code>mats</code>
</li>
<li>Names of functions that are currently allowed by the engine</li>
<li>Numeric literals (e.g. <code>3.14</code>)</li>
</ul>
<p>A simulation is the sequential evaluation of these expressions in a
user-specified order. Each expression may be evaluated during one of the
three simulation phases – before, during, and after the simulation loop.
Expressions evaluated before and after the simulation loop are evaluated
only once, whereas those evaluated during the loop are evaluated at
every iteration. The phase of each expression is controlled by the
<code>DATA_IVECTOR(eval_schedule)</code> vector described at the end of
this section.</p>
<p>Each mathematical expression can be used by C++ in several ways.
Information on how each expression should be used is passed to C++ using
a set of vectors. Each of these vectors is the same length, with one
element per expression.</p>
<ul>
<li>
<code>DATA_IVECTOR(expr_output_id)</code>
<ul>
<li>Index into <code>mats</code> identifying the matrix produced by the
expression</li>
</ul>
</li>
<li>
<code>DATA_IVECTOR(expr_sim_block)</code>
<ul>
<li>Identifies whether or not the expression should be evaluated inside
a <code>SIMULATE</code> macro within TMB</li>
<li>A value of <code>0</code> indicates that the expression is to be
evaluated without the <code>SIMULATE</code> macro (we expect this to be
the standard case), whereas a value of <code>1</code> indicates
evaluation inside a <code>SIMULATE</code> macro</li>
<li>Note that if an expression is evaluated in a <code>SIMULATE</code>
macro and is returned to the user through <code>mats_return == 1</code>,
then it must also be returned within the <code>SIMULATE</code>
macro</li>
</ul>
</li>
<li>
<code>DATA_IVECTOR(expr_num_p_table_rows)</code>
<ul>
<li>Number of rows associated with each expression in the parse table
(see section on <a href="#parse-tables">Parse Tables</a>)</li>
</ul>
</li>
</ul>
<p>Each expression is evaluated in the order in which it appears in
these vectors.</p>
<p>The <code>DATA_IVECTOR(eval_schedule)</code> vector gives the phase
in which each of these expressions should be evaluated. This vector has
three elements giving the number of expressions to evaluate before,
during, and after the simulation loop. In particular the first
<code>eval_schedule[0]</code> expressions are evaluated before the
simulation loop, the next <code>eval_schedule[1]</code> expressions are
evaluated at every iteration of the simulation loop, and the next
<code>eval_schedule[2]</code> expressions are evaluated after the
simulation loop.</p>
<p>Inputs are invalid if the sum of the elements of
<code>eval_schedule</code> does not equal the number of elements in each
of <code>expr_output_id</code>, <code>expr_sim_block</code>, and
<code>expr_num_p_table_rows</code>.</p>
</div>
<div class="section level2">
<h2 id="parse-tables">Parse Tables<a class="anchor" aria-label="anchor" href="#parse-tables"></a>
</h2>
<p>Each expression is parsed into a table of numbers that represents the
expression and can be passed to C++. Each row in this table corresponds
to a step in the process of evaluating the expression. These steps
correspond to one of three types of things, identified by column
<code>n</code>:</p>
<ol style="list-style-type: decimal">
<li>A function – if <code>n &gt; 0</code> – see section on <a href="#function-definitions">Function Definitions</a>
</li>
<li>A matrix – if <code>n == 0</code> – see section on <a href="#matrices">Matrices</a>
</li>
<li>A literal – if <code>n == -1</code> – see section on <a href="#literals">Literals</a>
</li>
</ol>
<p>If the row does correspond to a function, then column <code>n</code>
gives the number of arguments in that function.</p>
<p>The column, <code>x</code>, gives an index for looking up the
specific instance of each of these three types of entities. For example,
if <code>n == 0</code> then the <code>x</code> column gives the index
into the <code>mats</code> list for getting the appropriate matrix If
<code>n == -1</code> then <code>x</code> gives an index into
<code>literals</code> and if <code>n &gt; 0</code> <code>x</code> gives
an index into a list of valid functions. The <code>i</code> column is
only relevant for functions, and indicates the row of the table
representing the first argument to that function.</p>
<p>This table is processed on the C++ side with a recursive function
that either:</p>
<ul>
<li>for rows associated with functions: looks up a valid function from a
list of function definitions, and recursively calls itself</li>
<li>for rows associated with matrices: looks up and returns a matrix in
the <code>mats</code> list</li>
<li>for rows associated with literals: looks up and returns a literal
from a list of valid literals</li>
</ul>
<p>The parse tables for all expressions are concatenated row-wise and
passed to C++ as a set of three vectors of equal length.</p>
<ul>
<li><code>DATA_IVECTOR(p_table_n)</code></li>
<li><code>DATA_IVECTOR(p_table_x)</code></li>
<li><code>DATA_IVECTOR(p_table_i)</code></li>
</ul>
<p>The first three vectors correspond to <code>n</code>, <code>x</code>,
and <code>i</code> as discussed in this section.</p>
<p>The <code>expr_num_p_table_rows</code> vector (defined above in the
section on <a href="#expressions">Expressions</a>) is used to relate
each expression to a set of rows in this concatenated parse table. The
elements of this vector contain the number of parse table rows
associated with each expression. The ordering of the elements is
consistent with the ordering of the concatenation of the individual
parse tables, and so row indices are not necessary.</p>
</div>
<div class="section level2">
<h2 id="literals">Literals<a class="anchor" aria-label="anchor" href="#literals"></a>
</h2>
<p>A global list of valid literals for all expressions is passed to C++
as a numeric vector, <code>DATA_VECTOR(literals)</code>.</p>
</div>
<div class="section level2">
<h2 id="function-definitions">Function Definitions<a class="anchor" aria-label="anchor" href="#function-definitions"></a>
</h2>
<p>The functions that are used in each [Expression] must be in a valid
list of functions defined on the C++ side. Most of these functions will
have analogues on the R side to make it as easy as possible for R users
to reason about their expressions.</p>
<p>Valid functions take one or more matrix-valued arguments and return a
single matrix. The number of arguments does not need to be known when
the model is defined, but some functions may optionally require a
predefined number of arguments.</p>
<p>Extending functionality of the engine will typically involve simply
adding function definitions to the list of valid functions. All function
definitions have the following objects available to them.</p>
<ul>
<li>
<code>r</code> – A list of matrices giving the arguments to the
function (e.g. <code>r[0]</code> returns the first matrix).</li>
<li>
<code>index2mats</code> – A list of integers giving the indices for
identifying the matrices in the <code>mats</code> list
(e.g. <code>index2mats[0]</code> returns the index of the first
argument).</li>
<li>
<code>t</code> – Time step</li>
<li>
<code>hist</code> – A list of lists of matrices giving the history
of the simulation (e.g. <code>hist[4][0]</code> returns the value of the
first matrix at time step <code>4</code>).</li>
<li>
<code>n</code> – The number of arguments.</li>
</ul>
<p>Function definitions should be grouped into types if several
functions require similar processing. The main example that we have is
element-wise binary operators, including <code>+</code>, <code>*</code>,
<code>-</code>, <code>/</code>, <code>^</code>. These functions all
require the same pre-processing to make sure that the matrix dimensions
of the two operands are compatible and that compatibility is
conveniently defined for the user.</p>
</div>
<div class="section level2">
<h2 id="objective-function">Objective Function<a class="anchor" aria-label="anchor" href="#objective-function"></a>
</h2>
<p>The return value of the objective function is an expression that
could depend on the values of all the matrices at the end of the
simulation and the entire saved simulation history. This expression is
passed as a parse table.</p>
<ul>
<li><code>DATA_IVECTOR(o_table_n)</code></li>
<li><code>DATA_IVECTOR(o_table_x)</code></li>
<li><code>DATA_IVECTOR(o_table_i)</code></li>
</ul>
<p>The implied convention here is that <code>o</code> is for ‘Objective
function parse table’ and <code>p</code> is for ‘matrix Parse
table’.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc" aria-label="Table of contents"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p>Developed by Steve Walker, Weiguang Guan, Jen Freeman, Ben Bolker, Darren Flynn-Primrose.</p>
</div>

<div class="pkgdown-footer-right">
  <p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.1.1.</p>
</div>

    </footer>
</div>





  </body>
</html>
