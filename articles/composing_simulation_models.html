<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="macpan2">
<title>Composing Related Simulation Models â€¢ macpan2</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.3.1/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.3.1/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Composing Related Simulation Models">
<meta property="og:description" content="macpan2">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-light navbar-expand-lg bg-light"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">macpan2</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">1.1.0</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/quickstart.html">Quickstart</a>
    <a class="dropdown-item" href="../articles/example_models.html">Example Models</a>
    <a class="dropdown-item" href="../articles/time_varying_parameters.html">Specifying Time-Varying Parameters</a>
    <a class="dropdown-item" href="../articles/calibration.html">Calibrating Compartmental Models to Data</a>
    <a class="dropdown-item" href="../articles/engine_agnostic_grammar.html">Engine-Agnostic Model Specification Grammar</a>
    <div class="dropdown-divider"></div>
    <a class="dropdown-item" href="../articles/index.html">More articles...</a>
  </div>
</li>
<li class="nav-item">
  <a class="nav-link" href="../news/index.html">Changelog</a>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/canmod/macpan2/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Composing Related Simulation Models</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/canmod/macpan2/blob/HEAD/vignettes/composing_simulation_models.Rmd" class="external-link"><code>vignettes/composing_simulation_models.Rmd</code></a></small>
      <div class="d-none name"><code>composing_simulation_models.Rmd</code></div>
    </div>

    
    
<p><a href="https://canmod.github.io/macpan2/articles/vignette-status#working-draft"><img src="https://img.shields.io/badge/status-working%20draft-red" alt="status"></a></p>
<div class="section level2">
<h2 id="introduction">Introduction<a class="anchor" aria-label="anchor" href="#introduction"></a>
</h2>
<p>After defining an epidemiological model users often want to compute
quantities that summarize it. Examples include simple single-number
quantities like R0, Gbar, and r, as well as more elaborate objects like
the stable compartment distribution of the linearized model.</p>
<p>Methods for computing these summaries for arbitrary models is a deep
research area, making it difficult to include in general purpose
software. However, it is always (too strong?) possible to use brute
force simulation methods for approximating their values. It is this
simulation approach that we take in McMasterPandemic.</p>
<p>Our approach is to modify the focal model so that simulations from
the modified model can be used to approximate summaries of the focal
model. For example, one could scale population size to 1 with zeros in
all compartments except one exposed category. Simulations from such
cohort models will generate a force of infection time-series, and it
turns out that the sum of any finite length of this time-series is an
approximation to R0.</p>
<p>Sometimes these summaries are computed for descriptive purposes, but
here we focus on their use in semi-automatically refining calibrations.
For example, calibrations can often be improved by including prior
information about model parameters and using Bayesian estimation. It can
be easier to get prior information on summaries like R0 than on model
parameters. In such a case one might want to regularize calibrations
using these priors on R0.</p>
<p>As another example, it helps to initialize the state vector of a
simulation model by using the eigenvector of a linearization of the
focal model. Because the eigenvector is often interpretable as a stable
compartment distribution, unrealistic model fluctuations near the
beginning of an epidemic are often minimized.</p>
<p>Another use case of model composition occurs during online
forecasting. Here forecasts are made every <code>n</code> days, and each
forecast is for an <code>n</code>-day period. Between forecasts the
model can be improved. One simple way to carry the information in
previous forecasts forward to the next forecasting model is to use the
final value of the state vector as the initial value in the new
model.</p>
<p>In all of these cases, we start with a focal model and generate
several related models for computing summaries like R0, eigenvectors,
and final state vectors. Then we combine the outputs of these models to
produce improved calibrations of the focal model.</p>
</div>
<div class="section level2">
<h2 id="notation-and-theory">Notation and Theory<a class="anchor" aria-label="anchor" href="#notation-and-theory"></a>
</h2>
<p>As we are developing general modelling software, we need a general
theory with few assumptions. A trajectory model is a model that does the
following.</p>
<ol style="list-style-type: decimal">
<li>Takes a parameter vector, <span class="math inline">\(\theta\)</span>, and initial state vector, <span class="math inline">\(x\)</span>
</li>
<li>Simulates changes to <span class="math inline">\(x\)</span>,
referred to as trajectories</li>
<li>Compares the simulations to observed time-series, <span class="math inline">\(y\)</span>
</li>
<li>Returns an objective function that measures the deviation between
the simulated trajectories and observed time-series</li>
</ol>
<p>Each trajectory model contains two functions.</p>
<ol style="list-style-type: decimal">
<li>A function, <span class="math inline">\(g(\theta; x)\)</span>, of
the parameter and initial state vector, and returns the final state
vector</li>
<li>The objective function, <span class="math inline">\(f(\theta; x;
y)\)</span>
</li>
</ol>
<p>We will often omit <span class="math inline">\(y\)</span> for
notational compactness and simply write <span class="math inline">\(f(\theta; x)\)</span>.</p>
<p>One may estimate <span class="math inline">\(\theta\)</span> as <span class="math inline">\(\hat{\theta}\)</span> by optimizing <span class="math inline">\(f\)</span> over <span class="math inline">\(\theta\)</span> for a given <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. In this strategy <span class="math inline">\(x\)</span> must be assumed. Of course the user is
free to try to jointly calibrate both <span class="math inline">\(\theta\)</span> and <span class="math inline">\(x\)</span>. We represent this approach
mathematically by assuming that <span class="math inline">\(\theta\)</span> can be used to determine <span class="math inline">\(x\)</span>. In these cases where <span class="math inline">\(x\)</span> is determined by <span class="math inline">\(\theta\)</span>, we omit <span class="math inline">\(x\)</span> and write the final state vector and
objective functions as <span class="math inline">\(g(\theta)\)</span>
and <span class="math inline">\(f(\theta)\)</span>. In practice however,
there is often not enough information in the observed time series to
take this approach. Furthermore, this approach can be computationally
slow.</p>
<p>Here we discuss alternatives to naive calibration approaches that use
only a single trajectory model. These alternatives make use of
compositions and combinations of several related trajectory models. In
these approaches there is a focal trajectory model, which is the focus
of inference and forecasting. This focal model is able to generate one
or more models that can be used to improve calibrations of the focal
model.</p>
</div>
<div class="section level2">
<h2 id="online-forecasting">Online Forecasting<a class="anchor" aria-label="anchor" href="#online-forecasting"></a>
</h2>
<p>Consider a sequence of trajectory models that result in the following
sequence of objective functions, <span class="math inline">\(f_1(\theta_1;x_1), ...,
f_n(\theta_n;x_n)\)</span>. For simplicity, assume that each model has
the same state space but potentially different parameter spaces. Let the
final state of model <span class="math inline">\(i\)</span> be <span class="math inline">\(g_i(\theta_i;x_i)\)</span>. Assume that time is
split up into <span class="math inline">\(n+1\)</span> equally-sized and
adjacent intervals and that <span class="math inline">\(\theta_i\)</span> is calibrated on data from the
<span class="math inline">\(i\)</span>th interval and model <span class="math inline">\(i\)</span> is used to forecast the data in
interval <span class="math inline">\(i+1\)</span>.</p>
<p>A simple mechanism for setting the initial state vector for all
models after <span class="math inline">\(i = 1\)</span> is to set the
the objective function of the <span class="math inline">\(i+1\)</span>th
model as <span class="math inline">\(f_{i+1}(\theta_{i+1};x_{i+1} =
g_i(\hat{\theta}_i;x_i))\)</span>, where <span class="math inline">\(\hat{\theta}_i\)</span> is the calibrated
parameter vector for model <span class="math inline">\(i\)</span>. This
objective function is fast to evaluate relative to an objective function
that needs to calibrate the initial state vector.</p>
<p>This procedure will not work well if the forecasts are not
sufficiently accurate over each forecast period. However, it can be
improved upon by fitting the <span class="math inline">\(i\)</span>th
model again after the forecasted data have been observed, and using the
final state predicted by that model as the initial state for the next
forecasting model.</p>
</div>
<div class="section level2">
<h2 id="eigenvector-state-initialization">Eigenvector State Initialization<a class="anchor" aria-label="anchor" href="#eigenvector-state-initialization"></a>
</h2>
<p>The previous online forecasting setup did not consider how to
determine the initial state vector, <span class="math inline">\(x_1\)</span>, of the first model. An approach to
achieving this is to initialize the state vector using the eigenvector
of a linearized version of the model. To construct the objective
function for fitting such a model assume that there are two trajectory
models on the same parameter and state space. Let the initial state of
the focal model be given by <span class="math inline">\(x\)</span> and
the (possibly modified) eigenvector of the (possibly modified)
linearized model be given by <span class="math inline">\(g_0(\theta)\)</span>. Further let the objective
function of the focal model be <span class="math inline">\(f(\theta;x)\)</span>.</p>
<p>To avoid needing to specify or fit a reasonable value for <span class="math inline">\(x\)</span> at each calibration step, one could use
the following modified objective function, <span class="math inline">\(h(\theta) = f(\theta;x =
g_0(\theta))\)</span>.</p>
<p>There is a hidden computational difficulty here however.
McMasterPandemic uses TMB as the computational engine. TMB uses
automatic differentiation to efficiently provide the gradients of
objective functions. Optimizers can make use of these gradients to
converge in fewer iterations. However, TMB does not return the gradients
of the simulations with respect to the parameters. This means that the
gradients return by TMB for <span class="math inline">\(f(\theta;x =
g_0(\theta))\)</span> do not take into account the effect that <span class="math inline">\(\theta\)</span> has on <span class="math inline">\(x\)</span> through <span class="math inline">\(g_0\)</span>. This means that optimization using
this state-initialization approach would not be able to utilize all of
TMBâ€™s speed benefits.</p>
</div>
<div class="section level2">
<h2 id="priors-on-r0">Priors on R0<a class="anchor" aria-label="anchor" href="#priors-on-r0"></a>
</h2>
<p>To construct an objective function, <span class="math inline">\(f(\theta)\)</span> with this prior component one
needs two related trajectory models, each of which returns a
scalar-valued function of the model parameters, <span class="math inline">\(\theta\)</span>.</p>
<ol style="list-style-type: decimal">
<li>The focal model function, <span class="math inline">\(g(\theta)\)</span>, returns the negative log
likelihood</li>
<li>The cohort model function, <span class="math inline">\(h(\theta)\)</span>, approximates R0 and returns
the negative log prior density of this value</li>
</ol>
<p>The overall objective function is then given by <span class="math inline">\(f(\theta) = g(\theta) + h(\theta)\)</span>, which
is fast to evaluate to the extent that <span class="math inline">\(g\)</span> and <span class="math inline">\(h\)</span> are fast to evaluate.</p>
</div>
<div class="section level2">
<h2 id="regenerating-versus-reparameterizing-models">Regenerating Versus Reparameterizing Models<a class="anchor" aria-label="anchor" href="#regenerating-versus-reparameterizing-models"></a>
</h2>
<p>This framework can be used to model an important computational
reality when using TMB, which we do in McMasterPandemic. When we want to
change the initial state vector we can do it either by regenerating the
model with a new initial state, or by reparameterizing the model so that
changes in the parameter vector induce changes in the initial state.</p>
<p>In TMB, objective functions and simulation functions can only take
one parameter vector. In our notation, we model this parameter vector as
<span class="math inline">\(\theta\)</span>. For models that require
regeneration, <span class="math inline">\(f(\theta;x)\)</span>, we
assume that <span class="math inline">\(x\)</span> is a constant feature
of the model. To change <span class="math inline">\(x\)</span> means
recreating all model objects including <span class="math inline">\(f\)</span> and <span class="math inline">\(g\)</span> and this can be much slower than
reparameterizing the model, particularly when we want to iteratively
make changes to the state vector. Models that do not have an explicit
initial state, <span class="math inline">\(f(\theta)\)</span>, assume
that the initial state can be changed by passing a different parameter
vector, <span class="math inline">\(\theta\)</span>, which is faster
than the case where the model objects need to be iteratively
regenerated.</p>
<p>In the use cases above, we used the regeneration approach. But we can
modify any of these to use reparameterization.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Steve Walker, Weiguang Guan, Ben Bolker, Jen Freeman, Darren Flynn-Primrose.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
