[{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"hello-world-an-easy-calibration-exercise","dir":"Articles","previous_headings":"","what":"‘Hello, World’: an easy (??) calibration exercise","title":"Calibrating Compartmental Models to Data","text":"’ll first thing always trying new fitting procedure: simulate clean, nice data model see can recover something close true parameters.","code":""},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"step-0-set-up-simulator-and-generate-data","dir":"Articles","previous_headings":"‘Hello, World’: an easy (??) calibration exercise","what":"Step 0: set up simulator and generate ‘data’","title":"Calibrating Compartmental Models to Data","text":"First set model quickstart guide: fixme: providing mismatched time series (e.g. forgetting specify .phases = \"\" generating simulated data) gives cryptic/confusing errors behaviour (warnings failure recycle, objective function values equal zero). (can make reprex leaving .phases = \"\" … Add noise prevalence () value:","code":"sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) sir_simulator = sir$simulators$tmb(   time_steps = 100,   state = c(S = 99, I = 1, R = 0),   flow = c(foi = NA, gamma = 0.1),   beta = 0.2,   N = empty_matrix   ) ## This is key! sir_results = sir_simulator$report(.phases = \"during\") set.seed(101) sir_prevalence = (sir_results     |> dplyr::select(-c(matrix, col))     |> filter(row == \"I\")     |> mutate(obs_val = value + rnorm(n(), sd = 1)) ) gg0 <- ggplot(sir_prevalence, aes(time)) +     geom_point(aes(y = obs_val)) +     geom_line(aes(y = value)) print(gg0)"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"step-1-add-observed-data-and-slots-for-history-etc-","dir":"Articles","previous_headings":"‘Hello, World’: an easy (??) calibration exercise","what":"Step 1: add observed data and slots for history etc.","title":"Calibrating Compartmental Models to Data","text":"files specified model definition (variables.csv, derivations.csv, settings.json, flows.csv) sufficient define simulator, now need add structure model object can calibration - specifically, whatever observed data want compare , whatever new variables (“matrices”) expressions evaluate compute goodness fit (aka loss function objective function) particular set parameters. fixme: chance adding interface layer stuff? TMBSimulator object (.e., sir_simulator example), $add$matrices() method add new variables space object already stored state variables, etc. (use sir_simulator$matrix_names() list existing matrices, although produces long, scary list internal variables macpan2 constructed) Now use $add$matrices() : add observed data declare matrix storing simulation history variables compare observed data declare matrix store log-likelihood specify matrices save /return report fixme: possibly comment added objects -front, definition files … fixme: examples show sir_simulator$print$matrix_dims() point. good /interpret ?","code":"sir_simulator$add$matrices(   ## observed data   I_obs = sir_prevalence$obs_val,   ## simulated trajectory to compare with data   I_sim = empty_matrix,    ## matrix to contain the log likelihood values at each time step   log_lik = empty_matrix,   ## need to save the simulation history of each of these matrices   .mats_to_save = c(\"I_sim\", \"log_lik\"),   .mats_to_return = c(\"I_sim\", \"log_lik\") )"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"step-2-collect-simulated-values","dir":"Articles","previous_headings":"‘Hello, World’: an easy (??) calibration exercise","what":"Step 2: collect simulated values","title":"Calibrating Compartmental Models to Data","text":"Collect simulated values matrices compared data. .= Inf .phase = \"\" indicates expression come end expressions evaluated iteration simulation loop. Like $add$matrices(), $insert$expressions adds components existing TMBSimulator object - case, expressions computed simulation. (example, since set .phase = \"\", expressions computed time step.) fixme: ’s best way handle irregularly sampled data/match timestamps observed data? (, footnote put ‘extra tricks’ section)","code":"sir_simulator$insert$expressions(   I_sim ~ I,   .phase = \"during\",   .at = Inf )"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"step-3-set-up-and-compute-objective-function","dir":"Articles","previous_headings":"","what":"Step 3: set up and compute objective function","title":"Calibrating Compartmental Models to Data","text":"use log (default) Gaussian density observed values mean (.e. predicted) value simulated values (equivalent least-squares estimation, added complication estimate standard deviation explicitly rather computing residuals). Add new parameter (standard deviation observed distribution around predicted values) rbind_time function gathers together full simulation history I_sim matrix binding together rows iteration. Define objective function (almost always sum negative log-likelihoods point):","code":"sir_simulator$add$matrices( I_sd = 1 ) sir_simulator$insert$expressions(   log_lik ~ dnorm(I_obs, rbind_time(I_sim), I_sd),   .phase = \"after\"   ) sir_simulator$replace$obj_fn(~ -sum(log_lik))"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"step-4-declare-andor-transform-parameters-to-be-optimized-set-starting-values","dir":"Articles","previous_headings":"","what":"Step 4: declare and/or transform parameters to be optimized, set starting values","title":"Calibrating Compartmental Models to Data","text":"postponed defining I_sd model step (fixme: right?), confusing since used objective function. parameters restricted positive, almost always best estimate log scale. ensures values always non-negative (positive unless transformed values negative large enough magnitude exp(x) underflows zero) advantages optimization (fixme: much detail needed ? Shrink scale optimization, make parameter magnitudes \\({\\cal O}(1)\\), make Wald estimation reliable …) practice often read parameter starting values CSV file (using read.csv base R readr::read_csv() tidyverse), can set data frame fly Using $add_transformations(Log(\"var\")) automatically adds variable called log_var list matrices.","code":"sir_simulator$add$transformations(Log(\"I_sd\")) sir_simulator$add$transformations(Log(\"beta\")) params <- read.delim(sep = \"|\", header = TRUE,                      text = \" mat       | row | col | default log_I_sd  | 0   | 0   | 0 log_beta  | 0   | 0   | 1 \") sir_simulator$replace$params_frame(params)"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"step-5-do-the-fit","dir":"Articles","previous_headings":"Step 4: declare and/or transform parameters to be optimized, set starting values","what":"Step 5: do the fit","title":"Calibrating Compartmental Models to Data","text":"’s always good idea quick sanity checks objective function try optimize: get finite values (reasonable inputs)? changing inputs change returned value? Another sanity check: make sure starting values give reasonable-looking trajectory.  simulated trajectory sensible case - log_beta value way large (set default \\(\\exp(1) \\approx 2.78\\), know case true value 0.2). Hopefully real system know enough get reasonable order--magnitude starting values. (really knew \\(\\gamma \\approx 0.1\\), know starting value \\(\\log(\\beta)=1\\) correspond \\({\\cal R}_0 \\approx 28\\), clearly unrealistic infectious diseases … Setting \\(\\log(\\beta)=0\\) instead gives us trajectory still unrealistic (peak observed prevalence 16.7).  fixme: easier way substitute single parameter value? Way modify starting conditions optimizer fly? (Specifying start argument gives ‘formal argument “start” matched multiple actual arguments’ – “replace present” functionality) Print results nlminb - always check value convergence code (’s 0, something may gone wrong …) Back-transform parameters: Get information: correspond true values 0.2, 1, pretty close. fixme: can handle back-transformation/parameter naming nicely? coef(), summary() methods … ?? best-fit parameters stored internally, re-run $report() method get information predicted best-fit trajectory:  fixme: next? Show fit real data? Comparison fitode ? fixme: variations/examples: fit multiple parameters change objective function (Poisson, nbinom, SSQ, chi-squared stat …) add priors/regularization?? add accumulator compartment compute incidence fixme: examples (statistical) diagnostics? e.g. compute residuals, plot vs. time vs fitted values, scale-location plot, etc. ? fixme: add intermediate examples (simple time-varying parameters, Poisson/negative binomial responses, irregularly sampled data, fitting prevalence/hospitalization/death, fitting multiple data streams …) try minimize ‘boiler plate’, focus added features model …","code":"sir_simulator$objective(c(1,1)) #> [1] 3565.546 sir_simulator$objective(c(0,1)) #> [1] 25020 ## these were some other things I tried out when debugging ... print(sir_simulator$get$initial(\"log_I_sd\")) print(sir_simulator$get$initial(\"log_beta\")) print(sir_simulator$current$params_frame()) sir_simulator$report() (sir_simulator$report(c(0,1)) |>  filter(matrix == \"state\", row == \"I\") |>  ggplot(aes(time, value)) + geom_line() ) (sir_simulator$report(c(0,0)) |>  filter(matrix == \"state\", row == \"I\") |>  ggplot(aes(time, value)) + geom_line() ) fit <- sir_simulator$optimize$nlminb() print(fit) #> $par #>      params      params  #> -0.07942465 -1.61413121  #>  #> $objective #> [1] 133.9514 #>  #> $convergence #> [1] 0 #>  #> $iterations #> [1] 12 #>  #> $evaluations #> function gradient  #>       19       13  #>  #> $message #> [1] \"relative convergence (4)\" exp(fit$par) #>    params    params  #> 0.9236476 0.1990635 ff <- sir_simulator$ad_fun() class(ff) <- \"TMB\" if (requireNamespace(\"broom.mixed\")) {     (broom.mixed::tidy(ff, conf.int = TRUE)         |> select(-c(type, std.error))         ## ugh, shouldn't need to do this by hand         |> mutate(term = c(\"I_sd\", \"beta\"))         |> mutate(across(where(is.numeric), exp))     ) } #> Loading required namespace: broom.mixed #> outer mgc:  3.953665e-07  #> outer mgc:  0.1998001  #> outer mgc:  0.2002002  #> outer mgc:  63.85069  #> outer mgc:  63.73186 #>   term  estimate  conf.low conf.high #> 1 I_sd 0.9236476 0.8041134 1.0609510 #> 2 beta 0.1990635 0.1975248 0.2006143 sim_vals <- (sir_simulator$report(.phases = \"during\")     |> filter(matrix == \"state\", row == \"I\") ) gg0 + geom_line(data = sim_vals, aes(y= value), colour = \"red\")"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"measles-data","dir":"Articles","previous_headings":"","what":"Measles Data","title":"Calibrating Compartmental Models to Data","text":"reasonably difficult problem – fit SIR model weekly measles incidence data London UK six decades.  need slightly extend standard SIR model include waning immunity. use radial basis functions model time-variation transmission rate. also make variety questionable assumptions (TODO: fix ), point moment just illustrate usage provide proof concept. example simulation model, fitting data.  looks nothing like observed measles series, illustrates ability generate complex incidence patterns present simple SIR model without radial basis functions waning immunity. modify simulation object able fit measles data. optimization takes quite minutes, still doesn’t converge 10000 function evaluations. red data fitted black observed.  perfect fit, bad now (TODO: work , without papering real challenges).","code":"measles = read.csv(   file.path(     \"https://raw.githubusercontent.com/davidearn/iidda/master/data\",     \"meas_uk__lon_1944-94_wk/source-data/meas_uk__lon_1944-94_wk.csv\"   ),   comment = \"#\" ) measles$date = as.Date(sprintf(   \"%s-%s-%s\", measles$year, measles$month, measles$day )) plot(measles$date, measles$cases, type = \"l\") sir = Compartmental(system.file(\"starter_models\", \"sir_waning\", package = \"macpan2\")) sir$flows() #>   from to  flow       type #> 1    S  I   foi per_capita #> 2    I  R gamma per_capita #> 3    R  S  wane per_capita d = 100 n = nrow(measles) simulator = sir$simulators$tmb(       time_steps = n     , state = c(S = 100000 - 500, I = 500, R = 0)     , flow = c(foi = NA_real_, gamma = 0.2, wane = 0.01)          ## this beta does not matter because we will overwrite     ## it with the output of the radial basis functions     , beta = NA_real_          ## FIXME: this is surely not the population of London at     ##        all in the series     , N = 100000           ## matrices involved in radial basis functions     , X = rbf(n, d)     , b = rnorm(d, sd = 0.01)     , incidence = empty_matrix     , eta = empty_matrix          , .mats_to_save = c(\"state\", \"incidence\", \"beta\")     , .mats_to_return = c(\"state\", \"incidence\", \"beta\")      ## initial S is a function of initial I, which we ## fit to data below )$insert$expressions(     S ~ N - I   , .phase = \"before\"   , .at = 1    ## radial basis function evaluations )$insert$expressions(     eta ~ gamma * exp(X %*% b)   , .phase = \"before\"   , .at = Inf )$insert$expressions(     beta ~ eta[time_step(1)] / clamp(S/N, 1/100)   , .phase = \"during\"   , .at = 1    ## save the simulated incidence trajectory to ## compare with data )$insert$expressions(     incidence ~ I   , .vec_by_states = \"total_inflow\"   , .phase = \"during\"   , .at = Inf ) set.seed(1L) simulated_incidence = filter(simulator$report(.phases = \"during\"), matrix == \"incidence\")$value plot(measles$date, simulated_incidence, type = \"l\", xlab = \"time\") simulator$add$matrices(     reports = measles$cases   , log_lik = empty_matrix   , sim_reports = empty_matrix ) simulator$insert$expressions(     sim_reports ~ rbind_time(incidence)   , .phase = \"after\"   , .at = Inf ) simulator$replace$params(   default = c(       c(0.2, 0.01)     , rep(0, d)     , 500   )   , mat = c(       rep(\"flow\", 2L)     , rep(\"b\", d)       , \"state\"   )   , row = c(       (1:2)     , seq_len(d) - 1L     , 1   ) ) simulator$replace$obj_fn(~ - sum(dpois(reports, sim_reports))) simulator$optimize$nlminb(control = list(eval.max = 10000, iter.max = 10000, trace = 10)) simulator$optimization_history$get()[[3]]  ## the 3 is there because we tried two other times #> $par #>        params        params        params        params        params  #>  6.703610e-01  7.526679e-03 -2.162259e-01  1.126783e-01  1.543212e-01  #>        params        params        params        params        params  #> -2.604592e-01  1.668384e-01  2.362683e-02 -1.469025e-01  1.003317e-01  #>        params        params        params        params        params  #>  8.794944e-02 -2.221838e-01  2.361532e-01 -4.625439e-02 -1.112743e-01  #>        params        params        params        params        params  #>  1.922560e-01  4.819028e-03 -1.147457e-01  8.483063e-02  1.043099e-01  #>        params        params        params        params        params  #> -5.263295e-02 -1.705089e-01  5.913537e-02  2.166735e-01 -6.042527e-02  #>        params        params        params        params        params  #> -1.215896e-01  6.958421e-02  2.000553e-01 -1.625052e-01 -9.811385e-02  #>        params        params        params        params        params  #>  1.243763e-01  1.010677e-01 -1.360912e-01 -1.548706e-01  1.815481e-01  #>        params        params        params        params        params  #>  1.510911e-01 -1.712425e-01 -7.163212e-02  1.810955e-01  8.962858e-02  #>        params        params        params        params        params  #> -2.150714e-01 -3.808731e-02  2.005794e-01  2.046720e-02 -1.889520e-01  #>        params        params        params        params        params  #>  5.045731e-02  1.254563e-01 -5.315440e-03 -1.319711e-01  4.561258e-02  #>        params        params        params        params        params  #>  1.574013e-01 -8.553873e-02 -1.130256e-01  1.392581e-01  1.081628e-02  #>        params        params        params        params        params  #> -7.757039e-02 -3.295611e-02  2.639818e-02  8.123818e-02 -3.865452e-02  #>        params        params        params        params        params  #> -6.998228e-02  1.467173e-02  7.241144e-02 -1.128534e-02 -8.720973e-02  #>        params        params        params        params        params  #>  8.108630e-03  8.316732e-02 -2.468066e-02  2.586809e-03 -7.554319e-04  #>        params        params        params        params        params  #> -7.257835e-02  3.037401e-02  1.165830e-01 -1.002377e-01 -9.919561e-02  #>        params        params        params        params        params  #>  1.209433e-01  3.064010e-02 -8.642897e-02  7.491963e-02 -4.535475e-02  #>        params        params        params        params        params  #> -6.703071e-02  8.723632e-02  4.807756e-02 -9.014383e-02  1.343315e-02  #>        params        params        params        params        params  #>  4.295778e-03 -4.030916e-02  7.575340e-02  1.585366e-02 -9.703117e-02  #>        params        params        params        params        params  #>  7.145315e-03  2.509495e-02 -1.568298e-02 -1.155331e-02  1.704822e-03  #>        params        params        params        params        params  #>  3.350791e-03  1.860049e-03 -4.582404e-03 -1.358521e-03  1.805979e-02  #>        params        params        params  #>  3.190466e-03 -1.310191e-02  5.000000e+02  #>  #> $objective #> [1] 161891.9 #>  #> $convergence #> [1] 1 #>  #> $iterations #> [1] 3250 #>  #> $evaluations #> function gradient  #>    10000     3250  #>  #> $message #> [1] \"function evaluation limit reached without convergence (9)\" simulated_incidence = filter(simulator$report(.phases = \"during\"), matrix == \"incidence\")$value #> Constructing atomic D_lgamma plot(measles$date, measles$cases, xlab = \"time\", type = \"l\") lines(measles$date, simulated_incidence, col = 2)"},{"path":"https://canmod.github.io/macpan2/articles/calibration.html","id":"challenging-logistic-variation-in-transmission-rate","dir":"Articles","previous_headings":"","what":"Challenging Logistic Variation in Transmission Rate","title":"Calibrating Compartmental Models to Data","text":"consider problem fitting SIR model simulated dataset model, simulations pose challenges fitting machinery. simulation model includes logistically time-varying transmission rate.  Fitting simulation data, manages converge, wrong value.  fit good! ? find plot likelihood surface arrows representing magnitude direction -hill gradient towards optimum. Notice flat gradient direction along valley containing optimum \\((0, 1)\\). gradient pointing towards valley along . understand .   Explore carefully: fixme: causes spikiness along ridge? Add points optimization attempt stopped? experimental: working DEoptim (haven’t included yet don’t want Suggest: DEoptim … fixme: also add multi-start example (.e. less fancy DEoptim, suitable surfaces like one multimodal smooth (ref. Raue et al. “Lessons Learned Quantitative Dynamical Modeling Systems Biology” 2013)?) fixme: warning $current$params_vector() mutable/unreliable. Extractor $ad_fun()$env$last.par.best (equivalently optim fit)? fixme: add (abbreviated) sessionInfo output? (Package versions?)","code":"sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) sir$flows_expanded() #>   from to  flow       type #> 1    S  I   foi per_capita #> 2    I  R gamma per_capita n = 2500 set.seed(1L) simulator = sir$simulators$tmb(       time_steps = n     , state = c(S = 100000 - 500, I = 500, R = 0)     , flow = c(foi = NA, gamma = 0.2)#, wane = 0.01)     , beta = 1     , N = 100000     , X = cbind(1, scale(seq_len(n)))     , b = c(0, 1)     , incidence = empty_matrix     , beta_values = empty_matrix     , .mats_to_save = c(\"state\", \"incidence\", \"beta\")     , .mats_to_return = c(\"state\", \"incidence\", \"beta\") )$insert$expressions(     beta_values ~ 1 / (1 + exp(-X %*% b))   , .phase = \"before\"   , .at = Inf )$insert$expressions(     beta ~ beta_values[time_step(1)]   , .phase = \"during\"   , .at = 1 )$insert$expressions(     incidence ~ I   , .vec_by_states = \"total_inflow\"   , .phase = \"during\"   , .at = Inf )$replace$params(     default = c(0, 1)   , mat = rep(\"b\", 2)   , row = 0:1 ) set.seed(5L) sims = simulator$report(.phases = \"during\") (sims   |> mutate(variable = if_else(matrix == \"state\", row, matrix))   |> ggplot()   + facet_wrap(~ variable, ncol = 1, scales = 'free')   + geom_line(aes(time, value)) ) set.seed(3L) ## different seeds do result in convergence on the correct value reports = filter(sims, matrix == \"incidence\")$value simulator$add$matrices(reports = reports, report_sim = empty_matrix) simulator$insert$expressions(     report_sim ~ rbind_time(incidence)   , .phase = \"after\"   , .at = Inf ) simulator$replace$obj_fn(~ -sum(dpois(reports, report_sim))) simulator$replace$params(     default = rnorm(2L) ## random starting values for the optimizer   , mat = rep(\"b\", 2)   , row = 0:1 ) simulator$optimize$nlminb() #> outer mgc:  11268970  #> Constructing atomic D_lgamma #> outer mgc:  7215054  #> outer mgc:  3087372  #> outer mgc:  3522804  #> outer mgc:  470268.8  #> outer mgc:  802897.8  #> outer mgc:  133686.6  #> outer mgc:  4449.854  #> outer mgc:  5.260259  #> outer mgc:  8.0225e-06 #> $par #>     params     params  #> -1.0929130  0.1633477  #>  #> $objective #> [1] 326073.6 #>  #> $convergence #> [1] 0 #>  #> $iterations #> [1] 9 #>  #> $evaluations #> function gradient  #>       12       10  #>  #> $message #> [1] \"both X-convergence and relative convergence (5)\" simulator$current$params_frame() #>   par_id mat row col    default    current #> 1      0   b   0   0 -0.9619334 -1.0929130 #> 2      1   b   1   0 -0.2925257  0.1633477 fitted_incidence = (simulator$current$params_vector()   |> simulator$report()   |> filter(matrix == \"incidence\")   |> pull(value) ) plot(reports, type = \"l\") lines(fitted_incidence, col = 2) make_liksurf <- function(lwr = c(-1, 0), upr = c(1, 2),                          n = c(41, 41)) {     lik_surf = expand.grid(         intercept_parameter = seq(from = lwr[1], to = upr[1],                                    length.out = n[1]),         slope_parameter = seq(from = lwr[2], to = upr[2],                               length.out = n[2])     )     gr = t(apply(lik_surf, 1, simulator$gradient))     lik_surf$z = apply(lik_surf, 1, simulator$objective)     gr = 0.1 * gr / max(abs(gr))     lik_surf$gx = gr[,1]     lik_surf$gy = gr[,2]     return(lik_surf) } lik_surf <- make_liksurf() mk_plot <- function(dd, arrows = TRUE, contours = TRUE,                     arrow_len = 0.05,                     cbrks = (1:10)*1e5) {     gg0 <- (ggplot(dd, aes(intercept_parameter, slope_parameter))         + geom_tile(aes(fill = z))         + theme_bw()         + scale_x_continuous(expand = c(0,0))         + scale_y_continuous(expand = c(0,0))         + annotate(geom = \"point\", x = 0, y = 1, colour = \"yellow\", size = 2,                    pch = 16)         + scale_fill_continuous(trans = \"log10\")      )     if (contours) {         gg0 <- gg0 + geom_contour(aes(z = z), colour = \"red\",                                   breaks = cbrks)     }     if (arrows) {         gg0 <- gg0 + geom_segment(                          data = dd[seq(nrow(dd)) %% 5 == 0 , ],                          aes(                              xend = intercept_parameter - gx,                               yend = slope_parameter - gy                          ),                           arrow = arrow(length = unit(arrow_len, \"inches\")),                           colour = 'white'                      )     }     gg0 } print(mk_plot(lik_surf)) lik_surf2 <- make_liksurf(lwr = c(-0.1, 0.9), upr = c(0.1, 1.1)) print(mk_plot(lik_surf2, arrows = FALSE, cbrks = 1e4*(1:10))) make_mat <- function(x) {   with(x, matrix(z, sqrt(length(z)),             dimnames = list(intercept = unique(intercept_parameter),                             slope = unique(slope_parameter)))        ) } library(rgl) z1 <- make_mat(lik_surf) persp3d(as.numeric(rownames(z)), as.numeric(colnames(z)), log10(z),         col = \"gray\") z2 <- make_mat(lik_surf2) persp3d(as.numeric(rownames(z2)), as.numeric(colnames(z2)), log10(z2),         col = \"gray\") library(DEoptim) set.seed(101) fit <- DEoptim(simulator$objective, lower = rep(-10, 2), upper = rep(10, 2)) fitted_incidence = (simulator$ad_fun()$env$last.par.best     |> simulator$report()     |> filter(matrix == \"incidence\")     |> pull(value) ) plot(reports, type = \"l\") lines(fitted_incidence, col = 2)"},{"path":"https://canmod.github.io/macpan2/articles/composing_simulation_models.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Composing Related Simulation Models","text":"defining epidemiological model users often want compute quantities summarize . Examples include simple single-number quantities like R0, Gbar, r, well elaborate objects like stable compartment distribution linearized model. Methods computing summaries arbitrary models deep research area, making difficult include general purpose software. However, always (strong?) possible use brute force simulation methods approximating values. simulation approach take McMasterPandemic. approach modify focal model simulations modified model can used approximate summaries focal model. example, one scale population size 1 zeros compartments except one exposed category. Simulations cohort models generate force infection time-series, turns sum finite length time-series approximation R0. Sometimes summaries computed descriptive purposes, focus use semi-automatically refining calibrations. example, calibrations can often improved including prior information model parameters using Bayesian estimation. can easier get prior information summaries like R0 model parameters. case one might want regularize calibrations using priors R0. another example, helps initialize state vector simulation model using eigenvector linearization focal model. eigenvector often interpretable stable compartment distribution, unrealistic model fluctuations near beginning epidemic often minimized. Another use case model composition occurs online forecasting. forecasts made every n days, forecast n-day period. forecasts model can improved. One simple way carry information previous forecasts forward next forecasting model use final value state vector initial value new model. cases, start focal model generate several related models computing summaries like R0, eigenvectors, final state vectors. combine outputs models produce improved calibrations focal model.","code":""},{"path":"https://canmod.github.io/macpan2/articles/composing_simulation_models.html","id":"notation-and-theory","dir":"Articles","previous_headings":"","what":"Notation and Theory","title":"Composing Related Simulation Models","text":"developing general modelling software, need general theory assumptions. trajectory model model following. Takes parameter vector, \\(\\theta\\), initial state vector, \\(x\\) Simulates changes \\(x\\), referred trajectories Compares simulations observed time-series, \\(y\\) Returns objective function measures deviation simulated trajectories observed time-series trajectory model contains two functions. function, \\(g(\\theta; x)\\), parameter initial state vector, returns final state vector objective function, \\(f(\\theta; x; y)\\) often omit \\(y\\) notational compactness simply write \\(f(\\theta; x)\\). One may estimate \\(\\theta\\) \\(\\hat{\\theta}\\) optimizing \\(f\\) \\(\\theta\\) given \\(x\\) \\(y\\). strategy \\(x\\) must assumed. course user free try jointly calibrate \\(\\theta\\) \\(x\\). represent approach mathematically assuming \\(\\theta\\) can used determine \\(x\\). cases \\(x\\) determined \\(\\theta\\), omit \\(x\\) write final state vector objective functions \\(g(\\theta)\\) \\(f(\\theta)\\). practice however, often enough information observed time series take approach. Furthermore, approach can computationally slow. discuss alternatives naive calibration approaches use single trajectory model. alternatives make use compositions combinations several related trajectory models. approaches focal trajectory model, focus inference forecasting. focal model able generate one models can used improve calibrations focal model.","code":""},{"path":"https://canmod.github.io/macpan2/articles/composing_simulation_models.html","id":"online-forecasting","dir":"Articles","previous_headings":"","what":"Online Forecasting","title":"Composing Related Simulation Models","text":"Consider sequence trajectory models result following sequence objective functions, \\(f_1(\\theta_1;x_1), ..., f_n(\\theta_n;x_n)\\). simplicity, assume model state space potentially different parameter spaces. Let final state model \\(\\) \\(g_i(\\theta_i;x_i)\\). Assume time split \\(n+1\\) equally-sized adjacent intervals \\(\\theta_i\\) calibrated data \\(\\)th interval model \\(\\) used forecast data interval \\(+1\\). simple mechanism setting initial state vector models \\(= 1\\) set objective function \\(+1\\)th model \\(f_{+1}(\\theta_{+1};x_{+1} = g_i(\\hat{\\theta}_i;x_i))\\), \\(\\hat{\\theta}_i\\) calibrated parameter vector model \\(\\). objective function fast evaluate relative objective function needs calibrate initial state vector. procedure work well forecasts sufficiently accurate forecast period. However, can improved upon fitting \\(\\)th model forecasted data observed, using final state predicted model initial state next forecasting model.","code":""},{"path":"https://canmod.github.io/macpan2/articles/composing_simulation_models.html","id":"eigenvector-state-initialization","dir":"Articles","previous_headings":"","what":"Eigenvector State Initialization","title":"Composing Related Simulation Models","text":"previous online forecasting setup consider determine initial state vector, \\(x_1\\), first model. approach achieving initialize state vector using eigenvector linearized version model. construct objective function fitting model assume two trajectory models parameter state space. Let initial state focal model given \\(x\\) (possibly modified) eigenvector (possibly modified) linearized model given \\(g_0(\\theta)\\). let objective function focal model \\(f(\\theta;x)\\). avoid needing specify fit reasonable value \\(x\\) calibration step, one use following modified objective function, \\(h(\\theta) = f(\\theta;x = g_0(\\theta))\\). hidden computational difficulty however. McMasterPandemic uses TMB computational engine. TMB uses automatic differentiation efficiently provide gradients objective functions. Optimizers can make use gradients converge fewer iterations. However, TMB return gradients simulations respect parameters. means gradients return TMB \\(f(\\theta;x = g_0(\\theta))\\) take account effect \\(\\theta\\) \\(x\\) \\(g_0\\). means optimization using state-initialization approach able utilize TMB’s speed benefits.","code":""},{"path":"https://canmod.github.io/macpan2/articles/composing_simulation_models.html","id":"priors-on-r0","dir":"Articles","previous_headings":"","what":"Priors on R0","title":"Composing Related Simulation Models","text":"construct objective function, \\(f(\\theta)\\) prior component one needs two related trajectory models, returns scalar-valued function model parameters, \\(\\theta\\). focal model function, \\(g(\\theta)\\), returns negative log likelihood cohort model function, \\(h(\\theta)\\), approximates R0 returns negative log prior density value overall objective function given \\(f(\\theta) = g(\\theta) + h(\\theta)\\), fast evaluate extent \\(g\\) \\(h\\) fast evaluate.","code":""},{"path":"https://canmod.github.io/macpan2/articles/composing_simulation_models.html","id":"regenerating-versus-reparameterizing-models","dir":"Articles","previous_headings":"","what":"Regenerating Versus Reparameterizing Models","title":"Composing Related Simulation Models","text":"framework can used model important computational reality using TMB, McMasterPandemic. want change initial state vector can either regenerating model new initial state, reparameterizing model changes parameter vector induce changes initial state. TMB, objective functions simulation functions can take one parameter vector. notation, model parameter vector \\(\\theta\\). models require regeneration, \\(f(\\theta;x)\\), assume \\(x\\) constant feature model. change \\(x\\) means recreating model objects including \\(f\\) \\(g\\) can much slower reparameterizing model, particularly want iteratively make changes state vector. Models explicit initial state, \\(f(\\theta)\\), assume initial state can changed passing different parameter vector, \\(\\theta\\), faster case model objects need iteratively regenerated. use cases , used regeneration approach. can modify use reparameterization.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"The C++ Side","text":"document assumes solid understanding template model builder.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"matrices","dir":"Articles","previous_headings":"","what":"Matrices","title":"The C++ Side","text":"list numerical scalars, vectors, matrices passed input variables R C++. Scalars passed 1--1 matrices vectors n--1, numerical variables actually matrices. Treating numerical objects matrices might seem strange, similar R treats numerical objects vectors. way, R matrices vectors dimensions. just extending logic requiring vectors dimensions. restrictive R however allowing multidimensional arrays. Missing values allowed matrix. R side variables associated unique name, C++ side names associated 0-based index. indices spec 0-based. matrices must zero rows columns. matrix either zero rows zero columns empty matrix. Empty matrices allow placeholders matrices defined simulations. matrices passed using DATA_STRUCT(mats) TMB macro, associated C++ struct extracting component matrices index.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"parameters","dir":"Articles","previous_headings":"","what":"Parameters","title":"The C++ Side","text":"Two vectors parameters passed C++. PARAMETER_VECTOR(params) – vector becomes argument objective function, can therefore optimized using non-linear optimizer simulated using MCMC PARAMETER_VECTOR(random) – vector becomes random effects integrated objective function using Laplace approximation values parameter vectors used update certain elements matrix-valued variables within mats. elements updated described R side two data frames one row every matrix element replaced. data frames constructed R passed C++. columns data frame associated params following. DATA_IVECTOR(p_par_id) – indices params vector giving parameter use updating element mats updated DATA_IVECTOR(p_mat_id) – indices mats giving matrices elements replaced parameters DATA_IVECTOR(p_row_id) – indices rows within matrix associated element replaced parameters DATA_IVECTOR(p_col_id) – indices columns within matrix associated element replaced parameters vectors read C++, loop executed rows table replaces associated mats elements params elements. random vector treated similarly params associated data frame describing elements mats replaced. names columns table : DATA_IVECTOR(r_par_id) DATA_IVECTOR(r_mat_id) DATA_IVECTOR(r_row_id) DATA_IVECTOR(r_col_id) implied convention p stands ‘fixed Parameters’ r ‘Random parameters’.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"trajectory-simulation","dir":"Articles","previous_headings":"","what":"Trajectory Simulation","title":"The C++ Side","text":"input matrices mats updated using params random, matrices can modified. refer process modification trajectory simulation. three phases trajectory simulation process. simulation loop simulation loop simulation loop Simulation time measured dimensionless iterations, indexed integer, t, 0 <= t <= T+1, T number iterations loop. value matrix t = 0 value matrix just first iteration simulation loop begins. value matrix 0 < t < T+1 value matrix end tth iteration simulation loop. value matrix t = T+1 value matrix end simulation. time-indexing system used two purposes. optionally return simulation history user matrix modifications depend past values user can opt uses per-matrix basis, specifying two vectors one element per matrix. Equals 0 matrix overwritten simulation iteration, t Equals 1 computed values matrix saved Equals 0 matrix returned R side end simulation Equals 1 otherwise number iterations, T, passed TMB DATA_INTEGER(time_steps).","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"expressions","dir":"Articles","previous_headings":"","what":"Expressions","title":"The C++ Side","text":"mathematical details matrices modified simulation process controlled R side supplying expressions. expression right-hand-side R formula involving following three types objects. Names matrices mats Names functions currently allowed engine Numeric literals (e.g. 3.14) simulation sequential evaluation expressions user-specified order. expression may evaluated one three simulation phases – , , simulation loop. Expressions evaluated simulation loop evaluated , whereas evaluated loop evaluated every iteration. phase expression controlled DATA_IVECTOR(eval_schedule) vector described end section. mathematical expression can used C++ several ways. Information expression used passed C++ using set vectors. vectors length, one element per expression. Index mats identifying matrix produced expression Identifies whether expression evaluated inside SIMULATE macro within TMB value 0 indicates expression evaluated without SIMULATE macro (expect standard case), whereas value 1 indicates evaluation inside SIMULATE macro Note expression evaluated SIMULATE macro returned user mats_return == 1, must also returned within SIMULATE macro Number rows associated expression parse table (see section Parse Tables) expression evaluated order appears vectors. DATA_IVECTOR(eval_schedule) vector gives phase expressions evaluated. vector three elements giving number expressions evaluate , , simulation loop. particular first eval_schedule[0] expressions evaluated simulation loop, next eval_schedule[1] expressions evaluated every iteration simulation loop, next eval_schedule[2] expressions evaluated simulation loop. Inputs invalid sum elements eval_schedule equal number elements expr_output_id, expr_sim_block, expr_num_p_table_rows.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"parse-tables","dir":"Articles","previous_headings":"","what":"Parse Tables","title":"The C++ Side","text":"expression parsed table numbers represents expression can passed C++. row table corresponds step process evaluating expression. steps correspond one three types things, identified column n: function – n > 0 – see section Function Definitions matrix – n == 0 – see section Matrices literal – n == -1 – see section Literals row correspond function, column n gives number arguments function. column, x, gives index looking specific instance three types entities. example, n == 0 x column gives index mats list getting appropriate matrix n == -1 x gives index literals n > 0 x gives index list valid functions. column relevant functions, indicates row table representing first argument function. table processed C++ side recursive function either: rows associated functions: looks valid function list function definitions, recursively calls rows associated matrices: looks returns matrix mats list rows associated literals: looks returns literal list valid literals parse tables expressions concatenated row-wise passed C++ set three vectors equal length. DATA_IVECTOR(p_table_n) DATA_IVECTOR(p_table_x) DATA_IVECTOR(p_table_i) first three vectors correspond n, x, discussed section. expr_num_p_table_rows vector (defined section Expressions) used relate expression set rows concatenated parse table. elements vector contain number parse table rows associated expression. ordering elements consistent ordering concatenation individual parse tables, row indices necessary.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"literals","dir":"Articles","previous_headings":"","what":"Literals","title":"The C++ Side","text":"global list valid literals expressions passed C++ numeric vector, DATA_VECTOR(literals).","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"function-definitions","dir":"Articles","previous_headings":"","what":"Function Definitions","title":"The C++ Side","text":"functions used [Expression] must valid list functions defined C++ side. functions analogues R side make easy possible R users reason expressions. Valid functions take one matrix-valued arguments return single matrix. number arguments need known model defined, functions may optionally require predefined number arguments. Extending functionality engine typically involve simply adding function definitions list valid functions. function definitions following objects available . r – list matrices giving arguments function (e.g. r[0] returns first matrix). index2mats – list integers giving indices identifying matrices mats list (e.g. index2mats[0] returns index first argument). t – Time step hist – list lists matrices giving history simulation (e.g. hist[4][0] returns value first matrix time step 4). n – number arguments. Function definitions grouped types several functions require similar processing. main example element-wise binary operators, including +, *, -, /, ^. functions require pre-processing make sure matrix dimensions two operands compatible compatibility conveniently defined user.","code":""},{"path":"https://canmod.github.io/macpan2/articles/cpp_side.html","id":"objective-function","dir":"Articles","previous_headings":"","what":"Objective Function","title":"The C++ Side","text":"return value objective function expression depend values matrices end simulation entire saved simulation history. expression passed parse table. DATA_IVECTOR(o_table_n) DATA_IVECTOR(o_table_x) DATA_IVECTOR(o_table_i) implied convention o ‘Objective function parse table’ p ‘matrix Parse table’.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"principles","dir":"Articles","previous_headings":"","what":"Principles","title":"Development Principles and Patterns","text":"trade-offs among principles, good guidelines.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"small-classes","dir":"Articles","previous_headings":"Principles","what":"Small Classes","title":"Development Principles and Patterns","text":"able see whole constructor definition single screen – OK doesn’t happen though.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"avoid-modifying-well-tested-classes","dir":"Articles","previous_headings":"Principles","what":"Avoid Modifying Well-Tested Classes","title":"Development Principles and Patterns","text":"Extension better done introducing new classes, rather new methods. Big classes hard reason , test, stabilize.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"linear-inheritance","dir":"Articles","previous_headings":"Principles","what":"Linear Inheritance","title":"Development Principles and Patterns","text":"Classes inherit multiple parents.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"shallow-inheritance-hierarchy","dir":"Articles","previous_headings":"Principles","what":"Shallow Inheritance Hierarchy","title":"Development Principles and Patterns","text":"Parent classes may multiple children, cases hierarchy shallow simple. example, consider alternatives children inherit directly intermediate parent. things like start happen, usually best just extend intermediate parent can inherit directly Base class.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"balance-regeneration-with-consistency","dir":"Articles","previous_headings":"Principles","what":"Balance Regeneration with Consistency","title":"Development Principles and Patterns","text":"naive approach keeping components objects consistent regenerate object every change. continual regeneration can expensive. best avoid trade-much possible making fields cheap compute methods always recompute user asking . fields expensive regenerate therefore need stored regenerated necessary.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"patterns","dir":"Articles","previous_headings":"","what":"Patterns","title":"Development Principles and Patterns","text":"design patterns complying principles.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"alternative-classes","dir":"Articles","previous_headings":"Patterns","what":"Alternative Classes","title":"Development Principles and Patterns","text":"Alterative versions class set methods initial version. needs change becomes easy swap one alterative another. example, Reader() classes single method – $read() – without arguments. Therefore, bit functionality requires data read can modified simply writing new reader swapping old one, without needing modify code calls $read() method. methods alternative classes return type object, obviously return value can vary.","code":""},{"path":"https://canmod.github.io/macpan2/articles/development_patterns.html","id":"types-of-object-components","dir":"Articles","previous_headings":"Patterns","what":"Types of Object Components","title":"Development Principles and Patterns","text":"following types object components. Standard methods – Methods computing returning values derived arguments constructor Composition – Objects fields methods Args – Fields storing arguments constructor Static – Fields storing values derived arguments constructor $refesh() method can called update #3 components -place Private methods – Methods called methods class decide kind component use piece information depend following considerations. Standard methods used cheap run, regeneration consistency balanced. pattern generally preferred option, simplest reason maintain directly ensures consistency. Composition objects classes looks like . developers users can following. keeps classes small B can methods instead , small classes easier test stabilize. Testing can focus methods directly , can extended composing new classes like B. Static fields used expensive compute. Consistency can managed producing static fields $refresh() method – good way balance regeneration consistency. way, developers classes composed components can make use $refresh() method reliably keep everything --date consistent. way static fields $refresh() methods work together balance cost regeneration necessity consistency. constructor, $refresh() pattern looks like . Private methods used methods class. nothing stoping developer user calling private method, guarantee private method consistent behaviour even exist. communicate privacy, private methods start dot following example shows.","code":"A = function(...) {   ...   self$b = B(self)   ... } ... B = function(a) {   ...   self$a = a   ... } a = A(...) a$b$method(...) A = function(...) {   ...   self$refresh = function() {     self$expensive_field_1 = f_1(...)     ...     self$expensive_field_n = f_n(...)   }   self$refresh()   ...   self$b = B(a) } ... B = function(a) {   ...   self$a = a  ## an instance of `A`   ...   self$method_to_modify_a = function(...) {...}   self$a$refresh()   ... } A = function(...) {   ...   self$.private = function(...) {...}   ...   self$public = function(...) {     ...     self.private(...)     ...   } }"},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"the-problem","dir":"Articles","previous_headings":"","what":"The Problem","title":"Elementwise Binary Operators","text":"C++ engine every variable matrix. simple situation every variable matrix, elementwise binary operations can defined convenient properties. problem properties standard R, probably case numeric variables matrices. Differences standard R mathematical functions McMasterPandemic C++ engine make difficult test engine. document describes use R elementwise binary operators comparable engine. Consider following three related matrices. relate together x number rows, y number columns. Note although dimensionally related, three objects different shape x y one column row respectively, whereas one row column. relationships might naturally want multiply every column column vector x, R get following error. define rigorously convenient properties expect elementwise binary operators variables matrices, show convert elementwise binary operators R operators properties.","code":"A = matrix(rnorm(6), 3, 2)  # 3 by 2 matrix x = matrix(rnorm(3))        # 3 by 1 matrix y = t(rnorm(2))             # 1 by 2 matrix try(A * x) #> Error in A * x : non-conformable arrays"},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"definition-of-an-elementwise-binary-operator-in-the-c-engine","dir":"Articles","previous_headings":"","what":"Definition of an Elementwise Binary Operator in the C++ Engine","title":"Elementwise Binary Operators","text":"Consider generic binary operator, \\(\\otimes\\), operates two scalars produce third. can overload operator take two matrices, \\(x\\) \\(y\\), return third matrix, \\(z\\). \\[ z = x \\otimes y \\] elements \\(z\\) given following expression. \\[ z_{,j} = \\cases{ \\begin{array}{lll}   x_{,j} \\otimes y_{,j} & \\text{} n(x) = n(y) & \\text{} m(x) = m(y) & \\text{Standard Hadamard product} \\\\   x_{,j} \\otimes y_{,1} & \\text{} n(x) = n(y) & \\text{} m(y) = 1 & \\text{matrix column times column vector} \\\\   x_{,j} \\otimes y_{1,j} & \\text{} n(y) = 1 & \\text{} m(x) = m(y) & \\text{matrix row times row vector} \\\\   x_{,1} \\otimes y_{,j} & \\text{} n(x) = n(y) & \\text{} m(x) = 1 & \\text{Column vector times matrix column} \\\\   x_{1,j} \\otimes y_{,j} & \\text{} n(x) = 1 & \\text{} m(x) = m(y) & \\text{Row vector times matrix row} \\\\   x_{1,1} \\otimes y_{,j} & \\text{} n(x) = m(x) = 1  & & \\text{Scalar times matrix, vector scalar} \\\\   x_{,j} \\otimes y_{1,1} & \\text{} n(y) = m(y) = 1 & & \\text{Matrix, vector scalar times scalar} \\\\ \\end{array}} \\] functions \\(n()\\) \\(m()\\) give numbers rows columns respectively.","code":""},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"forcing-a-binary-operator-in-r-to-have-these-properties","dir":"Articles","previous_headings":"","what":"Forcing a Binary Operator in R to have these Properties","title":"Elementwise Binary Operators","text":"consider two matrix-valued operands, x y, standard binary operator, op (e.g. +), R.","code":""},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"step-1","dir":"Articles","previous_headings":"Forcing a Binary Operator in R to have these Properties","what":"Step 1","title":"Elementwise Binary Operators","text":"operands shape just operation. works R numeric operations vectorized anyways.","code":"eq = dim(x) == dim(y) if (all(eq)) return(op(x, y))"},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"step-2","dir":"Articles","previous_headings":"Forcing a Binary Operator in R to have these Properties","what":"Step 2","title":"Elementwise Binary Operators","text":"x either one row one column, define operation arguments swapped otherwise keep operator unchanged.","code":"vec_x = any(dim(x) == 1L) op1 = op if (vec_x) op1 = function(x, y) op(y, x)"},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"step-3","dir":"Articles","previous_headings":"Forcing a Binary Operator in R to have these Properties","what":"Step 3","title":"Elementwise Binary Operators","text":"Apply base-R sweep function, making sure matrix-like operand comes first.","code":"if (any(eq) & vec_x) return(sweep(y, which(eq), x, op1)) if (any(eq))         return(sweep(x, which(eq), y, op1))"},{"path":"https://canmod.github.io/macpan2/articles/elementwise_binary_operators.html","id":"implementation-and-examples","dir":"Articles","previous_headings":"Forcing a Binary Operator in R to have these Properties","what":"Implementation and Examples","title":"Elementwise Binary Operators","text":"BinaryOperator constructor uses algorithm. examples. tried operations naively, R engine complain. Note algorithm right thing commutative (e.g. *) non-commutative (e.g. ^) operators.","code":"times = BinaryOperator(`*`) pow = BinaryOperator(`^`) (A = matrix(1:6, 3, 2)) #>      [,1] [,2] #> [1,]    1    4 #> [2,]    2    5 #> [3,]    3    6 (x = matrix(1:3, 3)) #>      [,1] #> [1,]    1 #> [2,]    2 #> [3,]    3 (y = matrix(1:2, 1)) #>      [,1] [,2] #> [1,]    1    2 times(A, x) #>      [,1] [,2] #> [1,]    1    4 #> [2,]    4   10 #> [3,]    9   18 pow(A, y) #>      [,1] [,2] #> [1,]    1   16 #> [2,]    2   25 #> [3,]    3   36 try(A * x) #> Error in A * x : non-conformable arrays try(A ^ y) #> Error in A^y : non-conformable arrays identical(times(A, x), times(x, A)) #> [1] TRUE identical(pow(A, x), pow(x, A)) #> [1] FALSE"},{"path":"https://canmod.github.io/macpan2/articles/example_models.html","id":"finding-example-models","dir":"Articles","previous_headings":"","what":"Finding Example Models","title":"Example Models","text":"macpan2 comes set example model definitions, can listed show_models function. three things can items list: read , use , modify .","code":"show_models()"},{"path":"https://canmod.github.io/macpan2/articles/example_models.html","id":"reading-examples","dir":"Articles","previous_headings":"","what":"Reading Examples","title":"Example Models","text":"Suppose want read sir example go : https://github.com/canmod/macpan2/tree/main/inst/starter_models/sir. want see another model just switch sir another entry dir column table printed .","code":""},{"path":"https://canmod.github.io/macpan2/articles/example_models.html","id":"using-examples","dir":"Articles","previous_headings":"","what":"Using Examples","title":"Example Models","text":"use sir example can read R using following code. see actually generate simulations model see article. use another model, , replace sir another entry dir column .","code":"sir_dir = system.file(\"starter_models\", \"sir\", package = \"macpan2\") sir = Compartmental(sir_dir) sir$labels$all() #> [1] \"S\"     \"I\"     \"R\"     \"N\"     \"beta\"  \"foi\"   \"gamma\" sir$labels$state() #> [1] \"S\" \"I\" \"R\" sir$labels$flow() #> [1] \"foi\"   \"gamma\" sir$flows() #>   from to  flow       type from_partition to_partition flow_partition #> 1    S  I   foi per_capita            Epi          Epi            Epi #> 2    I  R gamma per_capita            Epi          Epi            Epi #>   from_to_partition from_flow_partition to_flow_partition #> 1                                                    Null #> 2                                                    Null"},{"path":"https://canmod.github.io/macpan2/articles/example_models.html","id":"modifying-examples","dir":"Articles","previous_headings":"","what":"Modifying Examples","title":"Example Models","text":"take sir jumping-point producing model one may use following code. running code can go files my_sir_dir modify see . Note typically want chose specific directory model instead using tempdir. still need read model usual way. look identical came , ’s just hasn’t modified … yet …","code":"my_sir_dir = file.path(tempdir(), \"my_sir\") model_starter(\"sir\", my_sir_dir) #> Classes 'ModelFiles', 'Files', 'Base' <environment: 0x55f72c541cf0>  #> derivations : function ()   #> flows : function ()   #> freeze : function ()   #> get : function (component_name, optional = FALSE)   #> settings : function ()   #> transmission_dimensions : function ()   #> transmission_matrices : function ()   #> variables : function () my_sir = Compartmental(my_sir_dir) my_sir$labels$all() #> [1] \"S\"     \"I\"     \"R\"     \"N\"     \"beta\"  \"foi\"   \"gamma\" my_sir$labels$state() #> [1] \"S\" \"I\" \"R\" my_sir$labels$flow() #> [1] \"foi\"   \"gamma\" my_sir$flows() #>   from to  flow       type from_partition to_partition flow_partition #> 1    S  I   foi per_capita            Epi          Epi            Epi #> 2    I  R gamma per_capita            Epi          Epi            Epi #>   from_to_partition from_flow_partition to_flow_partition #> 1                                                    Null #> 2                                                    Null"},{"path":"https://canmod.github.io/macpan2/articles/flow_types.html","id":"types-of-flows","dir":"Articles","previous_headings":"","what":"Types of Flows","title":"Flow Types","text":"Macpan2 library allows six different types flows. : per_capita absolute per_capita_inflow per_capita_outflow absolute_inflow absolute_outflow also demo model one flow type. Modelers can specify type given flow type column flows.csv file.","code":"flow_example_dir = system.file(\"starter_models\", \"flow_examples\", package = \"macpan2\") flow_example = Compartmental(flow_example_dir) flow_example$labels$state() #> [1] \"A\"     \"B\"     \"C\"     \"D\"     \"Dummy\" flow_example$labels$flow() #> [1] \"absin\"     \"absout\"    \"abs\"       \"percap\"    \"percapin\"  \"percapout\" flow_example$flows() #>    from    to      flow               type from_partition to_partition #> 1 Dummy     A     absin    absolute_inflow           Main         Main #> 2     A Dummy    absout   absolute_outflow           Main         Main #> 3     A     B       abs           absolute           Main         Main #> 4     B     C    percap         per_capita           Main         Main #> 5     C Dummy percapout per_capita_outflow           Main         Main #> 6     C     D  percapin  per_capita_inflow           Main         Main #>   flow_partition from_to_partition from_flow_partition to_flow_partition #> 1           Main                                                    Null #> 2           Main                                                    Null #> 3           Main                                                    Null #> 4           Main                                                    Null #> 5           Main                                                    Null #> 6           Main                                                    Null"},{"path":"https://canmod.github.io/macpan2/articles/flow_types.html","id":"per_capita-flows","dir":"Articles","previous_headings":"","what":"per_capita Flows","title":"Flow Types","text":"Probably common type flow per_capita flows move given proportion population compartment compartment. example two compartments B populations P_a P_b respectively linked per_capita flow flow rate r population decrease P_a * r per unite time population B increase equal amount. single time step population P_a - P_a * r population B P_b + P_a * r.","code":""},{"path":"https://canmod.github.io/macpan2/articles/flow_types.html","id":"absolute-flows","dir":"Articles","previous_headings":"","what":"Absolute Flows","title":"Flow Types","text":"Unlike per_capita flows, absolute flows specify change compartmental populations absolute terms. compartments B connected absolute flow rate r population decrease r per unite time population B increase equal amount. Thus single time step population P_a - r population B P_b + r.","code":""},{"path":"https://canmod.github.io/macpan2/articles/flow_types.html","id":"inflows-and-outflows","dir":"Articles","previous_headings":"","what":"Inflows and Outflows","title":"Flow Types","text":"Flows can also specified inflows outflows. Inflows increase population compartment effect population compartment. Similarly outflows decrease population compartment compartment. Inflows outflows can either per_capita flows absolute flows. example compartment absolute_outflow flow rate r single time step population P_a -r. Since outflows compartment population removed added anywhere, total population model decrease r. Alternatively, B compartment per_capita_inflow rate r compartment population B increase P_a * r per unite time. Notably, population changed total population model increase. single time step population B P_b + P_a * r population P_a (baring influence flows might ).","code":""},{"path":"https://canmod.github.io/macpan2/articles/flow_types.html","id":"specific-example","dir":"Articles","previous_headings":"","what":"Specific Example","title":"Flow Types","text":"created example model includes type flow. One key detail Macpan2 currently requires flows flows.csv file compartment. See . includes absolute_inflows compartment well absolute_outflows per_capita_outflows compartments. example explicitly used dummy compartment fulfill requirement, principle compartment can used dummy compartment since actual changes compartments population result used way. Note per_capita_inflows require compartment population compartment use compute total inflow compartment. one-sided flows though per_capita_inflows change population compartment. model includes absolute flows important chose starting values carefully prevent state populations going zero.","code":"flow_simulator = flow_example$simulators$tmb(    time_steps = 10,    state = c(A = 1000, B = 0, C = 0, D = 0, Dummy = 0),    flow = c(absin = 1000, absout = 500, abs = 100, percap = 0.5, percapout = 0.25, percapin=0.25)  ) flow_results = flow_simulator$report()  head(flow_results, 16) #>    matrix time   row col value #> 1   state    0     A      1000 #> 2   state    0     B         0 #> 3   state    0     C         0 #> 4   state    0     D         0 #> 5   state    0 Dummy         0 #> 6   state    1     A      1400 #> 7   state    1     B       100 #> 8   state    1     C         0 #> 9   state    1     D         0 #> 10  state    1 Dummy         0 #> 11  state    2     A      1800 #> 12  state    2     B       150 #> 13  state    2     C        50 #> 14  state    2     D         0 #> 15  state    2 Dummy         0 #> 16  state    3     A      2200"},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"read-models","dir":"Articles","previous_headings":"","what":"Read Models","title":"Hello Products","text":"read target product model, prod, two factor models, si age, R. goal document multiply si age see can recover target, prod.","code":"prod = Compartmental(prod_dir) si = Compartmental(si_dir) age = Compartmental(age_dir)"},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"types-of-variables","dir":"Articles","previous_headings":"","what":"Types of Variables","title":"Hello Products","text":"Model following set variables. variables categorized various types distinguish roles dynamics. state variables represent nodes compartmental diagram. model definition also recognizes two subsets states – infectious infected – models identical latency period. Note age model infection, types states present. flow variables represent flows states compartmental diagram. subset flows involved infection. variables neither states flows? can list variables. see variables age model states flows. also see si prod models transmission variable.","code":"si$variables$all() #>            Epi #> 1            S #> 2            I #> 3    infection #> 4     recovery #> 5 transmission age$variables$all() #>     Age #> 1 young #> 2   old #> 3 aging prod$variables$all() #>             Epi   Age #> 1             S young #> 2             S   old #> 3             I young #> 4             I   old #> 5     infection young #> 6     infection   old #> 7      recovery young #> 8      recovery   old #> 9             S aging #> 10            I aging #> 11 transmission si$variables$state() #>   Epi #> 1   S #> 2   I age$variables$state() #>     Age #> 1 young #> 2   old prod$variables$state() #>   Epi   Age #> 1   S young #> 2   I young #> 3   S   old #> 4   I   old si$variables$infectious_state() #>   Epi #> 1   I age$variables$infectious_state() #> [1] Age #> <0 rows> (or 0-length row.names) prod$variables$infectious_state() #>   Epi   Age #> 1   I young #> 2   I   old si$variables$infected_state() #>   Epi #> 1   I age$variables$infected_state() #> [1] Age #> <0 rows> (or 0-length row.names) prod$variables$infected_state() #>   Epi   Age #> 1   I young #> 2   I   old si$variables$flow() #>         Epi #> 1 infection #> 2  recovery age$variables$flow() #>     Age #> 1 aging prod$variables$flow() #>         Epi   Age #> 1 infection young #> 2 infection   old #> 3  recovery young #> 4  recovery   old #> 5         S aging #> 6         I aging si$variables$infection_flow() #>         Epi #> 1 infection age$variables$infection_flow() #> [1] Age #> <0 rows> (or 0-length row.names) prod$variables$infection_flow() #>         Epi   Age #> 1 infection young #> 2 infection   old si$variables$other() #>            Epi #> 1            S #> 2            I #> 3    infection #> 4     recovery #> 5 transmission age$variables$other() #> Warning in age$variables$other():  #> There are no other variables in this model #> except for state and flow variables. #> NULL prod$variables$other() #>             Epi   Age #> 1             S young #> 2             S   old #> 3             I young #> 4             I   old #> 5     infection young #> 6     infection   old #> 7      recovery young #> 8      recovery   old #> 9             S aging #> 10            I aging #> 11 transmission"},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"multiplying-variables","dir":"Articles","previous_headings":"","what":"Multiplying Variables","title":"Hello Products","text":"can recover kind variable prod model operating factor models, si age. state variables prod Cartesian product state variables si age. flow variables prod union two Cartesian products. variable prod, transmission., can obtained taking union variables si age. Putting together .","code":"cartesian(si$variables$state(), age$variables$state()) #>   Epi   Age #> 1   S young #> 2   I young #> 3   S   old #> 4   I   old prod$variables$state() #>   Epi   Age #> 1   S young #> 2   I young #> 3   S   old #> 4   I   old union_vars(   cartesian(si$variables$flow(), age$variables$state()),   cartesian(si$variables$state(), age$variables$flow()) ) #>         Epi   Age #> 1 infection young #> 2  recovery young #> 3 infection   old #> 4  recovery   old #> 5         S aging #> 6         I aging prod$variables$flow() #>         Epi   Age #> 1 infection young #> 2 infection   old #> 3  recovery young #> 4  recovery   old #> 5         S aging #> 6         I aging union_vars(si$variables$other(), age$variables$other()) #> Warning in age$variables$other():  #> There are no other variables in this model #> except for state and flow variables. #>            Epi #> 1            S #> 2            I #> 3    infection #> 4     recovery #> 5 transmission prod$variables$other() #>             Epi   Age #> 1             S young #> 2             S   old #> 3             I young #> 4             I   old #> 5     infection young #> 6     infection   old #> 7      recovery young #> 8      recovery   old #> 9             S aging #> 10            I aging #> 11 transmission union_vars(   cartesian(si$variables$state(), age$variables$state()),   cartesian(si$variables$flow(), age$variables$state()),   cartesian(si$variables$state(), age$variables$flow()),   si$variables$other(),   age$variables$other() ) #> Warning in age$variables$other():  #> There are no other variables in this model #> except for state and flow variables. #>             Epi   Age #> 1             S young #> 2             I young #> 3             S   old #> 4             I   old #> 5     infection young #> 6      recovery young #> 7     infection   old #> 8      recovery   old #> 9             S aging #> 10            I aging #> 11            S       #> 12            I       #> 13    infection       #> 14     recovery       #> 15 transmission prod$variables$all() #>             Epi   Age #> 1             S young #> 2             S   old #> 3             I young #> 4             I   old #> 5     infection young #> 6     infection   old #> 7      recovery young #> 8      recovery   old #> 9             S aging #> 10            I aging #> 11 transmission"},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"multiplying-flows","dir":"Articles","previous_headings":"","what":"Multiplying Flows","title":"Hello Products","text":"","code":"si_flows = si$flows() age_flows = age$flows() si_flows$from_to_partition = \"Age\" si_flows$from_flow_partition = \"Age\" age_flows$from_to_partition = \"Epi\" age_flows$from_flow_partition = \"Epi\" prod_flows = rbind(si_flows, age_flows) prod_flows #>    from  to      flow       type from_partition to_partition flow_partition #> 1     S   I infection per_capita            Epi          Epi            Epi #> 2     I   S  recovery per_capita            Epi          Epi            Epi #> 3 young old     aging per_capita            Age          Age            Age #>   from_to_partition from_flow_partition to_flow_partition #> 1               Age                 Age              Null #> 2               Age                 Age              Null #> 3               Epi                 Epi              Null prod$flows() #>    from  to      flow       type from_partition to_partition flow_partition #> 1     S   I infection per_capita            Epi          Epi            Epi #> 2     I   S  recovery per_capita            Epi          Epi            Epi #> 3 young old     aging per_capita            Age          Age            Age #>   from_to_partition from_flow_partition to_flow_partition #> 1               Age                 Age              Null #> 2               Age                 Age              Null #> 3               Epi                 Epi              Null"},{"path":[]},{"path":[]},{"path":[]},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"roadmap","dir":"Articles","previous_headings":"","what":"Roadmap","title":"Hello Products","text":"outline development needs take place order complete document. Add transmission matrix step StandardExprs Align transmission matrix specifications Pass required indices lining transmission matrix flow vector state vector.","code":""},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"scratch","dir":"Articles","previous_headings":"","what":"Scratch","title":"Hello Products","text":"","code":"prod$labels$state() #> [1] \"S.young\" \"I.young\" \"S.old\"   \"I.old\" prod$labels$flow() #> [1] \"infection.young\" \"infection.old\"   \"recovery.young\"  \"recovery.old\"    #> [5] \"S.aging\"         \"I.aging\" si$variables$all() #>            Epi #> 1            S #> 2            I #> 3    infection #> 4     recovery #> 5 transmission si$flows_expanded() #>   from to      flow       type #> 1    S  I infection per_capita #> 2    I  S  recovery per_capita age$variables$all() #>     Age #> 1 young #> 2   old #> 3 aging age$flows_expanded() #>    from  to  flow       type #> 1 young old aging per_capita prod$variables() prod$flows_expanded() UserExpr(prod)$expand_vector_expressions() prod$expr_list()$print_exprs()"},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"simulating-from-the-product-model","dir":"Articles","previous_headings":"","what":"Simulating from the Product Model","title":"Hello Products","text":"model definition hand works Specify numerical inputs Run simulation Verify results","code":""},{"path":"https://canmod.github.io/macpan2/articles/hello_products.html","id":"steps-in-taking-model-products","dir":"Articles","previous_headings":"","what":"Steps in Taking Model Products","title":"Hello Products","text":"nested set operations. Cartesian product state variables Cartesian product state flow variables (direction) Matrix product transmission matrix (lots variations available , example Kronecker product) modeller may choose just 1, just 1-2, 1-3.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"prerequisites","dir":"Articles","previous_headings":"","what":"Prerequisites","title":"Compartmental Model Definitions","text":"document assumes knowledge compartmental epidemic models. defining terms symbols consider widely understood mathematical epidemiologists.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"document-goals","dir":"Articles","previous_headings":"","what":"Document Goals","title":"Compartmental Model Definitions","text":"document describes specification data structure represent compartmental models. goal document define spec user interface constructing compartmental models. Instead, define data structure interfaces creating instances compartmental models can designed without needing grapple issues represent store model definitions.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"user-stories","dir":"Articles","previous_headings":"","what":"User Stories","title":"Compartmental Model Definitions","text":"spec design guided several high-level user stories, outline briefly. modeller, want use software provides extensive set modelling capabilities, can address specific changing public health needs. modeller, want build complex models simpler – easier understand – modular sub-models, can easily modify structure model public health needs change. developer, want able quickly add new modelling capability, can support public health modellers timely manner possible. user-stories developed working public-health modellers COVID-19 pandemic Canada.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"labelled-partitions-in-progress","dir":"Articles","previous_headings":"","what":"Labelled Partitions (in progress)","title":"Compartmental Model Definitions","text":"describing data structure representing Compartmental Models, need define concept labelled partitions. concept allows consistent, flexible, compact, readable mechanism identifying model variables sets variables. example, spatially structured model might want refer states particular location (e.g. Toronto) specific state within location (e.g. susceptible individuals Toronto). Labelled partitions can stored data frame. rows data frame represent things represented. primary example ‘thing’ variable compartmental model (e.g. number susceptible individuals Toronto, force infection). columns data frame represent different ways partition rows. Non-empty values cell must contain letters, numbers, underscores, must start letter. Empty labels zero-length strings can used indicate partitions applicable variables. purpose restrictions facilitate construction strings character vectors summarize different aspects labelled partition. taken together, summaries can inverted restore full labelled partition represent zero information loss. equivalence allows us go back--forth two representations without loosing information, perhaps gaining convenience. three types summaries: names, name, labels. names labelled partition column names corresponding data frame. name labelled partition dot-concatenation names, labels labelled partition dot-concatenation columns. labels give unique single character string referring variable. labels one either names name, one may recover labelled partition. labels provide convenient names variables – .e. rownames. convention use UpperCamelCase partition names modified form snake_case variable labels. modification snake case allows single uppercase letters order accommodate convention epidemiology using single uppercase letters refer state variables. example, S, , R, well I_mild I_severe, consistent modified snake case style.","code":"#>   Epi   Vax #> 1   S unvax #> 2   E unvax #> 3   I unvax #> 4   R unvax #> 5   S   vax #> 6   E   vax #> 7   I   vax #> 8   R   vax p$names() #> [1] \"Epi\" \"Vax\" p$name() #> [1] \"Epi.Vax\" p$labels() #> [1] \"S.unvax\" \"E.unvax\" \"I.unvax\" \"R.unvax\" \"S.vax\"   \"E.vax\"   \"I.vax\"   #> [8] \"R.vax\""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"compartmental-models","dir":"Articles","previous_headings":"","what":"Compartmental Models","title":"Compartmental Model Definitions","text":"compartmental model can represented directory following four files. variables – CSV file describing variables model. derivations – JSON file array instructions update variables iteration model simulation. flows – CSV file describing variables state variables magnitudes flows compartments. settings – JSON file object elements determine files 1-3 used software. following sections describe files detail.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"variables-and-partitions","dir":"Articles","previous_headings":"","what":"Variables and Partitions","title":"Compartmental Model Definitions","text":"variables.csv file row variable model one column labelled partition variables. labelled partition character vector labels describes variables. row file must unique uniquely identifies variable. example, list variables standard SIR model. example single labelled partition, Epi. partition uniquely identifies variable need partitions comply uniqueness requirement. stratify another factor (e.g. age groups locations) can add labelled partitions. emphasize list single Epi partition violate spec, required add partition make distinction state variables parameters. spec distinguishes Variable Roles like settings file. example, addition Type Infect partitions convenience. point user free add number partitions even required uniqueness. use term names strings identify partitions term labels strings identify variables respect particular partition. Note provide column numeric quantity variable spec compartmental model data structure. working pure model structure objects, can combine different atomic models easily produce models structure. comes time use model, computational engine can used associate model variables numerical quantities.","code":"#>     Epi #> 1     S #> 2     I #> 3     R #> 4     N #> 5  beta #> 6   foi #> 7 gamma"},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"required-partitions","dir":"Articles","previous_headings":"","what":"Required Partitions","title":"Compartmental Model Definitions","text":"component, settings$required_partitions, character vector names partitions used uniquely identify variable. previous example Type, Infect, Epi partitions settings$required_partitions == \"Epi\". refer labels associated required partitions required labels. Every variable must least one non-empty required label. required partitions used generate Variable Names.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"atomic-and-non-atomic-models","dir":"Articles","previous_headings":"","what":"Atomic and Non-Atomic Models","title":"Compartmental Model Definitions","text":"refer models exactly one required partition atomic. One may combine two atomic models get another model two required labelled partitions. example combination atomic models SEIR model stratified states atomic vaccination model required partition, Vax. atomic model unvax vax state variables representing numbers individuals unvaccinated vaccinated. dose_rate variable parameter giving proportion unvaccinated individuals receive vaccination day. combine two atomic models produce non-atomic model required partitions, Epi Vax. Note state variables, S, E, , R, well transmission rate, beta, stratified vaccination status, latency recovery parameters, alpha gamma, stratified indicating latency recovery influenced vaccination status. Similarly dose_rate also stratified epidemiological state. Consider one example different symptomatic statuses, infectious individuals either mild severe symptoms different statuses recover different rates.","code":"#>         Vax #> 1     unvax #> 2       vax #> 3 dose_rate #>      Epi       Vax #> 1      S     unvax #> 2      E     unvax #> 3      I     unvax #> 4      R     unvax #> 5   beta     unvax #> 6  alpha           #> 7  gamma           #> 8      N     unvax #> 9    foi     unvax #> 10     S       vax #> 11     E       vax #> 12     I       vax #> 13     R       vax #> 14  beta       vax #> 15 alpha           #> 16 gamma           #> 17     N       vax #> 18   foi       vax #> 19       dose_rate #>               Epi   Symp       Vax #> 1               S            unvax #> 2               E            unvax #> 3               I   mild     unvax #> 4               I severe     unvax #> 5               R            unvax #> 6            beta            unvax #> 7               S              vax #> 8               E              vax #> 9               I   mild       vax #> 10              I severe       vax #> 11              R              vax #> 12           beta              vax #> 13          alpha                  #> 14          gamma   mild           #> 15          gamma severe           #> 16 infectiousness   mild           #> 17 infectiousness severe           #> 18                       dose_rate"},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"variable-names","dir":"Articles","previous_headings":"","what":"Variable Names","title":"Compartmental Model Definitions","text":"Although row variables list provides unique identifier variable, convenient able combine required labels single string. call string variable name. name variable dot-delimited concatenation partitions settings$required_partitions associated variable. example, following table contains labelled partitions Epi--Symp--Vax variable list fourth column giving variable names. choice dot delimiter leads syntactically valid R names even name begins one dot. dots allowed labels , delimiter also makes parsing labels respective partitions unambiguous. Note impossible names dots variables must least one non-blank label. biggest downside choice dot delimiter conflicts tidyverse style, requires using dots specify S3 method dispatch. reason guideline reduce chances ambiguity S3 machinery searches methods. disadvantage opinion outweighed advantages list , model variables involved S3 dispatch. Variable names invertible, vector variable names can combined vector partition names reproduce associated labelled partitions. fact allows us choose either labelled partitions names representation depending convenience necessity.","code":"#>      Epi   Symp       Vax variable_names #> 1      S            unvax       S..unvax #> 2      E            unvax       E..unvax #> 3      I   mild     unvax   I.mild.unvax #> 4      I severe     unvax I.severe.unvax #> 5      R            unvax       R..unvax #> 6   beta            unvax    beta..unvax #> 7      S              vax         S..vax #> 8      E              vax         E..vax #> 9      I   mild       vax     I.mild.vax #> 10     I severe       vax   I.severe.vax #> 11     R              vax         R..vax #> 12  beta              vax      beta..vax #> 13 alpha                         alpha.. #> 14 gamma   mild              gamma.mild. #> 15 gamma severe            gamma.severe. #> 16              dose_rate    ..dose_rate"},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"variable-roles","dir":"Articles","previous_headings":"","what":"Variable Roles","title":"Compartmental Model Definitions","text":"Variable Names used lists identify variables specific roles model. least two lists settings.json file. settings$state_variables – Character vector giving names variables, tracks number individuals compartment. settings$rate_variables – Character vector giving names variables, determines per-capita rate flow one pairs compartments. Additional variable lists may used accommodate things absolute flow rates well sources sinks. state variables flow variables must scalars.","code":""},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"partition-sets","dir":"Articles","previous_headings":"","what":"Partition Sets","title":"Compartmental Model Definitions","text":"required_paritions component set partitions used uniquely identify variable generate invertible variable names. user free define partition_sets can refer groups variables name. sets can used filter variables specific purpose. partition_sets useful combining models. Variable names can used respect particular partition set. Variable names respect partition sets uniquely identify variable. example, Epi.Symp == \".mild\" occurs twice following example. ability refer multiple variables single name useful many circumstances. Typically non-unique names unique within groups variables. example, Epi.Symp == \".mild\" unique within Vax == \"vax\" within Vax == \"unvax\". examples illustrated, name partition set dot-delimited concatenation names partitions set. example, Epi.Symp name partition set containing Epi Symp partitions.","code":"#>      Epi   Symp       Vax     Epi.Symp    Epi.Vax #> 1      S            unvax           S.    S.unvax #> 2      E            unvax           E.    E.unvax #> 3      I   mild     unvax       I.mild    I.unvax #> 4      I severe     unvax     I.severe    I.unvax #> 5      R            unvax           R.    R.unvax #> 6   beta            unvax        beta. beta.unvax #> 7      S              vax           S.      S.vax #> 8      E              vax           E.      E.vax #> 9      I   mild       vax       I.mild      I.vax #> 10     I severe       vax     I.severe      I.vax #> 11     R              vax           R.      R.vax #> 12  beta              vax        beta.   beta.vax #> 13 alpha                        alpha.     alpha. #> 14 gamma   mild             gamma.mild     gamma. #> 15 gamma severe           gamma.severe     gamma. #> 16              dose_rate            . .dose_rate"},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"derived-variables","dir":"Articles","previous_headings":"","what":"Derived Variables","title":"Compartmental Model Definitions","text":"Now solid mechanism representing, referring , grouping model variables, can begin consider defining Flow Compartments. rate flow one compartment another given model parameter (e.g. recovery rate, gamma), straightforward describe flow compartments (e.g. R). However, flow rate function parameters state variables (e.g. force infection), first need define compute rate. section describe data structure representing mathematical expressions deriving model variables must recomputed iteration simulation. Flow rates force infection example derived variable. many examples, including sums groups (e.g. vaccinated) compartments, model summaries \\(\\mathcal{R}_0\\), convolutions infected compartments modelling -reporting reporting delays. derived variable must represented row variables list. Derived variables distinguished input variables associated element list, derivations. list contains objects describe compute derived variable. object contains following components. : Variable computed simulation loop. Intended variables must computed remain constant throughout simulation. during_pre_update: Variable re-computed loop simulation state variable updated. Intended variables depend state previous timestep. during_post_update: Variable re-computed loop simulation state variable updated. Intended variables depend state current timestep. : Variable computed simulation loop. Intended modifying simulation outputs comparable observed data. group_partition [optional] – name partition set use filtering grouping variables (1) subset variables utilized order produce derived variables (2) set derived variables can produced time producing one derived variable per group. group_partition missing, variables potentially utilized single derived variable. group_names group_partition missing – variables potentially utilized single derived variable length(group_names) == 1L – filtered subset variables get utilized single derived variable length(group_names) == n – variables n groups used produce one n derived variables output_partition [optional] – name partition set use declaring labels derived variables within group (see group_partition group_names producing one derived variable per group). output_partition given required partitions used. output_names [optional] – vector variable names respect output_partition, determine labels associated output_partition derived variable within group. group_names missing output_names must single variable name respect output_partition determining labels derived variable. Otherwise, ith element output_names determines labels derived variable produced ith element group_names. input_partition [optional] – name partition set use matching variables arguments expression. Every variable name respect input_partition must unique exist within group. input_partition given required partitions used. arguments [required expression arguments ...] – vector variable names respect input_partition. argument_dots [required expression ... argument] – vector variable names respect input_partition finding variables pass ... argument expression, exists. expression [required] – mathematical function producing one derived variable per group. names arguments function subset variable names respect input_partition optionally ... argument. TODO: Perhaps ‘compressed’ data format derivations, simple derived_var_name = function(...) ... used base case? compressed format can used form basis interface design? spec file hard understand first reading. understand better provide several examples designed justify clarify description bullet list. begin defining force infection SEIR model following variable list. force infection model can represented follows. atomic model, specifying output_partition = \"Epi\" output_names \"foi\", really just saying name output variable \"foi\". technically say derived variable label \"foi\" \"Epi\" partition. input_partition math_function go together. math_function describes compute derived variable, foi, terms variables. input_partition gives name partition set use matching model variables arguments function. example, argument list contains S, label Epi partition set. description may seem unnecessarily complex, useful representing complex models see. Also remember spec data structure user interface – likely user interface specifying component make much simpler . Updating derived variable specifications taking model products reasonably straightforward data structure. example, consider stratifying S, E, , R, beta geographic location. new model, functional form force infection remains constant simply update add partition sets variable names. define expressions produce derived variables called foi.montreal foi.toronto. get list following. Added geographical grouping information specify stratify force infection. Repeat entry output_names location. model product assumes individuals Toronto infected individuals Montreal. reasonable assumption spatial stratification, models stratification isolate compartments need add additional derived variable sums force infection components strata. Consider example SEIR model stratified vaccination status. can compute force infection components just spatial model. complete model product must add derived variable takes sum Epi == \"foi\" variables. produce single derived variable called foi.total, can used force infection vaccination strata. operations model space besides model products. Another operation convert single compartment several compartments. example operation break infectious compartment several symptomatic states. Notice \"Type\" partition indicates different forms symptomatic-status-structured variables represented. scalar components infectiousness can referred , one can refer vectors contain components. components .mild.component, .severe.component, infectiousness.mild.component, infectiousness.severe.component. vectors ..vector infectiousness..vector. variable ..effective refers weighted sum given inner product ..vector infectiousness..vector. assume component types input variables, derive infectiousness variables following definitions. ordering derivations list must topologically sorted dependencies expression appear earlier list. topological sorting requirement presents technical challenge models combined, becomes necessary able merge lists derivations remain topologically sorted.","code":"#>     Epi #> 1     S #> 2     I #> 3     R #> 4     N #> 5  beta #> 6   foi #> 7 gamma list(   output_partition = \"Epi\",   output_names = \"foi\",   input_partition = \"Epi\",   math_function = function(S, E, I, R, beta) {     I * beta / sum(S, E, I, R)   } ) #>      Epi                 Location #> 1      S                 montreal #> 2      E                 montreal #> 3      I                 montreal #> 4      R                 montreal #> 5   beta                 montreal #> 6      S                  toronto #> 7      E                  toronto #> 8      I                  toronto #> 9      R                  toronto #> 10  beta                  toronto #> 11 alpha                          #> 12 gamma                          #> 13       montreal_to_toronto_rate #> 14       toronto_to_montreal_rate list(   group_partition = \"Location\",   group_names = c(\"montreal\", \"toronto\"),   output_partition = \"Epi\",   output_names = c(\"foi\", \"foi\"),   input_partition = \"Epi\",   math_function = function(S, E, I, R, beta) {     I * beta / sum(S, E, I, R)   } ) #>      Epi       Vax #> 1      S     unvax #> 2      E     unvax #> 3      I     unvax #> 4      R     unvax #> 5   beta     unvax #> 6  alpha           #> 7  gamma           #> 8      N     unvax #> 9    foi     unvax #> 10     S       vax #> 11     E       vax #> 12     I       vax #> 13     R       vax #> 14  beta       vax #> 15 alpha           #> 16 gamma           #> 17     N       vax #> 18   foi       vax #> 19       dose_rate list(   group_partition = \"Vax\",   group_names = c(\"unvax\", \"vax\"),   output_partition = \"Epi\",   output_names = c(\"foi\", \"foi\"),   input_partition = \"Epi\",   math_function = function(S, E, I, R, beta) {     I * beta / sum(S, E, I, R)   } ) list(   output_partition = \"epi.vax\",   output_names = \"foi.total\",   input_partition = \"epi.vax\",   input_names_dots = c(\"foi.unvax\", \"foi.vax\"),   math_function = function(...) sum(...) ) #>               Epi EpiEffective   Symp      Type #> 1               S            S                  #> 2               E            E                  #> 3               I                mild component #> 4               I              severe component #> 5               I                        vector #> 6               I            I                  #> 7               R            R                  #> 8            beta         beta                  #> 9           alpha        alpha                  #> 10          gamma        gamma   mild           #> 11          gamma        gamma severe           #> 12 infectiousness                mild component #> 13 infectiousness              severe component #> 14 infectiousness                        vector #> 15            foi          foi list(   group_partition = \"Epi.Symp\",   group_names = c(\"I.mild\", \"I.severe\", \"infectiousness.mild\", \"infectiousness.severe\"),   output_partition = \"Epi.Type\",   output_names = c(\"I.vector\", \"infectiousness.vector\"),   input_partition = \"Symp\",   input_names_dots = c(\"mild\", \"severe\"),   math_function = function(...) c(...) ) # list( #   #group_partition = \"Epi\", #   #group_names = c(\"I\", \"I\", \"infectiousness.mild\", \"infectiousness.severe\"), #   output_partition = \"Epi.EpiEffective\", #   output_names = \"I.I\", #   input_partition = \"Epi.Symp\", #   input_names_dots = c(\"I.mild\", \"I.severe\", \"infectiousness.mild\", \"infectiousness.severe\"), #   math_function = function(...) { #     l = unlist(list(...)) #     n = length(l) #     sum(l[1:(n/2)] * l[((n/2)+1):n]) #   } # ) list(   group_partition = \"Type\",   group_names = \"vector\",   output_partition = \"EpiEffective\",   output_names = \"I\",   input_partition = \"Epi\",   math_function = function(I, infectiousness) {     sum(I * infectiousness)   } ) list(   output_partition = \"Epi\",   output_names = \"foi\",   input_partition = \"Epi\",   math_function = function(S, E, I, R) )"},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"flow-between-compartments","dir":"Articles","previous_headings":"","what":"Flow between Compartments","title":"Compartmental Model Definitions","text":"another data frame, flows, rows describing individuals flow pairs compartments. four required columns data frame, , , flow, type. – variable name compartment individuals flowing. – variable name compartment individuals flowing. flow – name variable governing magnitude flow. \"per_capita\" – flow equals * flow. \"absolute\" – flow equals flow. \"per_capita_inflow\" – flow equals * flow. \"per_capita_outflow\" – flow equals * flow. \"absolute_inflow\" – flow equals flow. \"absolute_outflow\" – flow equals flow. example, consider SIR model. following flows.csv file. Notice state variables appear table, contains parameters. mechanism encoding whether model variable state variables parameter. interesting example following Epi--Vax model. flows data frame variables look like following.","code":"#>     epi #> 1     S #> 2     I #> 3     R #> 4  beta #> 5 gamma #> 6   foi #>   from to  flow       type #> 1    S  I   foi per_capita #> 2    I  R gamma per_capita #>      Epi       Vax #> 1      S     unvax #> 2      I     unvax #> 3      R     unvax #> 4   beta     unvax #> 5      S       vax #> 6      I       vax #> 7      R       vax #> 8   beta       vax #> 9  alpha           #> 10 gamma           #> 11   foi           #> 12       dose_rate #>      from      to       flow       type #> 1 S.unvax I.unvax  foi.total per_capita #> 2 I.unvax R.unvax     gamma. per_capita #> 3   S.vax   I.vax  foi.total per_capita #> 4   I.vax   R.vax     gamma. per_capita #> 5 S.unvax   S.vax .dose_rate per_capita #> 6 I.unvax   I.vax .dose_rate per_capita #> 7 R.unvax   R.vax .dose_rate per_capita"},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"flows-in-structured-models","dir":"Articles","previous_headings":"","what":"Flows in Structured Models","title":"Compartmental Model Definitions","text":"Structured models can large number flows making flows data structure long. example, SEIR model three symptomatic status’, five vaccination status’, 30 geographic locations 750 flows depending details vaccination geographic models. length list ---main problem data structure. bigger problem data structure preserve model structure, making difficult visualize underlying simplicity. example, model structure preserved flows data possible automatically construct box diagrams communicating simplicity seemingly complex compartmental model. hand, benefit explicit data structure [Flows Compartments] easy read line. example, following line clearly tells unvaccinated exposed individuals flow unvaccinated infectious individuals mild symptoms rate independent vaccination status symptomatic status. section add columns data structure encoding model structure. additional columns make possible shorten list retain model structure information, cost making meaning line difficult decode. However, required, see, structured version can always converted simpler longer unstructured version. possible go unstructured structured. first three additional columns contain partition sets resolve names , , flow. Consider following example. Consider example within context SEIR model stratified two vaccination status’. case data structure allow us distinguish models S.unvax flows E.unvax one also allowed flow E.vax. address problem, need three partition columns matching valid S-E pairs. following table provides example .","code":"#>       from           to    flow       type #> 1 E..unvax I.mild.unvax alpha.. per_capita #>   from to flow       type from_partition to_partition flow_partition #> 1    S  E  foi per_capita            Epi          Epi            Epi #>   from to flow       type from_partition to_partition flow_partition #> 1    S  E  foi per_capita            Epi          Epi            Epi #>   from_to_partition from_flow_partition to_flow_partition #> 1               Vax"},{"path":[]},{"path":"https://canmod.github.io/macpan2/articles/model_definitions.html","id":"file-formats","dir":"Articles","previous_headings":"","what":"File Formats","title":"Compartmental Model Definitions","text":"CSV files following format. Column delimiter comma. quotes anywhere file. special missing value tokens. first row gives names partitions. row names. Additionally, characters allowed file uppercase lowercase letters, digits, underscores, commas. presence character sufficient invalidate file. settings.json file contains single object following key-value pairs. required_partitions – array strings state_variables – array strings flow_variables – array strings derivations.json file contains single array objects. objects following required key-value pairs. output_names – array strings expression – string objects following optional key-value pairs, although optional pairs become required given existence others. filter_names – array strings group_names – array strings input_names – array strings input_dots – array strings filter_partition – string group_partition – string output_partition – string input_partition – string","code":""},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"model-definition-files","dir":"Articles","previous_headings":"","what":"Model Definition Files","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"Models defined set four model definition files, housed directory: Installations macpan2 contain several starter models: simplest SIR model, can found directory: article, work specification simulation SIR sample model. can discover examples . make copy model (e.g. want modify ), can use model_starter(starter_name, dir_name), e.g. model_starter(\"sir\", \"~/my_projects/macpan2/sir\") (target directory doesn’t exist, model_starter() refuse overwrite ).","code":"model_name ├── variables.csv ├── derivations.json ├── settings.json └── flows.csv list.files(system.file(\"starter_models\", package = \"macpan2\")) #>  [1] \"age\"           \"flow_examples\" \"macpan_base\"   \"seir\"          #>  [5] \"seir_symp\"     \"seir_symp_vax\" \"seir_vax\"      \"SI_products\"   #>  [9] \"sir\"           \"sir_demo\"      \"sir_vax\"       \"sir_waning\"    #> [13] \"testing\"       \"vax\"           \"ww\" print(sir_dir <- system.file(\"starter_models\", \"sir\", package = \"macpan2\")) #> [1] \"/home/runner/work/_temp/Library/macpan2/starter_models/sir\""},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"variables","dir":"Articles","previous_headings":"Model Definition Files","what":"variables.csv","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"variables.csv includes list model variables: (first row file header row, classifies variables . later.) macpan2, use “variables” general term refer S: number susceptible individuals point time; : number infectious individuals; R: number removed individuals. beta: contact rate (transmission per time per susceptible per infective); gamma: per-capita recovery rate infectious individuals. N: population size, calculated summing state variables S + + R. foi: force infection, beta * / N model. Formulas derived quantities defined derivations.json. simple models like one, variables.csv single-column .csv file. header row contains one column name, Epi, labels variables epidemiological variables. variable category labels, variable partitions, aren’t useful simple models like basic SIR, single variable category. However, partitions essential part “product” models combine multiple model structures complex models (example, SEIR model infectious class divided level symptoms: see vignette('quickstart2', package = 'macpan2').","code":"#> Epi #> S #> I #> R #> N #> beta #> foi #> gamma"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"derivations","dir":"Articles","previous_headings":"Model Definition Files","what":"derivations.json","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"derivations.json includes expressions computing derived variables: example, derived variables total population size, N, force infection, foi. derived variable defined JSON object. JSON object contains several key-value pairs. keys : output_names: name(s) derived variable(s); simple model, JSON object defines single derived variable. , means variable calculated initial variable values, simulation begins; during_pre_update, means variable calculated simulation step, state variables updated next time step. arguments: array variables (delimited brackets []) used calculate derived variable. expression: string storing mathematical expression used calculate derived variable using arguments. keys described options; supplementary keys used defining complicated models. fully catalogued model definitions article. Mathematical operations functions available use expression string listed engine functions reference article. example , defined foi beta * / (S + + R). However, expression harder read, less computationally efficient. defined , N computed , simulation begins (\"simulation_phase\": \"\"), since population size fixed model. foi computed arguments simulation time step (\"simulation_phase\": \"during_pre_update\") order update numerator using latest prevalence. denominator (S + + R) also re-computed needlessly time step.","code":"#> [ #>   { #>     \"output_names\" : [\"N\"], #>     \"simulation_phase\" : \"before\", #>     \"arguments\" : [\"S\", \"I\", \"R\"], #>     \"expression\" : \"sum(S, I, R)\" #>   }, #>   { #>     \"output_names\" : [\"foi\"], #>     \"simulation_phase\" : \"during_pre_update\", #>     \"arguments\" : [\"I\", \"beta\", \"N\"], #>     \"expression\" : \"I * beta / N\" #>   } #> ]"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"settings-json","dir":"Articles","previous_headings":"Model Definition Files","what":"settings.json","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"settings.json gives information interpret variables defined variables.csv. file contains single JSON object, several key-value pairs. mandatory keys : required_partitions: array variable partition names (header row variables.csv) required uniquely identify variable. null_partition: Leave entry \"Null\"; key may used expand macpan2’s functionality future, currently unused. state_variables: array state variables. flow_variables: array flow variables.","code":"#> { #>   \"required_partitions\" : [\"Epi\"], #>   \"null_partition\" : \"Null\", #>   \"state_variables\" : [\"S\", \"I\", \"R\"], #>   \"flow_variables\" : [\"foi\", \"gamma\"] #> }"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"flows-csv","dir":"Articles","previous_headings":"Model Definition Files","what":"flows.csv","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"flows.csv defines flows state variable compartments: file also starts header row, including following columns: : name flow origin compartment. : name flow destination compartment. flow: variable name storing value flow rate. type: type flow. , flow type per_capita: .e., flow time step \\(t+1\\) equals flow times number individuals compartment time \\(t\\). example , flow S equals foi * S (referring back derivations file, equal beta * S * / N). available flow types given model definitions article.","code":"#> from ,to ,flow  ,type      ,from_partition ,to_partition ,flow_partition ,from_to_partition ,from_flow_partition ,to_flow_partition #> S    ,I  ,foi   ,per_capita,Epi,Epi,Epi,,,Null #> I    ,R  ,gamma ,per_capita,Epi,Epi,Epi,,,Null"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"side-note-macpan2-is-object-oriented","dir":"Articles","previous_headings":"","what":"Side-Note: macpan2 is Object-Oriented","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"demonstrate import use model R, note macpan2 object-oriented. really need know using macpan2, routinely create (“initialize”) special R objects specific functions (“methods”) attached perform useful actions. objects generally just named lists, list elements actually methods (functions). example, made-general names: next section make idea concrete.","code":"myObject <- functionToInitializeObject(argumentsToSetUpMyObject) names(myObject) > [1] \"objectInfo\" \"objectMethod\" myObject$objectMethod(argumentsForUsingObjectMethod)"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"getting-model-definitions-into-r","dir":"Articles","previous_headings":"","what":"Getting Model Definitions into R","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"Now directory completely defines compartmental model, can use create model structure object R using Compartmental() function. Compartmental() function initializes macpan2 models (also include Compartmental class): Visualizing Compartmental object function macpan2helpers package: can display components macpan2 models (Compartmental objects), including methods operate , listing names: documentation Compartmental objects (?Compartmental()) gives full description components, next section, focus sir$simulators.","code":"sir = Compartmental(sir_dir) class(sir) #> [1] \"Compartmental\" \"Model\"         \"Base\" vn = macpan2helpers::visCompartmental(sir, label_flows = TRUE) names(sir) #>  [1] \"def\"            \"indices\"        \"labels\"         \"flows_expanded\" #>  [5] \"variables\"      \"simulators\"     \"expr_list\"      \"flows\"          #>  [9] \"flows_explicit\" \"settings\"       \"derivations\""},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"inputting-values-to-create-model-simulators","dir":"Articles","previous_headings":"","what":"Inputting Values to Create Model Simulators","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"Model structure objects, like sir, general: don’t contain specific values variables, initial conditions state variables values flow rates. order simulate model, need create model simulator object combining model structure object numerical values variables. sir$simulators list element contains methods generating model simulators. article, use sir$simulators$tmb() method, currently simulation engine available. attach specific values model variables initializing model simulator, sir_simulator, using sir$simulators$tmb() function: (flow variables recalculated every time step, specified derivations.json, can set NA - placeholder values don’t affect simulation) simulator initializer function, sir$simulators$tmb(), uses sir model structure, additionally takes following arguments: time_steps: many time steps epidemic simulator run ? state: named vector containing initial values state variables defined settings.json. example, units states “number individuals”. flow: named vector containing values flow variables defined settings.json - , just foi gamma. ...: named variables required model definition, .e., variables used derivations.json included settings.json. , beta N used expressions derived variables explicitly flow variables. Always think explicitly units flow variables. example, perhaps know infected individuals recover ten days average. set per-capita recovery rate, gamma, equal 1/10 = 0.1, thus implicitly specifying time step one day. set gamma = 1/240 instead, time step represent one hour. must define flow variables using consistent time units! example, use empty_matrix placeholder value initialize value population size N. N computed simulation starts using given initial conditions, specified derivations.json \"simulation_phase\": \"\". order create model simulator object, must give value every variable model definition. macpan2 check ahead time whether N pre-computed. Thus, initialize N placeholder value macpan2::empty_matrix, simply empty matrix. (Although N scalar value, macpan2 represents variables matrices, including scalars, case treated 1 x 1 matrices.) specified hard-coded value N ? instance: actually problem specification; macpan2 compute N using expression S + + R derivations.json initial conditions state argument simulation overwrite user-input value 100. Thus, one change initial condition state = c(S = 999, = 1, R = 0) without updating population N = 1000, simulator still use correct population size. However, code readable explicitly use N = empty_matrix, reminds N computed simulator.","code":"sir_simulator = sir$simulators$tmb(   time_steps = 100,   state = c(S = 99, I = 1, R = 0),   flow = c(foi = NA, gamma = 0.1),   beta = 0.2,   N = empty_matrix # explained below ) sir_simulator2 = sir$simulators$tmb(   time_steps = 100,   state = c(S = 99, I = 1, R = 0),   flow = c(foi = NA, gamma = 0.1),   beta = 0.2,   N = 100 )"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"simulation","dir":"Articles","previous_headings":"","what":"Simulation","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"Now simulation engine object, sir_simulator, use generate simulation results using one methods: report(). results come long (“narrow”) format, exactly one value per row: simulation results output data frame following columns: matrix: matrix value come ? default, simulation results include values state variables (coming state matrix). behaviour can changed .mats_to_return argument $simulators$tmb() (see ?Simulators()) time: time index, initial conditions returned time 0. row: name variable, corresponding row names state matrix. col: placeholder variable name components complicated models (covered article). value: simulated value particular state time step.","code":"sir_results = sir_simulator$report() head(sir_results, 9) #>   matrix time row col     value #> 1  state    0   S     99.000000 #> 2  state    0   I      1.000000 #> 3  state    0   R      0.000000 #> 4  state    1   S     98.802000 #> 5  state    1   I      1.098000 #> 6  state    1   R      0.100000 #> 7  state    2   S     98.585031 #> 8  state    2   I      1.205169 #> 9  state    2   R      0.209800"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"processing-results","dir":"Articles","previous_headings":"","what":"Processing Results","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"macpan2 provide data manipulation plotting tools (although macpan2helpers). philosophy focus engine modelling interface, provide outputs formats easy use data processing packages, like ggplot2, dplyr, tidyr, readily make use data long format. example, can generate ggplot :  mutate step optional, included enforce logical ordering state variables legend plot – otherwise alphabetically-ordered IRS model instead flow-ordered SIR. want use base R plots, can convert long format data wide format: (, used base R pipe operator, |>.)  ","code":"(sir_results   |> mutate(state = factor(row, levels = sir$labels$state()))   |> ggplot()   + geom_line(aes(time, value, colour = state))   + theme_bw() ) sir_results_wide <- (sir_results     ## drop 'matrix' (has only a single value) and 'col' (empty)     |> dplyr::select(-c(matrix, col))     |> tidyr::pivot_wider(id_cols = time, names_from = row) )  head(sir_results_wide, n = 3) #> # A tibble: 3 × 4 #>    time     S     I     R #>   <int> <dbl> <dbl> <dbl> #> 1     0  99    1    0     #> 2     1  98.8  1.10 0.1   #> 3     2  98.6  1.21 0.210 with(sir_results_wide,      plot(x = time,           y = I) ) par(las = 1) ## horizontal y-axis ticks matplot(sir_results_wide[, 1],         sir_results_wide[,-1],         type = \"l\",         log = \"y\",         xlab = \"time\", ylab = \"\") #> Warning in xy.coords(x, y, xlabel, ylabel, log = log, recycle = TRUE): 1 y #> value <= 0 omitted from logarithmic plot legend(\"bottom\", col = 1:3, lty = 1:3, legend = sir$labels$state())"},{"path":"https://canmod.github.io/macpan2/articles/quickstart.html","id":"incidence","dir":"Articles","previous_headings":"","what":"Incidence","title":"Quickstart Guide: specifying and simulating a simple compartmental model","text":"simulations give prevalence disease incidence, total number new individuals entering -box time step. Incidence commonly reported prevalence, important able get incidence numbers. total number new individuals entering boxes stored total_inflow vector automatically constructed Compartmental function. vector long state element inflow corresponding box (analogous total_outflow vector well). return vector, one must declare matrix return following code (default state matrix returned). plotting code used can modified plot inflow rather state.  figure incidence inflow box. S line flat model flow S. Note approach calculating incidence works time period incidence measured corresponds length one time step. assumption met – example time step one day incidence data reported every week – approaches computing simulated incidence must taken. simplest approach use accumulator variables, covered (TODO: write vignette accumulator variables).","code":"sir_simulator3 = sir$simulators$tmb(   time_steps = 100,   state = c(S = 99, I = 1, R = 0),   flow = c(foi = NA, gamma = 0.1),   beta = 0.2,   N = empty_matrix,      ## telling the simulator to return the inflows into each box   ## including `I`, which corresponds to incidence   ## (note: in the near future the .dimnames part will be automatic)   .mats_to_return = c(\"state\", \"total_inflow\"),   .dimnames = list(total_inflow = list(sir$labels$state(), \"\")) ) (sir_simulator3$report()   |> filter(matrix == \"total_inflow\")   |> mutate(state = factor(row, levels = sir$labels$state()))   |> ggplot()   + geom_line(aes(time, value, colour = state))   + ggtitle(\"Total Inflow into Each State\")   + theme_bw() )"},{"path":"https://canmod.github.io/macpan2/articles/quickstart2.html","id":"sir-vaccination-model","dir":"Articles","previous_headings":"","what":"SIR Vaccination model","title":"Quickstart Guide, part 2: specifying and simulating a structured compartmental model","text":"good place start product models sir_vax starter model stratifies standard SIR model include vaccination status. case simple SIR model population divided compartments susceptible, infected, recovered individuals. However population also divided compartments vaccinated unvaccinated individuals. simple SIR model three compartments SIR_vax model six. reflected variables.csv file model directory now two columns. row file specifies name column; first column called Epi second column called Vax. predictably Epi column lists compartment parameter names relevant epidemiological status Vax column similarly relates vaccination status. parameters (e.g. gamma) SIR model single value now two values reflect differences behavior vaccinated unvaxxinated people. parameters (e.g. vax_rate) single value (case susceptible people vaccinated). Epi parameters vary based vax status parameter name repeated Epi column differing status labels Vax column. referring specific compartments parameters concatenate labels column ., compartment unvaccinated susceptible population called S.unvax. variable label given column entry left blank concatonation dot still included (vax_rate properly referred .vax_rate). Flows product models specified flows.csv file model definition directory. Notice three right columns, unused single stratum models now important role. particular ensure compartments one stratum flow compartments stratum. Without S.vax compartment flows .vax .unvax. three columns from_to_partition, from_flow_partition to_flow_partition, general two columns entries third blank null_partition label specified settings.json. from_to_partition column indicates partitions used math compartments. example flow S indicates Vax partition used S.vax flows .vax S.unvax .unvax. from_flow_partition column indicates partition used match compartments flow variables. example flow R Vax from_flow_partition flow .unvax R.unvax matched gamma.unvax variable. principle to_flow_partition column can used match flow parameters flow via compartment rather compartment however example used two columns to_flow_column Null entry. Notice flow S.unvax S.vax different flows corresponding flows .unvax .vax R.unvax R.vax. case from_partition to_partition Epi.Vax compartments specified using partitions, flow_partition specified Vax rate vaccination governed .dose_rate variable entry Epi partition. need use final three columns since compartments involved flow given explicitly rather group case flows. derivations.json file model definition directory largely single stratum models. key distinction now derivation can correspond multiple different equations, reflected existence multiple entries group_names well output_names fields. take first derivation file example can see expression evaluated sum(S, , R). group_names field entries unvax vax (group_partition field defines partition group_names related ). output_names field also two entries N.unvax N.vax names variables derivation compute values . Taken together see single derivation produces two distinct equations, N.unvax = sum(.unvax, S.unvax, R.unvax) N.vax = sum(S.vax, .vax, R.vax). notable difference settings.json files single stratum multi-strata models multi-strata models multiple required_partitions. ’s also worth noting null_partition entry defines entered whichever from_to_partition, from_flow_partition to_from_partition isn’t used flows.csv file.","code":"print(sir_vax_dir <- system.file(\"starter_models\", \"sir_vax\", package = \"macpan2\")) #> [1] \"/home/runner/work/_temp/Library/macpan2/starter_models/sir_vax\" #> Epi       ,Vax #> S         ,unvax #> I         ,unvax #> R         ,unvax #> N         ,unvax #> sigma     ,unvax #> beta      ,unvax #> foi       ,unvax #> infection ,unvax #> gamma     ,unvax #> S         ,vax #> I         ,vax #> R         ,vax #> N         ,vax #> sigma     ,vax #> beta      ,vax #> foi       ,vax #> infection ,vax #> gamma     ,vax #> foi       , #>           ,vax_rate #> from    ,to    ,flow      ,type       ,from_partition ,to_partition ,flow_partition ,from_to_partition ,from_flow_partition ,to_flow_partition #> S       ,I     ,infection ,per_capita ,Epi            ,Epi          ,Epi            ,Vax               ,Vax                 ,Null #> I       ,R     ,gamma     ,per_capita ,Epi            ,Epi          ,Epi            ,Vax               ,Vax                 ,Null #> S.unvax ,S.vax ,vax_rate  ,per_capita ,Epi.Vax        ,Epi.Vax      ,Vax            ,                  ,                    ,Null #> [ #>   { #>     \"group_partition\" : \"Vax\", #>     \"group_names\" : [\"unvax\", \"vax\"], #>     \"output_partition\" : \"Epi.Vax\", #>     \"output_names\" : [\"N.unvax\", \"N.vax\"], #>     \"simulation_phase\" : \"during_pre_update\", #>     \"input_partition\" : \"Epi\", #>     \"arguments\" : [\"S\", \"I\", \"R\"], #>     \"expression\" : \"sum(S, I, R)\" #>   }, #>   { #>     \"group_partition\" : \"Vax\", #>     \"group_names\" : [\"unvax\", \"vax\"], #>     \"output_partition\" : \"Epi.Vax\",  #>     \"output_names\" : [\"foi.unvax\", \"foi.vax\"], #>     \"simulation_phase\" : \"during_pre_update\", #>     \"input_partition\" : \"Epi\", #>     \"arguments\" : [\"I\", \"beta\", \"N\"], #>     \"expression\" : \"I * beta / clamp(N)\"  #>   }, #>   { #>     \"filter_partition\" : \"Epi\", #>     \"filter_names\" : [\"foi\"], #>     \"output_partition\" : \"Epi.Vax\", #>     \"output_names\" : [\"foi.\"], #>     \"simulation_phase\" : \"during_pre_update\", #>     \"input_partition\" : \"Vax\", #>     \"arguments\" : [\"unvax\", \"vax\"], #>     \"expression\" : \"unvax + vax\" #>   }, #>   { #>     \"filter_partition\" : \"Epi.Vax\", #>     \"filter_names\" : [\"foi.\", \"sigma.unvax\", \"sigma.vax\", \"infection.unvax\", \"infection.vax\"], #>     \"group_partition\" : \"Vax\", #>     \"group_names\" : [\"unvax\", \"vax\"], #>     \"output_partition\" : \"Epi.Vax\", #>     \"output_names\" : [\"infection.unvax\", \"infection.vax\"], #>     \"simulation_phase\" : \"during_pre_update\", #>     \"input_partition\" : \"Epi\", #>     \"arguments\" : [\"foi\", \"sigma\"], #>     \"expression\" : \"foi * sigma\" #>   } #> ] #> { #>   \"required_partitions\" : [\"Epi\", \"Vax\"], #>   \"null_partition\" : \"Null\", #>   \"state_variables\" : [\"S.unvax\", \"I.unvax\", \"R.unvax\", \"S.vax\", \"I.vax\", \"R.vax\"], #>   \"flow_variables\" : [\"infection.unvax\", \"infection.vax\", \"gamma.unvax\", \"gamma.vax\", \".vax_rate\"] #> } sir_vax = Compartmental(sir_vax_dir) ## TODO: add this 'facet grid' functionality to macpan2helpers::visCompartmental draw_vis(sir_vax, x_mult = 200, y_mult = 100) sir_vax_sim = sir_vax$simulators$tmb(time_steps = 100L   , state = c(S.unvax = 99, I.unvax = 1, R.unvax = 0, S.vax = 0, I.vax = 0, R.vax = 0)   , flow = c(         infection.unvax = 0, infection.vax = 0       , gamma.unvax = 0.1, gamma.vax = 0.1       , .vax_rate = 0.1     )   , sigma.unvax = 1   , sigma.vax = 0.01   , beta.unvax = 0.2   , beta.vax = 0.2   , foi.unvax = empty_matrix   , foi.vax = empty_matrix   , foi. = empty_matrix   , N.unvax = empty_matrix   , N.vax = empty_matrix ) (sir_vax_sim$report()   %>% separate_wider_delim(\"row\", \".\", names = c(\"Epi\", \"Vax\"))  %>% mutate(Epi = factor(Epi, levels = c(\"S\", \"I\", \"R\")))  %>% ggplot()  + facet_grid(Epi~Vax, scales = \"free\")  + geom_line(aes(time, value)) )"},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"decomposition-of-state-dependent-rates","dir":"Articles","previous_headings":"","what":"Decomposition of State-Dependent Rates","title":"State-Dependent Rates","text":"vast majority compartmental models contain flows depend states compartments directly involved flows. example, magnitude flow compartment compartment B depend another compartment, C. important example dependencies infection, use terminology infection processes. However, model subsume large number flows special cases. Let \\(s\\) \\(x\\) subsets state vector. length-\\(n\\) vector \\(s\\) contains -compartments – typically compartments susceptible infection – set flows. length-\\(m\\) vector \\(x\\) contains compartments – typically infectious compartments – affect flows. components \\(x\\) need affect components \\(y\\) need affect . Note keep track -compartments flows matter (think). define \\(n\\)--\\(m\\) transmission matrix following decomposition. \\[ \\DeclareMathOperator{\\diag}{diag} T = \\diag(p) B \\diag(c) \\] decomposition involves following terms. \\(p\\) – length-\\(n\\) vector susceptibilities \\(s\\) state \\(B\\) – \\(n\\)--\\(m\\) matrix contacts \\(x\\) \\(s\\) state \\(c\\) – length-\\(m\\) vector infectivities \\(x\\) state alternative way write transmission matrix decomposition – prefer accurate representation actual computations – using element-wise operations. \\(\\circ\\) element-wise product following. \\[ T = p \\circ B \\circ c^\\top \\] expression column vector \\(p\\) element-wise multiplied column \\(B\\), row product element-wise multiplied row vector \\(c^\\top\\), \\(\\top\\) matrix transpose operator. vector containing per-capita flow rates \\(s\\) states following. \\[ \\lambda = Tx \\] \\(\\lambda\\) vector often called force infection. finally absolute flow rates \\(s\\) states following. \\[ \\DeclareMathOperator{\\diag}{diag} r = \\lambda \\circ s \\]","code":""},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"example-sir","dir":"Articles","previous_headings":"","what":"Example – SIR","title":"State-Dependent Rates","text":"\\(s\\) vector contains single state, S, \\(x\\) contains . case \\(n\\) \\(m\\) 1, components 1--1 follows. \\(p = 1\\) – susceptibility \\(B = 1\\) – contact matrix \\(c = \\frac{\\sigma}{N}\\) – infectivity Therefore following transmission matrix, per-capita flow rate vector, absolute flow rate vector. \\(T = \\frac{\\sigma}{N}\\) \\(\\lambda = \\frac{\\sigma}{N} \\) \\(r = \\frac{\\sigma}{N} \\) overly simple hopefully clarifying example decided put \\(\\sigma\\) \\(\\frac{1}{N}\\) components, \\(p\\), \\(B\\), \\(c\\). point somewhat mechanistic somewhat general decomposition transmission, start working complex models combining model modules (e.g. combining SEIR age spatial structure) way conveniently combine modules resulting transmission rates make mechanistic sense.","code":""},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"product-models","dir":"Articles","previous_headings":"","what":"Product Models","title":"State-Dependent Rates","text":"Now consider two models, following triples representing transmission decomposition. \\[ (p_1, B_1, c_1) \\] \\[ (p_2, B_2, c_2) \\] Note subscripts represent model, components vectors matrices. dimensions two models \\(n_1, m_1\\) \\(n_2, m_2\\). Taking product two models results following triple. \\[ (p, B, c) = (p_1\\otimes p_2, B_1\\otimes B_2, c_1\\otimes c_2) \\] \\(\\otimes\\) Kronecker product. leads \\(n_1n_2\\)--1 column vector, \\(p\\), \\(n_1n_2\\)--\\(m_1m_2\\) matrix, \\(B\\), \\(m_1m_2\\)--1 column vector \\(c\\). also \\(x_1, x_2\\) \\(s_1, s_2\\) combine \\(x\\) \\(s\\). need make distinction factor models transmission without. example, SIR model clearly transmission, factor model just age groups . pure age model distinguish infectious susceptible people, process considers aging. Nevertheless age model becomes combined model transmission, want ready combined. make age model – factor model without transmission – ready combined model includes transmission need two things. First need account fact states may appear \\(x\\) \\(s\\) (e.g. young people can infectious susceptible). Second need include parameters used factor model’s processes used combined model includes transmission (e.g. age model needs contact matrix even though contact processes affect aging, process age model). next example illustrates ideas.","code":""},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"example-sir-times-age","dir":"Articles","previous_headings":"","what":"Example – SIR times age","title":"State-Dependent Rates","text":"take product SIR model two-age-group factor model. components transmission decomposition particular age-group factor model follows. susceptibility: \\(p = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\) contact matrix: \\(B = \\begin{bmatrix} q & (1 - q) \\\\ (1 - q) & q \\end{bmatrix}\\) infectivity: \\(c = \\begin{bmatrix} \\sigma_\\text{young} \\\\ \\sigma_\\text{young} \\end{bmatrix}\\) \\(q\\) probability given contact individuals age. symmetric contact matrix, didn’t need . also decided susceptibility depend age, absolutely parameterizing vector. little odd refer decomposition transmission, age-model contains aging processes include transmission. However, including transmission decomposition necessary prepare model combination model transmission. Taking product age model SIR model following transmission decomposition. susceptibility: \\(p = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\) contact matrix: \\(B = \\begin{bmatrix} q & (1 - q) \\\\ (1 - q) & q \\end{bmatrix}\\) infectivity: \\(c = \\frac{\\sigma}{N}\\begin{bmatrix} \\sigma_\\text{young} \\\\ \\sigma_\\text{old} \\end{bmatrix}\\) product model \\(x\\) contains .young .old \\(s\\) contains S.young S.old. transmission matrix can obtained multiplying three components decomposition follows. \\[ T = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\circ \\begin{bmatrix} q & (1 - q) \\\\ (1 - q) & q \\end{bmatrix} \\circ \\frac{\\sigma}{N}\\begin{bmatrix} \\sigma_\\text{young} & \\sigma_\\text{old} \\end{bmatrix} = \\frac{\\sigma}{N} \\begin{bmatrix} q \\sigma_\\text{young} & (1 - q) \\sigma_\\text{old} \\\\ (1 - q) \\sigma_\\text{young} & q \\sigma_\\text{old} \\end{bmatrix} \\] force infection vector product \\(T\\) \\(x = \\begin{bmatrix}I_{\\text{young}} \\\\ I_{\\text{old}}\\end{bmatrix}\\) \\[ \\lambda = \\frac{\\sigma}{N} \\begin{bmatrix} q \\sigma_\\text{young} I_{\\text{young}} + (1-q) \\sigma_\\text{old} I_{\\text{old}} \\\\ (1-q) \\sigma_\\text{young} I_{\\text{young}} + q \\sigma_\\text{old} I_{\\text{old}} \\end{bmatrix} \\]","code":""},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"example-sir-with-multiple-i-boxes-times-age","dir":"Articles","previous_headings":"","what":"Example – SIR with multiple I-boxes times age","title":"State-Dependent Rates","text":"example SIR model \\(n = 1\\) susceptible class \\(m = 2\\) infectious classes – mild severe – following transmission decomposition. susceptibility: \\(p = 1\\) contact matrix: \\(B = \\begin{bmatrix} 1 & 1 \\end{bmatrix}\\) infectivity: \\(c = \\frac{1}{N}\\begin{bmatrix} \\sigma_\\text{mild} \\\\ \\sigma_\\text{severe} \\end{bmatrix}\\) Multiplying decomposition age model (order) gives following model \\(n = 2\\) susceptible compartments \\(m = 4\\) infectious compartments. susceptibility: \\(p = \\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix}\\) contact matrix: \\(B = \\begin{bmatrix} q & (1 - q) & q & (1 - q) \\\\ (1 - q) & q & (1 - q) & q \\end{bmatrix}\\) infectivity: \\(c = \\frac{1}{N}\\begin{bmatrix} \\sigma_\\text{mild} \\sigma_\\text{young} \\\\ \\sigma_\\text{mild} \\sigma_\\text{old}\\\\ \\sigma_\\text{severe} \\sigma_\\text{young}\\\\ \\sigma_\\text{severe}\\sigma_\\text{old} \\end{bmatrix}\\) non-square contact matrix might seem weird, fine modelling contacts two susceptible classes four infectious classes. One write \\(2\\)--\\(4\\) transmission matrix, don’t think informative. informative write component force infection vector, say young people. \\[ \\begin{array}{rrrrrrr} \\lambda_{\\text{young}} = \\frac{1}{N} & ( & & q      \\sigma_\\text{mild}    \\sigma_\\text{young}  I_{\\text{mild},\\text{young}} \\\\ & & + & (1-q)  \\sigma_\\text{mild}    \\sigma_\\text{old}    I_{\\text{mild},\\text{old}} \\\\ & & + & q      \\sigma_\\text{severe}  \\sigma_\\text{young}  I_{\\text{severe},\\text{young}} \\\\ & & + & (1-q)  \\sigma_\\text{severe}  \\sigma_\\text{old}    I_{\\text{severe},\\text{old}} & ) \\\\ \\end{array} \\] first term, example, gives contribution force infection due contacts young susceptible individuals mildly infected young individuals.","code":""},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"example-sir-with-multiple-i-boxes-and-partial-immunity-times-age","dir":"Articles","previous_headings":"","what":"Example – SIR with multiple I-boxes and partial immunity times age","title":"State-Dependent Rates","text":"starting approach ‘real’ models now. SIR model R box can now flow back , immunity gained infection recovery imperfect. model feature means \\(s\\) vector two states, S R, \\(n = 2\\). \\(x\\) vector contains I_mild I_severe, \\(m = 2\\) well. transmission decomposition looks like . susceptibility: \\(p = \\begin{bmatrix} 1 \\\\ 1 - \\pi \\end{bmatrix}\\) contact matrix: \\(B = \\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}\\) infectivity: \\(c = \\frac{1}{N}\\begin{bmatrix} \\sigma_\\text{mild} \\\\ \\sigma_\\text{severe} \\end{bmatrix}\\) \\(\\pi\\) efficacy immunity reinfection. product model age looks like . susceptibility: \\(p = \\begin{bmatrix} 1 \\\\ 1 \\\\ 1- \\pi \\\\ 1-\\pi \\end{bmatrix}\\) contact matrix: \\(B = \\begin{bmatrix} q & (1 - q) & q & (1 - q) \\\\ (1 - q) & q & (1 - q) & q \\\\ q & (1 - q) & q & (1 - q) \\\\ (1 - q) & q & (1 - q) & q \\end{bmatrix}\\) infectivity: \\(c = \\frac{1}{N}\\begin{bmatrix} \\sigma_\\text{mild} \\sigma_\\text{young} \\\\ \\sigma_\\text{mild} \\sigma_\\text{old}\\\\ \\sigma_\\text{severe} \\sigma_\\text{young}\\\\ \\sigma_\\text{severe}\\sigma_\\text{old} \\end{bmatrix}\\) force infection young individuals R box, example, given following expression \\[ \\begin{array}{rrrrrr} \\lambda_{\\text{R,young}} = \\frac{1-\\pi}{N} & ( & & q      \\sigma_\\text{mild}    \\sigma_\\text{young}  I_{\\text{mild},\\text{young}} \\\\ & & + & (1-q)  \\sigma_\\text{mild}    \\sigma_\\text{old}    I_{\\text{mild},\\text{old}} \\\\ & & + & q      \\sigma_\\text{severe}  \\sigma_\\text{young}  I_{\\text{severe},\\text{young}} \\\\ & & + & (1-q)  \\sigma_\\text{severe}  \\sigma_\\text{old}    I_{\\text{severe},\\text{old}} & ) \\\\ \\end{array} \\] Note almost identical expression \\(\\lambda_\\text{young}\\) , factor, \\(1-\\pi\\), giving reduction transmission conferred immunity. \\[ \\lambda_{\\text{R,young}} = (1-\\pi) \\lambda_{\\text{young}} \\]","code":""},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"State-Dependent Rates","text":"Assume SI model times young-old model. Variables.csv","code":"Epi,        Age S,          young I,          young S,          old I,          old susceptibility,   contact"},{"path":"https://canmod.github.io/macpan2/articles/state_dependent_rates.html","id":"bookkeeping-in-progress","dir":"Articles","previous_headings":"","what":"Bookkeeping (in progress)","title":"State-Dependent Rates","text":"Index element \\(s\\) \\(\\) element \\(x\\) \\(j\\). can define per-capita rate individuals flow \\(s_i\\) compartment following decomposition. \\[ r_i = p_i \\lambda_i \\] components decomposition follows. \\(p_i\\): susceptibility (e.g. complement vaccine efficacy) \\(\\lambda_i\\): force infection definition, absolute rate flow \\(s_i\\) given \\(r_i s_i\\). force infection . \\[ \\lambda_i = \\sum_j B_{ij}c_jx_j \\]","code":""},{"path":"https://canmod.github.io/macpan2/articles/time_varying_parameters.html","id":"baseline-sir-model","dir":"Articles","previous_headings":"","what":"Baseline SIR Model","title":"Specifying Time-Varying Parameters","text":"modify SIR model transmission rate time-varying.","code":"sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) simulator = sir$simulators$tmb(time_steps = 50   , state = c(S = 99, I = 1, R = 0)   , flow = c(foi = NA, gamma = 0.2)   , N = empty_matrix   , beta = 0.8 ) (simulator$report(.phases = \"during\")   %>% rename(state = row)   %>% mutate(state = factor(state, sir$labels$state()))   %>% ggplot() + geom_line(aes(time, value, colour = state)) )"},{"path":"https://canmod.github.io/macpan2/articles/time_varying_parameters.html","id":"piecewise-time-variation","dir":"Articles","previous_headings":"","what":"Piecewise Time Variation","title":"Specifying Time-Varying Parameters","text":"now change value transmission rate, beta, beginning time-step 10 15. first step add simulator vector containing change-points. Next add values beta changes time-steps. also need variable track current value beta. beta_pointer starts time-step equal 0, incremented throughout simulation. increment beta_pointer using time_group function returns either beta_pointer beta_pointer + 1 depending whether current time-step change-point beta_changepoints. update beta every iteration simulation loop using beta_pointer. ’s . Now plot updated simulations using change-points, highlight vertical lines.","code":"simulator$add$matrices(beta_changepoints = c(0, 10, 15)) simulator$add$matrices(beta_values = c(0.8, 0.01, 0.4)) simulator$add$matrices(beta_pointer = 0) simulator$insert$expressions(     beta_pointer ~ time_group(beta_pointer, beta_changepoints),      .phase = \"during\" ) simulator$insert$expressions(   beta ~ beta_values[beta_pointer],   .phase = \"during\" ) s = simulator$report(.phases = \"during\") (s   %>% rename(state = row)   %>% mutate(state = factor(state, sir$labels$state()))   %>% ggplot()   + geom_line(aes(time, value, colour = state))   + geom_vline(     aes(xintercept = x),      linetype = \"dashed\",      alpha = 0.5,      data = data.frame(x = simulator$get$initial(\"beta_changepoints\"))   ) )"},{"path":"https://canmod.github.io/macpan2/articles/time_varying_parameters.html","id":"calibrating-time-variation-parameters","dir":"Articles","previous_headings":"","what":"Calibrating Time Variation Parameters","title":"Specifying Time-Varying Parameters","text":"First simulate data fit model , see can recover time-varying parameters.  add matrices model keeping tracking information used model fitting. Now need new expressions. first expression pulls state state vector. second expression computes vector Poisson log-likelihood values – one time step. Next declare beta values parameters optimized log scale. Finally fit model back simulation data. can see optimizer converges (.e. $convergence = 0) 26 iterations. log scale see optimizer finds different values (current) started (default). importantly beta values untransformed scale recover values used simulations, although second fitted beta value much smaller true value.","code":"set.seed(1L) I_observed = rpois(   50,    filter(s, matrix == \"state\", row == \"I\")$value ) plot(I_observed) simulator$add$matrices(      ## observed data   I_obs = I_observed,      ## simulated trajectory to compare with data   I_sim = empty_matrix,       ## location of I in the state vector   ## (the `-1L` bit is to get 0-based indices instead of 1-based)   I_index = match(\"I\", sir$labels$state()) - 1L,       ## matrix to contain the log likelihood values at    ## each time step   log_lik = empty_matrix,       ## need to save the simulation history of each of these matrices   .mats_to_save = c(\"I_sim\", \"log_lik\") ) simulator$insert$expressions(   I_sim ~ state[I_index],   .phase = \"during\" ) simulator$insert$expressions(   log_lik ~ dpois(I_obs, clamp(rbind_time(I_sim))),   .phase = \"after\" ) simulator$replace$obj_fn(~ -sum(log_lik)) simulator$add$transformations(Log(\"beta_values\")) simulator$replace$params(   default = log(mean(simulator$get$initial(\"beta_values\"))),   mat = rep(\"log_beta_values\", 3L),   row = 0:2 ) simulator$optimize$nlminb() #> Constructing atomic D_lgamma #> outer mgc:  736.1414  #> Constructing atomic D_lgamma #> outer mgc:  112.6655  #> outer mgc:  71.38648  #> outer mgc:  13.6616  #> outer mgc:  12.58091  #> outer mgc:  3.638083  #> outer mgc:  1.399513  #> outer mgc:  1.609453  #> outer mgc:  1.140347  #> outer mgc:  0.5870909  #> outer mgc:  0.2527136  #> outer mgc:  0.09938628  #> outer mgc:  0.03753935  #> outer mgc:  0.01394885  #> outer mgc:  0.005150654  #> outer mgc:  0.001897432  #> outer mgc:  0.0006983805  #> outer mgc:  0.0002569678  #> outer mgc:  9.453969e-05  #> outer mgc:  3.478009e-05  #> outer mgc:  1.2795e-05  #> outer mgc:  4.707033e-06  #> outer mgc:  1.731623e-06  #> outer mgc:  6.370286e-07  #> outer mgc:  2.3435e-07  #> outer mgc:  8.621247e-08  #> outer mgc:  3.171579e-08 #> $par #>      params      params      params  #>  -0.1710158 -22.8268369  -0.8291142  #>  #> $objective #> [1] 99.74231 #>  #> $convergence #> [1] 0 #>  #> $iterations #> [1] 26 #>  #> $evaluations #> function gradient  #>       28       27  #>  #> $message #> [1] \"relative convergence (4)\" simulator$current$params_frame() #>   par_id             mat row col    default     current #> 1      0 log_beta_values   0   0 -0.9079919  -0.1710158 #> 2      1 log_beta_values   1   0 -0.9079919 -22.8268369 #> 3      2 log_beta_values   2   0 -0.9079919  -0.8291142 data.frame(   fitted = formatC(     exp(simulator$current$params_frame()$current),     format = \"e\", digits = 2   ),   true = simulator$get$initial(\"beta_values\") ) #>     fitted true #> 1 8.43e-01 0.80 #> 2 1.22e-10 0.01 #> 3 4.36e-01 0.40"},{"path":[]},{"path":[]},{"path":"https://canmod.github.io/macpan2/articles/time_varying_parameters.html","id":"radial-basis-functions-for-flexible-time-variation-in-progress","dir":"Articles","previous_headings":"","what":"Radial Basis Functions for Flexible Time Variation (In-Progress)","title":"Specifying Time-Varying Parameters","text":"section uses radial basis functions (RBFs) generate models flexible functional form smooth changes transmission rate. can add fancy radial basis transmission rate, need base model. use SIR model modified include waning. macpan2::rbf function can used produce matrix giving values basis function (column) time step (row). Using matrix, \\(X\\), weights vector, \\(b\\), can get flexible output vector, \\(y\\), shape can modified wide variety shapes changing weights vector. \\[ y = Xb \\] following code illustrates approach.  d dimension basis, number functions, n number time steps. multiplying uniform basis matrix (top panel) set weights (middle panel), obtain non-uniform curve (bottom panel). Note peaks (troughs) output associated large positive (negative) weights. Now want transform output (matrix) product RBF matrix weights vector time-series transmission rate, \\(\\beta\\). Although just use output vector \\(\\beta\\) time series, convenient transform \\(\\beta\\) values yield interesting dynamics SIR model. particular, model \\(\\beta_t\\) function time, \\(t\\), \\[ \\log(\\beta_t) = \\log(\\gamma_t) + \\log(N) - \\log(S_t) + x_tb \\] recovery rate, \\(\\gamma_t\\), number susceptibles, \\(S_t\\), time, \\(t\\), total population, \\(N\\), \\(t\\)th row \\(X\\), \\(x_t\\). better understand rationale equation note every element \\(b\\) set zero, following condition. \\[ \\frac{\\beta_t S_t}{N} = \\gamma_t \\] condition assures number infected individuals remains constant time, \\(t\\). means positive values \\(b\\) tend generate outbreaks negative values tend reduce transmission. local nature RBFs, don’t need set coefficients \\(b\\) zero achieve results practice – need work coefficients basis functions appreciably greater zero \\(t\\). fixme: clarify last sentence? fixme: (BMB) understand ’re setting model way, ’s odd/non-standard setup - may confuse people already familiar epidemic models (confused initially). simulation model radial basis exogenous transmission rate dynamics. fixme: explain first/unnamed argument $report() ? setting random value ? (understand , ’s parameter vector; rnorm() default setting parameter. Commenting term doesn’t seem change anything just set random-number seed? (default value something different evaluated different seed …)","code":"sir = Compartmental(system.file(\"starter_models\", \"sir_waning\", package = \"macpan2\")) sir$flows() #>   from to  flow       type #> 1    S  I   foi per_capita #> 2    I  R gamma per_capita #> 3    R  S  wane per_capita set.seed(1L) d = 20 n = 2500 X = rbf(n, d) b = rnorm(d, sd = 0.01) par(mfrow = c(3, 1), mar = c(0.5, 4, 1, 1) + 0.1) matplot(X, type = \"l\", lty = 1, col = 1, ylab = \"basis functions\", axes = FALSE) axis(side = 2) box() barplot(b, xlab = \"\", ylab = \"weights\") par(mar = c(5, 4, 1, 1) + 0.1) plot(X %*% b, type = \"l\", xlab = \"time\", ylab = \"output\") set.seed(1L) simulator = sir$simulators$tmb(       time_steps = n     , state = c(S = 100000 - 500, I = 500, R = 0)     , flow = c(foi = NA, gamma = 0.2, wane = 0.01)     , beta = 1     , N = 100000     , X = rbf(n, d)     , b = rnorm(d, sd = 0.01)     , incidence = empty_matrix     , eta = empty_matrix     , .mats_to_save = c(\"state\", \"incidence\", \"beta\")     , .mats_to_return = c(\"state\", \"incidence\", \"beta\") )$insert$expressions(     eta ~ gamma * exp(X %*% b)   , .phase = \"before\"   , .at = Inf )$insert$expressions(     beta ~ eta[time_step(1)] / clamp(S/N, 1/100)   , .phase = \"during\"   , .at = 1 )$insert$expressions(     incidence ~ I   , .vec_by_states = \"total_inflow\"   , .phase = \"during\"   , .at = Inf )$replace$params(     default = rnorm(d, sd = 0.01)   , mat = rep(\"b\", d)   , row = seq_len(d) - 1L ) set.seed(5L) (simulator$report(## rnorm(d, sd = 0.01),                   .phases = \"during\"  ## report only 'during' time steps                   )   %>% mutate(variable = if_else(matrix == \"state\", row, matrix))   %>% ggplot()   + facet_wrap(~ variable, ncol = 1, scales = 'free')   + geom_line(aes(time, value)) )"},{"path":"https://canmod.github.io/macpan2/articles/time_varying_parameters.html","id":"calibration","dir":"Articles","previous_headings":"Radial Basis Functions for Flexible Time Variation (In-Progress)","what":"Calibration","title":"Specifying Time-Varying Parameters","text":"Now ’re going try calibrate model data. main innovation use built-feature TMB (macpan2 constructed), estimation latent variables Laplace approximation fit time series efficiently without overfitting (see section 5.10 Madsen Thyregod (2011), Kristensen et al. (2016), TMB documentation detail). next steps follow first example Calibration vignette: 1. Simulate model add noise:  2. Add calibration information. start adding standard boilerplate stuff include observed data store/return results. Now start deviate previous example: addition parameter (I_sd) standard deviation noise \\(\\), also add parameter (rbf_sd) variance RBF coefficients, penalize likelihood using \\[ \\begin{split} I_{\\textrm{obs}} & \\sim \\textrm{Normal}(I_\\textrm{sim}(\\phi, {\\mathbf b}), \\sigma^2_I) \\\\ b_i & \\sim \\textrm{Normal}(0, \\sigma^2_{\\textrm{rbf}}) \\end{split} \\] likelihood defined : \\[ \\int {\\cal L}(I_{\\textrm{obs}}|\\phi, {\\mathbf b}', \\sigma^2_I) \\cdot {\\cal L}({\\mathbf b}'|\\sigma^2_{\\textrm{rbf}}) \\, d{\\mathbf b}. \\] \\(\\phi\\) vector set fixed-effect (unpenalized) parameters; case empty, include (example) time-constant recovery immune-waning rates, baseline transmission rate (see note ). (fixed-effect parameter usually denoted \\(\\beta\\) statistical models, ’ve already used symbol transmission coefficient …) Although looks awful, (1) high-dimensional integral \\(\\mathbf b\\) can separated product one-dimensional integrals (2) Laplace approximation gives us quick, reasonable approximation one-dimensional integrals. rbf_sd parameter can interpreted standard deviation Gaussian random effect approximately \\(1/\\sqrt{\\lambda}\\) \\(\\lambda\\) ridge penalty. Continuing coding, add parameters negative log-likelihood model, making negative log-likelihood sum two terms integral : NLL data (-sum(dnorm(I_obs, ...))) likelihood RBF parameters (-sum(dnorm(b, ...))): fit SD parameters log scale. Finally, add b vector set random parameters: tells macpan2 apply Laplace approximation parameters … Test objective function: fixme: can’t get objective function shut . specified silent = TRUE calling MakeADFun() initially, now tried assigning value several different environments, without success … step normally produces lots output (output model random effects) Laplace approximation involves additional “inner” step b parameters optimized, even though evaluating objective single set fixed parameters (log_I_sd, log_rbf_sd) fixme: note developers, cache results may need call $retape() function restore internal structure retrieving … fixme: need incantation extract full parameters (including RE parameters) order make sure $report works properly? (general, caution mutability/make sure use last.par.best internally …) Extract parameters, run simulator best-fit parameters, compare data …  fixme: artificialities example /relaxed fixed parameters standard deviations. Normally also estimating gamma (possibly prior? examples, say calibration vignette, adding priors?) RBF function penalized zero. general, augment penalized RBF component (determines variation around mean) unpenalized intercept/baseline transmission parameter. , example, transmission rate computed b0 + exp(X %*% b), b0 represents unpenalized parameter ’s allowed vary freely … fixme: compare (1) unpenalized fit; (2) penalized fit without Laplace approximation … fixme: discuss (somewhere) alternate bases latent variables (random-walk, Gaussian process, …)","code":"obs_I <- (     simulator$report(.phases = \"during\")     |> filter(row == \"I\", matrix == \"state\")     |> mutate(across(value, ~ rnorm(n(), ., sd = 50)))     |> pull(value) ) plot(obs_I, xlab = \"time\", ylab = \"prevalence\") ## copied from 'calibration/\"hello world\"' example simulator$add$matrices(               I_obs = obs_I,               I_sim = empty_matrix,                log_lik = empty_matrix,               .mats_to_save = c(\"I_sim\"),               .mats_to_return = c(\"I_sim\")           ) simulator$insert$expressions(                      I_sim ~ I,                      .phase = \"during\",                      .at = Inf                  ) simulator$add$matrices(I_sd = 1,                        rbf_sd = 1) simulator$insert$expressions(                          log_lik ~ -sum(dnorm(I_obs, rbind_time(I_sim), I_sd)) +                              -1*sum(dnorm(b, 0.0, rbf_sd)),                          .phase = \"after\"                  ) ## initially forgot this: maybe we could warn when someone is missing this???? simulator$replace$obj_fn(~ log_lik) simulator$add$transformations(Log(\"I_sd\")) simulator$add$transformations(Log(\"rbf_sd\")) ## not sure if this is required? params <- read.delim(sep = \"|\", header = TRUE,                      strip.white = TRUE, ## important!                       text = \" mat         | row | col | default log_I_sd    | 0   | 0   | 0 log_rbf_sd  | 0   | 0   | 1 \") simulator$replace$params_frame(params) rparams <- data.frame(     mat  = \"b\",     row = 0:19,     col = 0,     default = 0) simulator$replace$random_frame(rparams) res <- simulator$ad_fun()$fn(c(1,1)) #> Optimizing tape... Done #> iter: 1  value: 5834940 mgc: 2027953927 ustep: 1  #> iter: 2  value: 1266446 mgc: 1312363455 ustep: 1  #> iter: 3  value: 504276.1 mgc: 352004416 ustep: 1  #> iter: 4  value: 432087 mgc: 70722502 ustep: 1  #> iter: 5  value: 428917 mgc: 8625089 ustep: 1  #> iter: 6  value: 428886.9 mgc: 525976.1 ustep: 1  #> iter: 7  value: 428886.9 mgc: 5853.994 ustep: 1  #> iter: 8  value: 428886.9 mgc: 1.444768 ustep: 1  #> iter: 9  value: 428886.9 mgc: 2.233791e-06 ustep: 1  #> mgc: 9.270754e-06 #> [1] 429059.1 #> attr(,\"logarithm\") #> [1] TRUE ## testing: simulator$ad_fun()$fn() fit <- simulator$optimize$nlminb() ## simulator$print$matrix_dims() ## fixed effects only: ## look at parameters, but skip the random-effects parameters ## 'random' holds the indices of the parameters that are treated ## as random effects (fixed_params <- with(simulator$ad_fun()$env,                       last.par.best[-random])) #>    params    params  #>  3.916658 -4.764201 ## ??? ## RE only (ran_params <- with(simulator$ad_fun()$env,                     last.par.best[random])) #>        random        random        random        random        random  #>  0.0077623594  0.0106462453 -0.0033241271 -0.0152209556  0.0018056818  #>        random        random        random        random        random  #>  0.0036394012 -0.0049338054 -0.0138082058 -0.0043197178  0.0074629697  #>        random        random        random        random        random  #>  0.0067332443  0.0039721353  0.0027104366 -0.0021796443 -0.0103571897  #>        random        random        random        random        random  #> -0.0069793171 -0.0028926299  0.0006549716  0.0079703675  0.0090849416 pp <- simulator$ad_fun()$env$last.par.best est_I <- (     simulator$report(pp, .phases = \"during\")     |> filter(row == \"I\", matrix == \"state\")     |> pull(value) ) par(las = 1, bty = \"l\") plot(obs_I, xlab = \"time\", ylab = \"prevalence\") lines(est_I, col = 2, lwd = 2)"},{"path":"https://canmod.github.io/macpan2/articles/time_varying_parameters.html","id":"generalized-linear-mixed-models-in-progress","dir":"Articles","previous_headings":"","what":"Generalized Linear Mixed Models (In-Progress)","title":"Specifying Time-Varying Parameters","text":"","code":"#set.seed(6L) sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) simulator_rand_beta = sir$simulators$tmb(time_steps = 50   , state = c(S = 99, I = 1, R = 0)   , flow = c(foi = NA, gamma = 0.2)   , N = empty_matrix   , beta = 0.4 ) simulator_rand_beta$add$matrices(   beta_eps = norm_beta,   beta_mean = log(0.3) ) simulator_rand_beta$insert$expressions(     beta ~ 1 / (1 + exp(-beta_mean - beta_eps))   , .phase = \"during\"   , .at = 1 ) (simulator_rand_beta$report(.phases = \"during\")   %>% filter(row == \"I\", matrix == \"state\")   %>% ggplot()   + facet_wrap(~ matrix, ncol = 1, scales = 'free')   + geom_line(aes(time, value)) ) observed_I = filter(simulator_rand_beta$report(.phases = \"during\"), row == \"I\", matrix == \"state\")$value sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) simulator_step_level_re = sir$simulators$tmb(time_steps = 50   , state = c(S = 99, I = 1, R = 0)   , flow = c(foi = NA, gamma = 0.2)   , N = empty_matrix   , beta = 0.8 ) simulator_step_level_re$add$matrices(     beta_mean = log(0.5)   , beta_sd = 1   , beta_time_step = rnorm(50, 0, 0.2)   , beta_log_density = empty_matrix   , I_observed = observed_I   , log_lik = empty_matrix   , total_log_lik = empty_matrix   , .mats_to_save = \"log_lik\" ) simulator_step_level_re$insert$expressions(     beta_log_density ~ sum(dnorm(       beta_time_step,        0,        beta_sd     ))   , .phase = \"before\" ) simulator_step_level_re$insert$expressions(     beta ~ exp(beta_mean + beta_time_step[time_step(1)])   , .phase = \"during\" ) simulator_step_level_re$insert$expressions(     log_lik ~ dpois(I_observed[time_step(1)], clamp(I))   , .phase = \"during\"   , .at = Inf ) simulator_step_level_re$insert$expressions(     total_log_lik ~ sum(rbind_time(log_lik))   , .phase = \"after\" ) simulator_step_level_re$replace$params(   default = c(0, 1),   mat = c(\"beta_mean\", \"beta_sd\") ) simulator_step_level_re$replace$random(   default = rnorm(50, 0, 1),   mat = rep(\"beta_time_step\", 50),   row = 0:49 ) simulator_step_level_re$replace$obj_fn(   ~ -total_log_lik-beta_log_density-dnorm(beta_sd, 0.2, 0.01) ) simulator_step_level_re$optimize$nlminb() simulator_step_level_re$optimize$optim() #simulator_step_level_re$current$random_frame() #simulator_step_level_re$current$params_frame() #simulator_step_level_re$ad_fun()$fn(0) ggplot(simulator_step_level_re$current$random_frame()) +   geom_line(aes(row, current)) #simulator_step_level_re$cache$invalidate() #simulator_step_level_re$ad_fun()$gr(-1.23) plot(   filter(simulator_step_level_re$report(.phases = \"during\"), row == \"I\", matrix == \"state\")$value,   observed_I ) abline(0, 1)"},{"path":[]},{"path":"https://canmod.github.io/macpan2/articles/vignette_status.html","id":"stable","dir":"Articles","previous_headings":"","what":"Stable","title":"Article Status","text":"– Please read! Although mistakes always possible, please open issue find .","code":""},{"path":"https://canmod.github.io/macpan2/articles/vignette_status.html","id":"mature-draft","dir":"Articles","previous_headings":"","what":"Mature Draft","title":"Article Status","text":"– consistent accurate, yet widely utilized /checked correctness.","code":""},{"path":"https://canmod.github.io/macpan2/articles/vignette_status.html","id":"working-draft","dir":"Articles","previous_headings":"","what":"Working Draft","title":"Article Status","text":"– Makes sense, well inconsistent confusing.","code":""},{"path":"https://canmod.github.io/macpan2/articles/vignette_status.html","id":"stub","dir":"Articles","previous_headings":"","what":"Stub","title":"Article Status","text":"– even bother reading.","code":""},{"path":"https://canmod.github.io/macpan2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Steve Walker. Maintainer, author. Darren Flynn-Primrose. Author. Weiguang Guan. Author. Ben Bolker. Author. Michael Li. Contributor. Irena Papst. Contributor.","code":""},{"path":"https://canmod.github.io/macpan2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Steve Walker, Darren Flynn-Primrose, Weiguang Guan, Ben Bolker (2023). macpan2: Fast Flexible Compartmental Modelling. https://canmod.github.io/macpan2/, https://github.com/canmod/macpan2.","code":"@Manual{,   title = {macpan2: Fast and Flexible Compartmental Modelling},   author = {{Steve Walker} and {Darren Flynn-Primrose} and {Weiguang Guan} and {Ben Bolker}},   year = {2023},   note = {https://canmod.github.io/macpan2/, https://github.com/canmod/macpan2}, }"},{"path":"https://canmod.github.io/macpan2/index.html","id":"macpan2","dir":"","previous_headings":"","what":"Fast and Flexible Compartmental Modelling","title":"Fast and Flexible Compartmental Modelling","text":"McMasterPandemic developed provide forecasts insights Canadian public health agencies throughout COVID-19 pandemic. Much learned developing general purpose compartmental modelling software experience, pressure deliver regular forecasts made difficult focus software . goal macpan2 project re-imagine McMasterPandemic, building ground architectural technological decisions address many lessons learned COVID-19 software. Although macpan2 designed compartmental modelling tool agnostic underlying computational engine, currently makes use template model builder. Template model builder (TMB) R modelling package based C++ framework incorporating mature automatic differentiation matrix algebra libraries.","code":""},{"path":"https://canmod.github.io/macpan2/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Fast and Flexible Compartmental Modelling","text":"Package reference Quick-start guide Representation compartmental models [specification document] C++ engine [specification document] Project history trajectory [slides]","code":""},{"path":"https://canmod.github.io/macpan2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fast and Flexible Compartmental Modelling","text":"Users install following R commands. projects production one install specific version, following command.","code":"remotes::install_github(\"canmod/oor\") remotes::install_github(\"canmod/macpan2\") remotes::install_github(\"canmod/macpan2@v0.0.3\")"},{"path":"https://canmod.github.io/macpan2/index.html","id":"hello-world","dir":"","previous_headings":"","what":"Hello World","title":"Fast and Flexible Compartmental Modelling","text":"quick-start guide describes following hello-world SIR model.","code":"library(macpan2) sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) N = 100 simulator = sir$simulators$tmb(time_steps = 100   , state = c(S = N - 1, I = 1, R = 0)   , flow = c(foi = 0, gamma = 0.1)   , N = N   , beta = 0.2 ) sir_sims = simulator$report()"},{"path":"https://canmod.github.io/macpan2/index.html","id":"for-developers","dir":"","previous_headings":"","what":"For Developers","title":"Fast and Flexible Compartmental Modelling","text":"Developers contributors clone repository call make command-line top level directory. following make rules available getting control build process. R packages compiled code, developers edit source files compiled src directory. macpan2 single file directory called macpan2, generated automatically file misc/dev/dev.cpp. setup allows quicker C++ development cycles, developers can edit misc/dev/dev.cpp use file tests without needing re-install package new source. particular, hello-world example use dev.cpp follows. update src/macpan2 state misc/dev/dev.cpp one may run make src-update. Running misc/dev/dev.cpp print debugging information verbose manner, whereas src/macpan2.cpp . src-update make rule removes #define MP_VERBOSE flag top file.","code":"make quick-install     # for changes that only modify R source make quick-doc-install # for changes that modify R source and roxygen comments make quick-test        # quick-doc-install + run-examples + run-tests make run-examples      # help file checks only (without package rebuild) make run-tests         # run scripts in tests (without package rebuild) make full-install      # for all changes, including changes to C++ source make src-update        # push changes to dev.cpp to macpan2.cpp (see below) make enum-update       # register new C++ engine functions on the R-side make engine-doc-update # generate roxygen comments from comments in dev.cpp make doc-update        # roxygenize make pkg-build         # build the R package make pkg-install       # install the R package from the build make pkg-check         # R package checks library(macpan2) macpan2:::dev_compile() ## compile dev.cpp sir = Compartmental(system.file(\"starter_models\", \"sir\", package = \"macpan2\")) N = 100 simulator = sir$simulators$tmb(time_steps = 100   , state = c(S = N - 1, I = 1, R = 0)   , flow = c(foi = 0, gamma = 0.1)   , N = N   , beta = 0.2   , .tmb_cpp = \"dev\" ## use dev.cpp ) sir_sims = simulator$report()"},{"path":"https://canmod.github.io/macpan2/index.html","id":"product-management","dir":"","previous_headings":"","what":"Product Management","title":"Fast and Flexible Compartmental Modelling","text":"Roadmap","code":""},{"path":"https://canmod.github.io/macpan2/reference/BinaryOperator.html","id":null,"dir":"Reference","previous_headings":"","what":"Binary Operator — BinaryOperator","title":"Binary Operator — BinaryOperator","text":"Convert function represents elementwise binary operator one consistent C++ engine.","code":""},{"path":"https://canmod.github.io/macpan2/reference/BinaryOperator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Binary Operator — BinaryOperator","text":"","code":"BinaryOperator(operator)"},{"path":"https://canmod.github.io/macpan2/reference/BinaryOperator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Binary Operator — BinaryOperator","text":"operator binary operator. r binop_validity_message","code":""},{"path":"https://canmod.github.io/macpan2/reference/BinaryOperator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Binary Operator — BinaryOperator","text":"binary operator consistent C++ engine.","code":""},{"path":"https://canmod.github.io/macpan2/reference/BinaryOperator.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Binary Operator — BinaryOperator","text":"","code":"set.seed(1L) A = matrix(abs(rnorm(6)), 3, 2)  # 3 by 2 matrix x = matrix(abs(rnorm(3)))        # 3 by 1 matrix y = t(abs(rnorm(2)))             # 1 by 2 matrix times = BinaryOperator(`*`) pow = BinaryOperator(`^`) identical(times(A, x), times(x, A))  ## TRUE #> [1] TRUE identical(pow(A, x), pow(x, A))  ## FALSE #> [1] FALSE"},{"path":"https://canmod.github.io/macpan2/reference/Collection.html","id":null,"dir":"Reference","previous_headings":"","what":"Collection — Collection","title":"Collection — Collection","text":"Named collection components.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Collection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collection — Collection","text":"","code":"Collection(...)"},{"path":"https://canmod.github.io/macpan2/reference/Collection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collection — Collection","text":"... Named components.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Collection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collection — Collection","text":"Object class Collection following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Collection.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Collection — Collection","text":"$get(component_name): Return components name. $freeze(): Return object $freeze() method Files objects feel idempotent.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Collection.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Collection — Collection","text":"Much like list designed work Files. Typically one produces Collection object freezing Files object changes files represented object affect object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Compartmental.html","id":null,"dir":"Reference","previous_headings":"","what":"Compartmental Model — Compartmental","title":"Compartmental Model — Compartmental","text":"Create object containing compartmental model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Compartmental.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compartmental Model — Compartmental","text":"","code":"Compartmental(model_directory)"},{"path":"https://canmod.github.io/macpan2/reference/Compartmental.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compartmental Model — Compartmental","text":"model_directory String giving path directory containing following files, variables.csv, derivations.json, flows.csv, settings.json, described spec.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Compartmental.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compartmental Model — Compartmental","text":"object following methods fields.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Compartmental.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Compartmental Model — Compartmental","text":"$variables$(): Partition object variables. $flows(): Data frame rows giving groups flows. $flows_expanded(): Data frame rows giving individual flows. $variables$state(): Partition object state variables. $variables$flow(): Partition object flow variables. $all_labels(): Character vector giving labels variables. $labels$state(): Character vector giving labels state variables. $labels$flow(): Character vector giving labels flow variables. $labels$(): Character vector giving labels variables neither state flow variables. $expr_list(): ExprList object containing expressions.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Compartmental.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Compartmental Model — Compartmental","text":"$def: ModelFiles object representing directory defines model. $simulators: Simulators instance containing methods generating simulators, objects can generate simulations model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/DerivationExtractor.html","id":null,"dir":"Reference","previous_headings":"","what":"DerivationExtractor — DerivationExtractor","title":"DerivationExtractor — DerivationExtractor","text":"Construct object extracting derivations within Model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/DerivationExtractor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"DerivationExtractor — DerivationExtractor","text":"","code":"DerivationExtractor(model)"},{"path":"https://canmod.github.io/macpan2/reference/DerivationExtractor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"DerivationExtractor — DerivationExtractor","text":"model Object class Model","code":""},{"path":"https://canmod.github.io/macpan2/reference/DerivationExtractor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"DerivationExtractor — DerivationExtractor","text":"object class DerivationExtractor following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/DerivationExtractor.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"DerivationExtractor — DerivationExtractor","text":"$expand_derivation(derivation) -- Expand single derivation name. $expand_derivations() -- Example derivations model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Derivations2ExprList.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","title":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","text":"Convert Derivation Lists Expression Lists","code":""},{"path":"https://canmod.github.io/macpan2/reference/Derivations2ExprList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","text":"","code":"Derivations2ExprList(user_expr, standard_expr)"},{"path":"https://canmod.github.io/macpan2/reference/Derivations2ExprList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","text":"user_expr UserExpr object. standard_expr StandardExpr object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Derivations2ExprList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","text":"Object class Derivations2ExprList following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Derivations2ExprList.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","text":"$expr_list() -- alternate constructor ExprList objects set derivations. $math_expr_list() -- List MathExpressions associated set derivations.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Derivations2ExprList.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Derivation Lists to Expression Lists — Derivations2ExprList","text":".simulate_exprs -- See argument name ExprList.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ExprList.html","id":null,"dir":"Reference","previous_headings":"","what":"Expression List — ExprList","title":"Expression List — ExprList","text":"Create list expressions defining compartmental model TMB.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ExprList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expression List — ExprList","text":"","code":"ExprList(   before = list(),   during = list(),   after = list(),   .simulate_exprs = character(0L) )"},{"path":"https://canmod.github.io/macpan2/reference/ExprList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expression List — ExprList","text":"List formulas evaluated order provided simulation loop begins. formula must left hand side gives name matrix updated, right hand side giving expression containing names matrices model, functions defined macpan2.cpp, numerical literals (e.g. 3.14). available functions described engine_functions. Names can provided components , names unique.  names used .simulate_exprs argument. List formulas evaluated every iteration simulation loop, rules . List formulas evaluated simulation loop, rules . .simulate_exprs Character vector names expressions evaluated within TMB simulate blocks. useful expression evaluated computation objective function gradients (e.g. expression contains randomness discontinuities break automatic differentiation machinery TMB).","code":""},{"path":"https://canmod.github.io/macpan2/reference/ExprList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expression List — ExprList","text":"Object class ExprList following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ExprList.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Expression List — ExprList","text":"$data_arg(...): Return following components data structure pass C++. expr_output_id -- Indices list matrices identifying matrix produced. expr_sim_block -- Identified whether expression evaluated inside simulate macro within TMB. expr_num_p_table_rows -- Number rows associated expression parse table (p_table_*) eval_schedule -- Vector giving number expressions evaluate phase (, , ) simulation. p_table_x -- Parse table column giving index looking either function, matrix, literal. p_table_n -- Parse table column giving number arguments functions. p_table_i -- Parse table column giving indices looking rows parse table corresponding first argument function.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ExprList.html","id":"method-arguments","dir":"Reference","previous_headings":"","what":"Method Arguments","title":"Expression List — ExprList","text":"...: Character vector containing names matrices model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Files.html","id":null,"dir":"Reference","previous_headings":"","what":"Files — Files","title":"Files — Files","text":"Construct objects representing files disk.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Files.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Files — Files","text":"","code":"Files(directory, ..., .cache = CacheList())"},{"path":"https://canmod.github.io/macpan2/reference/Files.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Files — Files","text":"directory Path directory containing files. ... One reader_spec(s) point files within directory define Reader used access file. .cache Optional object invalidate method can called files updated.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Files.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Files — Files","text":"Object class Collection following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Files.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Files — Files","text":"$get(component_name, optional = FALSE): Return components name. optional, first check exists return NULL . $freeze(): Convert Collection object, equivalent Files object $get method returns objects. difference Files object update returns associated files change disk, whereas Collection intended (convention) immutable (hence verb 'freeze'). 'convention' bit means user free change contents private .components field, violate convention.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Files.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Files — Files","text":"Files can accessed reading R objects memory demand, caching objects. cache used return file contents unless file updated, case file accessed corresponding object re-cached.","code":""},{"path":"https://canmod.github.io/macpan2/reference/FlowExpander.html","id":null,"dir":"Reference","previous_headings":"","what":"Flow Expander — FlowExpander","title":"Flow Expander — FlowExpander","text":"Flow Expander","code":""},{"path":"https://canmod.github.io/macpan2/reference/FlowExpander.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Flow Expander — FlowExpander","text":"","code":"FlowExpander(model)"},{"path":"https://canmod.github.io/macpan2/reference/FlowExpander.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Flow Expander — FlowExpander","text":"model Object constructed ModelFiles ModelCollection.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MathExpression.html","id":null,"dir":"Reference","previous_headings":"","what":"Math Expression — MathExpression","title":"Math Expression — MathExpression","text":"Construct objects representing mathematical expressions. objects allow numeric symbolic evaluations expressions. following functions can used construct mathematical expressions: r allowed_math_functions. two alternative constructors. MathExpressionFromFunc takes numerical function returns MathExpression object. MathExpressionFromString takes character vector giving names arguments string representing expression, returns MathExpression object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MathExpression.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Math Expression — MathExpression","text":"","code":"MathExpressionFromFunc(math_function)  MathExpressionFromStrings(   expression_string,   argument_strings = character(0L),   include_dots = FALSE )"},{"path":"https://canmod.github.io/macpan2/reference/MathExpression.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Math Expression — MathExpression","text":"math_function Function takes number named numeric arguments returns numeric object. functions can used function include r allowed_math_functions. expression_string String representing expression, referring names arguments names following functions: r allowed_math_functions. argument_strings Character vector names arguments mathematical expression. include_dots expression expect three dots?","code":""},{"path":"https://canmod.github.io/macpan2/reference/MathExpression.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Math Expression — MathExpression","text":"string String representing mathematical expression. arguments Character vector names arguments mathematical expression.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MathExpression.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Math Expression — MathExpression","text":"$numeric_function(): Function numerically evaluate mathematical expression. $symbolic_function(): Function symbolically evaluate mathematical expression.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MathExpression.html","id":"method-arguments","dir":"Reference","previous_headings":"","what":"Method Arguments","title":"Math Expression — MathExpression","text":"argument signature depends expression , can found arguments field.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MatsList.html","id":null,"dir":"Reference","previous_headings":"","what":"Matrix List — MatsList","title":"Matrix List — MatsList","text":"Create list initial values matrices used define compartmental model TMB.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MatsList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matrix List — MatsList","text":"","code":"MatsList(   ...,   .mats_to_save = character(0L),   .mats_to_return = character(0L),   .dimnames = list(),   .structure_labels = NullLabels() )"},{"path":"https://canmod.github.io/macpan2/reference/MatsList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matrix List — MatsList","text":"... Named objects can coerced numerical matrices. .mats_to_save Character vector naming matrices saved set simulation calculations can make use past value (e.g. delayed effects) /able retrieved simulation history simulation complete. .mats_to_return Character vector naming matrices returned simulate complete. .dimnames Named list dimnames matrices change dimensions simulation steps. names correspond names matrices. output simulations try best honor names, shape matrix inconsistent dimnames numerical indices used instead. matrices change dimensions, set dimnames adding dimnames matrices passed .... .structure_labels optional object obtaining labels elements special vectors matrices. object can found $labels field Compartmental model. Note advanced technique.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MatsList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matrix List — MatsList","text":"Object class MatsList following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/MatsList.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Matrix List — MatsList","text":"$data_arg(): Return following components data structure pass C++. mats -- Unnamed list numeric matrices. mats_save_hist -- Boolean vector identifying matrices history saved. mats_return -- Boolean vector identifying matrices returned simulation. $mat_dims(): Return data frame giving numbers rows columns matrix list. $add_mats(...): Add matrices list return new regenerated MatsList object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Model.html","id":null,"dir":"Reference","previous_headings":"","what":"Model — Model","title":"Model — Model","text":"Construct object representing model structure.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Model.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model — Model","text":"","code":"Model(definition)"},{"path":"https://canmod.github.io/macpan2/reference/Model.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model — Model","text":"definition Output ModelFiles.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelCollection.html","id":null,"dir":"Reference","previous_headings":"","what":"Model Collection — ModelCollection","title":"Model Collection — ModelCollection","text":"model definition untied set ModelFiles.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelCollection.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model Collection — ModelCollection","text":"","code":"ModelCollection(variables, derivations, flows, settings)"},{"path":"https://canmod.github.io/macpan2/reference/ModelCollection.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model Collection — ModelCollection","text":"variables Return value variables method ModelFiles object. derivations Return value derivations method ModelFiles object. flows Return value flows method ModelFiles object. settings Return value settings method ModelFiles object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelCollection.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model Collection — ModelCollection","text":"object class ModelCollection following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelCollection.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Model Collection — ModelCollection","text":"$variables$() -- $derivations() $flows() $settings()","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelFiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Model Files — ModelFiles","title":"Model Files — ModelFiles","text":"Construct objects accessing caching model definition files.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelFiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model Files — ModelFiles","text":"","code":"ModelFiles(   model_directory,   csv_reader = CSVReader,   json_reader = JSONReader,   txt_reader = TXTReader )"},{"path":"https://canmod.github.io/macpan2/reference/ModelFiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model Files — ModelFiles","text":"model_directory String giving path directory containing following files, variables.csv, derivations.json, flows.csv, settings.json, described spec. csv_reader Class inheriting Reader reading csv files. json_reader Class inheriting Reader reading json files. txt_reader Class inheriting Reader reading txt files.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ModelFiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model Files — ModelFiles","text":"","code":"d = system.file(\"starter_models\", \"seir_symp_vax\", package = \"macpan2\") m = ModelFiles(d) m$flows() #>    from  to      flow       type from_partition to_partition flow_partition #> 1     S   E       foi per_capita            Epi          Epi            Epi #> 2     E   I     alpha per_capita            Epi          Epi            Epi #> 3     I   R     gamma per_capita            Epi          Epi            Epi #> 4 unvax vax dose_rate per_capita            Vax          Vax            Vax #>    from_to_partition from_flow_partition to_flow_partition #> 1                Vax                                  Null #> 2                Vax                                  Null #> 3                Vax                Symp              Null #> 4 Epi.Symp.SympStruc                                  Null expander = FlowExpander(m) expander$expand_flows() #>                        from                       to                     flow #> 1     S..unstructured.unvax    E..unstructured.unvax  foi..unstructured.unvax #> 2     S..unstructured.unvax    E..unstructured.unvax    foi..unstructured.vax #> 3       S..unstructured.vax      E..unstructured.vax  foi..unstructured.unvax #> 4       S..unstructured.vax      E..unstructured.vax    foi..unstructured.vax #> 5     E..unstructured.unvax   I.mild.component.unvax     alpha..unstructured. #> 6     E..unstructured.unvax I.severe.component.unvax     alpha..unstructured. #> 7       E..unstructured.vax     I.mild.component.vax     alpha..unstructured. #> 8       E..unstructured.vax   I.severe.component.vax     alpha..unstructured. #> 9    I.mild.component.unvax    R..unstructured.unvax    gamma.mild.component. #> 10 I.severe.component.unvax    R..unstructured.unvax  gamma.severe.component. #> 11     I.mild.component.vax      R..unstructured.vax    gamma.mild.component. #> 12   I.severe.component.vax      R..unstructured.vax  gamma.severe.component. #> 13    S..unstructured.unvax      S..unstructured.vax ..unstructured.dose_rate #> 14    E..unstructured.unvax      E..unstructured.vax ..unstructured.dose_rate #> 15   I.mild.component.unvax     I.mild.component.vax ..unstructured.dose_rate #> 16 I.severe.component.unvax   I.severe.component.vax ..unstructured.dose_rate #> 17    R..unstructured.unvax      R..unstructured.vax ..unstructured.dose_rate #>          type #> 1  per_capita #> 2  per_capita #> 3  per_capita #> 4  per_capita #> 5  per_capita #> 6  per_capita #> 7  per_capita #> 8  per_capita #> 9  per_capita #> 10 per_capita #> 11 per_capita #> 12 per_capita #> 13 per_capita #> 14 per_capita #> 15 per_capita #> 16 per_capita #> 17 per_capita"},{"path":"https://canmod.github.io/macpan2/reference/Namer.html","id":null,"dir":"Reference","previous_headings":"","what":"Namer — Namer","title":"Namer — Namer","text":"Name model variables parse names labelled partitions.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Namer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Namer — Namer","text":"","code":"Namer()"},{"path":"https://canmod.github.io/macpan2/reference/Namer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Namer — Namer","text":"object class Namer two methods public, names partitions, inverses .","code":""},{"path":"https://canmod.github.io/macpan2/reference/ObjectiveFunction.html","id":null,"dir":"Reference","previous_headings":"","what":"Objective Function — ObjectiveFunction","title":"Objective Function — ObjectiveFunction","text":"Define objective function compartmental model TMB.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ObjectiveFunction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Objective Function — ObjectiveFunction","text":"","code":"ObjectiveFunction(obj_fn_expr)"},{"path":"https://canmod.github.io/macpan2/reference/ObjectiveFunction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Objective Function — ObjectiveFunction","text":"obj_fn_expr One sided formula giving objective function TMB model. right hand side expression must contain names matrices model, functions defined macpan2.cpp, numerical literals (e.g. 3.14).","code":""},{"path":"https://canmod.github.io/macpan2/reference/ObjectiveFunction.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Objective Function — ObjectiveFunction","text":"Object class ObjectiveFunction following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ObjectiveFunction.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Objective Function — ObjectiveFunction","text":"data_arg(..., .existing_literals) -- Return following components data structure pass C++. o_table_x -- Objective function parse table column giving index looking either function, matrix, literal. o_table_n -- Objective function parse table column giving number arguments functions. o_table_i -- Objective function parse table column giving indices looking rows parse table corresponding first argument function. literals -- Numeric vector literals can used expressions model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/ObjectiveFunction.html","id":"method-arguments","dir":"Reference","previous_headings":"","what":"Method Arguments","title":"Objective Function — ObjectiveFunction","text":"...: Character vector containing names matrices model. .existing_literals: Numeric vector giving literals used model expressions produced objective function.","code":""},{"path":"https://canmod.github.io/macpan2/reference/OptParamsList.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimization Parameters List — OptParamsList","title":"Optimization Parameters List — OptParamsList","text":"Create object specifying matrix elements optimized integrated objective function using Laplace transform.","code":""},{"path":"https://canmod.github.io/macpan2/reference/OptParamsList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimization Parameters List — OptParamsList","text":"","code":"OptParamsList(   ...,   par_id = integer(0L),   mat = character(0L),   row_id = integer(0L),   col_id = integer(0L) )"},{"path":"https://canmod.github.io/macpan2/reference/OptParamsList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimization Parameters List — OptParamsList","text":"... Objects can coerced numeric vectors, concatenated produce default value parameter vector. par_id Integer vector identifying elements parameter vector used replace elements model matrices. mat Character vector length par_id giving names matrices containing elements replace. row_id Integer vector length par_id giving row indices matrix elements replace parameter values. col_id Integer vector length par_id giving column indices matrix elements replace parameter values.","code":""},{"path":"https://canmod.github.io/macpan2/reference/OptParamsList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimization Parameters List — OptParamsList","text":"Object class OptParamsList following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/OptParamsList.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Optimization Parameters List — OptParamsList","text":"$data_arg(..., .type_string = c(\"p\", \"r\")): Return following components data structure pass C++. {.type_string}_par_id -- Integers identifying replacing parameter. {.type_string}_mat_id -- Integers identifying matrix within element replaced. {.type_string}_row_id -- Integers identifying rows within matrices replace. {.type_string}_col_id -- Integers identifying columns within matrices replace. $vector(): Return initial value numerical parameter vector. $data_frame(): Return data frame row describing parameter.","code":""},{"path":"https://canmod.github.io/macpan2/reference/OptParamsList.html","id":"method-arguments","dir":"Reference","previous_headings":"","what":"Method Arguments","title":"Optimization Parameters List — OptParamsList","text":"...: Character vector containing names matrices model. .type_string: Either \"p\" \"r\" indicating whether object used represent fixed parameters optimized random parameters integrated using Laplace transform.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Partition.html","id":null,"dir":"Reference","previous_headings":"","what":"Partition — Partition","title":"Partition — Partition","text":"Create object manipulating partitions, sets labels representing naming model entities.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Partition.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Partition — Partition","text":"","code":"Partition(frame)"},{"path":"https://canmod.github.io/macpan2/reference/Partition.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Partition — Partition","text":"frame Data frame representing partition.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Partition.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Partition — Partition","text":"Object class Partition following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Partition.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Partition — Partition","text":"$frame() -- Partition object data frame. $dotted() -- Partition object data frame one united column. $names() -- names Partition (.e. column names). $name() -- name Partition (.e. dot-concatenated column names). $labels() -- labels Partition (.e. row-wise dot-concatenated columns). $partial_labels() -- TODO $filter(..., .wrt, .comparison_function) -- Filter keeping subset labels. $filter_out(..., .wrt, .comparison_function) -- Filter removing subset labels. $filter_ordered(..., .wrt, .comparison_function = all_equal) -- Filter order labels. ... -- Labels filter .wrt -- filtering labels respect particular Partition, .wrt name Partition. .comparison_function -- Boolean function decide filtering label equal label Partition. $select(...) -- Create new Partition subset names. rows new Partition de-duplicated. $select_out(...) -- Create new Partition without subset names. ... -- Names keep resulting Partition. $expand(name) -- TODO $union() -- TODO","code":""},{"path":"https://canmod.github.io/macpan2/reference/Partition.html","id":"fields","dir":"Reference","previous_headings":"","what":"Fields","title":"Partition — Partition","text":"products","code":""},{"path":"https://canmod.github.io/macpan2/reference/Products.html","id":null,"dir":"Reference","previous_headings":"","what":"Products — Products","title":"Products — Products","text":"Products","code":""},{"path":"https://canmod.github.io/macpan2/reference/Products.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Products — Products","text":"","code":"Products(x)"},{"path":"https://canmod.github.io/macpan2/reference/Products.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Products — Products","text":"x Object $frame method returns data frame.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Reader.html","id":null,"dir":"Reference","previous_headings":"","what":"Reader — Reader","title":"Reader — Reader","text":"Construct objects reading data.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Reader.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reader — Reader","text":"","code":"Reader(...)  CSVReader(...)  JSONReader(...)  TXTReader(...)  NULLReader(...)"},{"path":"https://canmod.github.io/macpan2/reference/Reader.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reader — Reader","text":"... Character vectors giving path components file read.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Reader.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Reader — Reader","text":"CSVReader(): Read CSV files. JSONReader(): Read JSON files. TXTReader(): Read TXT files. NULLReader(): Placeholder reader always returns NULL.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Scalar2Vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Scalar2Vector — Scalar2Vector","title":"Scalar2Vector — Scalar2Vector","text":"Construct object replacing scalar names within Model model, equivalent vector name.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Scalar2Vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Scalar2Vector — Scalar2Vector","text":"","code":"Scalar2Vector(derivation_extractor)"},{"path":"https://canmod.github.io/macpan2/reference/Scalar2Vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Scalar2Vector — Scalar2Vector","text":"derivation_extractor Object type DerivationExtractor","code":""},{"path":"https://canmod.github.io/macpan2/reference/Scalar2Vector.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Scalar2Vector — Scalar2Vector","text":"$vectorizer(expanded_derivation) $vectorize()","code":""},{"path":"https://canmod.github.io/macpan2/reference/Simulators.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulators — Simulators","title":"Simulators — Simulators","text":"Adapt Compartmental model simulation engine. Currently TMB simulation engine.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Simulators.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulators — Simulators","text":"","code":"Simulators(model)"},{"path":"https://canmod.github.io/macpan2/reference/Simulators.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulators — Simulators","text":"model Compartmental model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Simulators.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulators — Simulators","text":"object following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Simulators.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Simulators — Simulators","text":"","code":"$tmb(time_steps    , state, rate    , ...    , .mats_to_save = .mats_to_return    , .mats_to_return = \"state\"    , .dimnames = list() )"},{"path":"https://canmod.github.io/macpan2/reference/Simulators.html","id":"method-arguments","dir":"Reference","previous_headings":"","what":"Method Arguments","title":"Simulators — Simulators","text":"time_steps: number time steps run simulation. state: Named numerical vector giving default initial value state vector. names must equal model$state_labels(). flow: Named numerical vector giving default initial value flow vector. names must equal model$flow_labels(). ...: Named numerical objects can coerced matrix, giving matrices required model. .mats_to_save: Character vector names matrices save. Defaults \"state\", state vector. useful names include \"total_inflow\" (incidence associated state variable) \"total_outflow\" (total leaving state variable time step). One may also add variable model$other_labels(). See MatsList details. .mats_to_return: Character vector names matrices return. Defaults \"state\", state vector. useful names include \"total_inflow\" (incidence associated state variable) \"total_outflow\" (total leaving state variable time step). One may also add variable model$other_labels(). See MatsList details. .dimnames: Advanced often necessary.  See MatsList details.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StandardExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard Expressions — StandardExpr","title":"Standard Expressions — StandardExpr","text":"Evaluate standard model expressions.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StandardExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard Expressions — StandardExpr","text":"","code":"StandardExpr(model)"},{"path":"https://canmod.github.io/macpan2/reference/StandardExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standard Expressions — StandardExpr","text":"model Object created Model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StandardExprHazard.html","id":null,"dir":"Reference","previous_headings":"","what":"Standard Expressions for Hazard-Corrected Models — StandardExprHazard","title":"Standard Expressions for Hazard-Corrected Models — StandardExprHazard","text":"Evaluate standard expressions hazard-corrected models.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StandardExprHazard.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standard Expressions for Hazard-Corrected Models — StandardExprHazard","text":"","code":"StandardExprHazard(model)"},{"path":"https://canmod.github.io/macpan2/reference/StandardExprHazard.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standard Expressions for Hazard-Corrected Models — StandardExprHazard","text":"model Object created Model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StringData.html","id":null,"dir":"Reference","previous_headings":"","what":"String Data — StringData","title":"String Data — StringData","text":"Create objects representing names labels compartmental model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StringData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"String Data — StringData","text":"","code":"StringDataFromFrame(data)  StringDataFromDotted(labels, name)  # S3 method for StringData print(x, ...)"},{"path":"https://canmod.github.io/macpan2/reference/StringData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"String Data — StringData","text":"data Data frame names given column names labels elements columns. labels Character vector (dot-separated) partition labels. name Character scalar (dot-separated) partition name. x StringData object ... used present S3 method consistency.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StringData.html","id":"methods-by-generic-","dir":"Reference","previous_headings":"","what":"Methods (by generic)","title":"String Data — StringData","text":"print(StringData): Print StringData object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StringData.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"String Data — StringData","text":"StringDataFromFrame(): Construct object data frame without dots either names values. StringDataFromDotted(): Construct object character scalar (dot-separated) partition names character vector (dot-separated) partition labels.","code":""},{"path":"https://canmod.github.io/macpan2/reference/StringData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"String Data — StringData","text":"","code":"path = system.file(\"starter_models\", \"seir_symp_vax\", package = \"macpan2\") model = ModelFiles(path) vars = StringDataFromFrame(model$variables()) vars #> String data object with the following $frame(): #>               Epi   Symp    SympStruc       Vax #> 1               S        unstructured     unvax #> 2               E        unstructured     unvax #> 3               I   mild    component     unvax #> 4               I severe    component     unvax #> 5               I              vector     unvax #> 6               I           effective     unvax #> 7               I               total     unvax #> 8               R        unstructured     unvax #> 9  infectiousness   mild    component     unvax #> 10 infectiousness severe    component     unvax #> 11 infectiousness              vector     unvax #> 12              N        unstructured     unvax #> 13            foi        unstructured     unvax #> 14              S        unstructured       vax #> 15              E        unstructured       vax #> 16              I   mild    component       vax #> 17              I severe    component       vax #> 18              I              vector       vax #> 19              I           effective       vax #> 20              I               total       vax #> 21              R        unstructured       vax #> 22 infectiousness   mild    component       vax #> 23 infectiousness severe    component       vax #> 24 infectiousness              vector       vax #> 25              N        unstructured       vax #> 26            foi        unstructured       vax #> 27          alpha        unstructured           #> 28           beta        unstructured           #> 29          gamma   mild    component           #> 30          gamma severe    component           #> 31                       unstructured dose_rate vars$dot() #> String data object with the following $frame(): #>                   Epi.Symp.SympStruc.Vax #> 1                  S..unstructured.unvax #> 2                  E..unstructured.unvax #> 3                 I.mild.component.unvax #> 4               I.severe.component.unvax #> 5                        I..vector.unvax #> 6                     I..effective.unvax #> 7                         I..total.unvax #> 8                  R..unstructured.unvax #> 9    infectiousness.mild.component.unvax #> 10 infectiousness.severe.component.unvax #> 11          infectiousness..vector.unvax #> 12                 N..unstructured.unvax #> 13               foi..unstructured.unvax #> 14                   S..unstructured.vax #> 15                   E..unstructured.vax #> 16                  I.mild.component.vax #> 17                I.severe.component.vax #> 18                         I..vector.vax #> 19                      I..effective.vax #> 20                          I..total.vax #> 21                   R..unstructured.vax #> 22     infectiousness.mild.component.vax #> 23   infectiousness.severe.component.vax #> 24            infectiousness..vector.vax #> 25                   N..unstructured.vax #> 26                 foi..unstructured.vax #> 27                  alpha..unstructured. #> 28                   beta..unstructured. #> 29                 gamma.mild.component. #> 30               gamma.severe.component. #> 31              ..unstructured.dose_rate"},{"path":"https://canmod.github.io/macpan2/reference/TMBModel.html","id":null,"dir":"Reference","previous_headings":"","what":"TMB Model — TMBModel","title":"TMB Model — TMBModel","text":"Define compartmental model TMB. model uses spec https://canmod.net/misc/cpp_side.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBModel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TMB Model — TMBModel","text":"","code":"TMBModel(   init_mats = MatsList(),   expr_list = ExprList(),   params = OptParamsList(0),   random = OptParamsList(),   obj_fn = ObjectiveFunction(~0),   time_steps = Time(0L) )"},{"path":"https://canmod.github.io/macpan2/reference/TMBModel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TMB Model — TMBModel","text":"init_mats object class MatsList. expr_list object class ExprList. params object class OptParamsList. random object class OptParamsList. obj_fn object class ObjectiveFunction. time_steps object class Time.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBModel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TMB Model — TMBModel","text":"Object class TMBModel following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBModel.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"TMB Model — TMBModel","text":"$data_arg() -- Return components data structure pass C++. $param_arg() -- Return components parameter list pass C++. $simulator() -- Return object class TMBSimulator, can used simulate data model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBModel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"TMB Model — TMBModel","text":"","code":"sir = TMBModel(   init_mats = MatsList(     state = c(1 - 1e-2, 1e-2, 0),     beta = 0.3,     gamma = 0.2,     N = 1,     foi = 0,     ratemat = matrix(0, 3, 3),     flowmat = matrix(0, 3, 3),     .mats_to_save = c(\"state\", \"N\", \"foi\"),     .mats_to_return = c(\"state\", \"N\", \"foi\")   ),   expr_list = ExprList(     before = list(       N ~ sum(state)     ),     during = list(       foi ~ beta * state[1, 0] / N,       ratemat ~ matrix(c(         0,   0,     0,         foi, 0,     0,         0,   gamma, 0), 3, 3),       flowmat ~ ratemat * state,       state ~ state - rowSums(flowmat) + t(colSums(flowmat))     )   ),   params = OptParamsList(0.3     , par_id = 0L     , mat = \"beta\"     , row_id = 0L     , col_id = 0L   ),   random = OptParamsList(),   obj_fn = ObjectiveFunction(~ foi + 1),   time_steps = Time(time_steps = 30L) ) sir$data_arg() #> $mats #> $mats[[1]] #>      [,1] #> [1,] 0.99 #> [2,] 0.01 #> [3,] 0.00 #>  #> $mats[[2]] #>      [,1] #> [1,]  0.3 #>  #> $mats[[3]] #>      [,1] #> [1,]  0.2 #>  #> $mats[[4]] #>      [,1] #> [1,]    1 #>  #> $mats[[5]] #>      [,1] #> [1,]    0 #>  #> $mats[[6]] #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>  #> $mats[[7]] #>      [,1] [,2] [,3] #> [1,]    0    0    0 #> [2,]    0    0    0 #> [3,]    0    0    0 #>  #>  #> $mats_save_hist #> [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE #>  #> $mats_return #> [1]  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE #>  #> $expr_output_id #> [1] 3 4 5 6 0 #>  #> $expr_sim_block #> [1] 0 0 0 0 0 #>  #> $expr_num_p_table_rows #> [1]  2  8 13  3  8 #>  #> $eval_schedule #> [1] 1 4 0 #>  #> $p_table_x #>  [1] 11  0  3  2  3  1 16  0  0  1  9  8  2  3  4  5  6  4  7  8  9  2 10  2  5 #> [26]  0  0  1 18  0 13 14  6  6 #>  #> $p_table_n #>  [1]  1  0  2  2  0  0  3  0 -1 -1  3  9 -1 -1 -1 -1 -1  0 -1 -1 -1  0 -1  2  0 #> [26]  0  2  2  1  0  1  1  0  0 #>  #> $p_table_i #>  [1]  1  0  3  5  0  0  7  0  0  0 11 14  0  0  0  0  0  0  0  0  0  0  0 24  0 #> [26]  0 27 29 31  0 32 33  0  0 #>  #> $p_par_id #> [1] 0 #>  #> $p_mat_id #> [1] 1 #>  #> $p_row_id #> [1] 0 #>  #> $p_col_id #> [1] 0 #>  #> $r_par_id #> integer(0) #>  #> $r_mat_id #> integer(0) #>  #> $r_row_id #> integer(0) #>  #> $r_col_id #> integer(0) #>  #> $o_table_x #> [1]  0  4 11 #>  #> $o_table_n #> [1]  2  0 -1 #>  #> $o_table_i #> [1] 1 0 0 #>  #> $literals #>  [1] 1 0 3 3 0 0 0 0 0 0 0 1 #>  #> $time_steps #> [1] 30 #>  sir$param_arg() #> $params #> [1] 0.3 #>  #> $random #> numeric(0) #>"},{"path":"https://canmod.github.io/macpan2/reference/TMBSimulator.html","id":null,"dir":"Reference","previous_headings":"","what":"TMB Simulator — TMBSimulator","title":"TMB Simulator — TMBSimulator","text":"Construct object methods simulating optimizing compartmental model made using TMBModel.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBSimulator.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"TMB Simulator — TMBSimulator","text":"","code":"TMBSimulator(tmb_model, tmb_cpp = \"macpan2\", initialize_ad_fun = TRUE)"},{"path":"https://canmod.github.io/macpan2/reference/TMBSimulator.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"TMB Simulator — TMBSimulator","text":"tmb_model object class TMBModel. tmb_cpp Name C++ program using TMB simulation engine. initialize_ad_fun TMB AD function intialized? usually set TRUE unless want hack data structure passed TMB (can acquired using $tmb_model$make_ad_fun_arg()) passing TMB::MakeADFun. particularly useful want modify tmb_cpp.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBSimulator.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"TMB Simulator — TMBSimulator","text":"Object class TMBSimulator following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/TMBSimulator.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"TMB Simulator — TMBSimulator","text":"$report(): Runs simulations returns data frame following columns. matrix: Name matrix values returned. time: Time step values. row: Row matrix containing value. col: Column matrix containing value. value: Numerical value reported. $error_code(): simulations result engine error code associated error returned, otherwise code 0 returned. $ad_fun(): Return underlying TMB object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Time.html","id":null,"dir":"Reference","previous_headings":"","what":"Time — Time","title":"Time — Time","text":"Define number time steps compartmental model TMB.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time — Time","text":"","code":"Time(time_steps)"},{"path":"https://canmod.github.io/macpan2/reference/Time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time — Time","text":"time_steps Number time steps simulation loop.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time — Time","text":"Object class Time following methods.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Time.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Time — Time","text":"$data_arg() -- Return following components data structure pass C++. time_steps -- Number time steps simulation loop.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Transform.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform — Transform","title":"Transform — Transform","text":"Transform","code":""},{"path":"https://canmod.github.io/macpan2/reference/Transform.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform — Transform","text":"","code":"Transform(variable, default = NULL, prefix = \"\")  Log(variable, default = NULL)  Logit(variable, default = NULL)"},{"path":"https://canmod.github.io/macpan2/reference/Transform.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform — Transform","text":"variable Character string giving variable model. default (??) prefix Character string use distinguish transformed version variable.","code":""},{"path":"https://canmod.github.io/macpan2/reference/Transform.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Transform — Transform","text":"Log(): Log transformation Logit(): Logit transformation","code":""},{"path":"https://canmod.github.io/macpan2/reference/UserExpr.html","id":null,"dir":"Reference","previous_headings":"","what":"UserExpr — UserExpr","title":"UserExpr — UserExpr","text":"Evaluate user input expressions","code":""},{"path":"https://canmod.github.io/macpan2/reference/UserExpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"UserExpr — UserExpr","text":"","code":"UserExpr(model)"},{"path":"https://canmod.github.io/macpan2/reference/UserExpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"UserExpr — UserExpr","text":"model Object created Model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/cartesian.html","id":null,"dir":"Reference","previous_headings":"","what":"Cartesian Product — cartesian","title":"Cartesian Product — cartesian","text":"Cartesian Product","code":""},{"path":"https://canmod.github.io/macpan2/reference/cartesian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cartesian Product — cartesian","text":"","code":"cartesian(x, y)"},{"path":"https://canmod.github.io/macpan2/reference/cartesian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cartesian Product — cartesian","text":"x Object $frame method returns data frame. y Object $frame method returns data frame.","code":""},{"path":"https://canmod.github.io/macpan2/reference/comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Comparison Functions — comparison","title":"Comparison Functions — comparison","text":"Comparison Functions","code":""},{"path":"https://canmod.github.io/macpan2/reference/comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Comparison Functions — comparison","text":"","code":"all_equal(x, y)  all_consistent(x, y)  not_all_equal(x, y)  all_not_equal(x, y)"},{"path":"https://canmod.github.io/macpan2/reference/comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Comparison Functions — comparison","text":"x character object y character object","code":""},{"path":"https://canmod.github.io/macpan2/reference/comparison.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Comparison Functions — comparison","text":"all_equal(): true corresponding elements x y equal, shape, missing values? all_consistent(): true corresponding elements x y either equal least one blank string, shape, missing values? not_all_equal(): Complement all_equal. all_not_equal(): know yet. Currently unused; remove?","code":""},{"path":"https://canmod.github.io/macpan2/reference/empty_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Empty Matrix — empty_matrix","title":"Empty Matrix — empty_matrix","text":"Empty matrices useful defining matrices need initialized get computed required expressions. also useful placeholder matrices value certain phase simulation.","code":""},{"path":"https://canmod.github.io/macpan2/reference/empty_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Empty Matrix — empty_matrix","text":"","code":"empty_matrix"},{"path":"https://canmod.github.io/macpan2/reference/empty_matrix.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Empty Matrix — empty_matrix","text":"numeric matrix zero rows zero columns.","code":""},{"path":"https://canmod.github.io/macpan2/reference/empty_matrix.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Empty Matrix — empty_matrix","text":"","code":"s = TMBModel(   init_mats = MatsList(x = empty_matrix     , .mats_to_save = \"x\"     , .mats_to_return = \"x\"   ),   expr_list = ExprList(during = list(x ~ time_step(0))),   time_steps = Time(2) ) s$simulator()$report() #>   matrix time row col value #> 1      x    1   0   0     1 #> 2      x    2   0   0     2 #> 3      x    3   0   0     2"},{"path":"https://canmod.github.io/macpan2/reference/engine_eval.html","id":null,"dir":"Reference","previous_headings":"","what":"Engine Evaluation — engine_eval","title":"Engine Evaluation — engine_eval","text":"Evaluate expression TMB-based C++ simulation objective function engine. function useful trying engine_functions can used define macpan2 models.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_eval.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Engine Evaluation — engine_eval","text":"","code":"engine_eval(   e,   ...,   .matrix_to_return,   .tmb_cpp = \"macpan2\",   .structure_labels = NullLabels() )"},{"path":"https://canmod.github.io/macpan2/reference/engine_eval.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Evaluation — engine_eval","text":"e Expression one-sided formula, right-hand-side treated expression evaluated. ... Named objects can coerced numeric matrices. .matrix_to_return Optional name one matrices given ... returned. argument missing, matrix returned matrix returned expression right-hand-side formula. .tmb_cpp Name C++ program defining engine. Typically just want use default, macpan2, unless extending engine . .structure_labels See MatsList.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_eval.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Engine Evaluation — engine_eval","text":"Matrix produced right-hand-side matrix given .matrix_to_return provided.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_eval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Evaluation — engine_eval","text":"","code":"engine_eval(~ exp(y), y = pi) # ~ 23.14069 #>          [,1] #> [1,] 23.14069  # It is not currently possible to assign values to a subset of # a matrix in a natural way (e.g. you cannot do things like x[1] = exp(y)), # but you can achieve this functionality using the assign function. engine_eval(~ assign(x, 1, 0, exp(y))   , x = rep(0, 2)   , y = pi   , .matrix_to_return = \"x\" ) #>          [,1] #> [1,]  0.00000 #> [2,] 23.14069"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Engine Functions — engine_functions","title":"Engine Functions — engine_functions","text":"Functions currently supported C++ TMB engine constructing expressions defining model simulations.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"quickest way experiment functions use engine_eval function, following example calculates force infection.   produce simulation using functions, one may use simple_sims.","code":"engine_eval(~ beta * I / N   , beta = 0.25   , I = 1e3   , N = 1e7 ) simple_sims(   iteration_exprs = list(x ~ x - 0.9 * x),   time_steps = 5,   x = 1 )"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"elementwise-binary-operators","dir":"Reference","previous_headings":"","what":"Elementwise Binary Operators","title":"Engine Functions — engine_functions","text":"Elementwise binary operators take two matrix-valued arguments apply binary operator (e.g. +, *) set corresponding elements, return corresponding matrix-valued output containing resulting elements. 'corresponding' mean? two matrix-valued arguments shape (number rows columns), two elements correspond occur row column position two matrices. two matrices shape one row /one column either matrix, singleton rows columns recycled sufficiently many times match shape matrix. recycling singleton rows columns matrices still different shape, error thrown matrices said incompatible.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"x + y x - y x * y x / y x ^ y","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix dimensions compatible y. y -- matrix dimensions compatible x.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix binary operator applied elementwise necessary recycling rows /columns.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~ 1 + 2) engine_eval(~ y * z, y = 1:3, z = matrix(1:6, 3, 2)) engine_eval(~ 1 / (1 - y), y = 1/4)"},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-1","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"log(x) -- Natural logarithm exp(x) -- Exponential function cos(x) -- Cosine function","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-1","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-1","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix dimensions x, unary function applied elementwise.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-1","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~ log(y), y = c(2, 0.5))"},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-2","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":":-- Inclusive ordered sequence integers two bounds. seq(, length, ) -- Ordered sequence integers equal spacing adjacent values.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-2","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"-- Scalar integer giving first integer sequence. -- Scalar integer giving last integer sequence. length -- Number integers sequence. -- Scalar giving difference adjacent values sequence.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-2","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"Column vector sequence integers.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details-1","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"colon operator works much like base R version :. takes two scalar-valued integers returns column vector integers two inputs. seq function little different base R default, seq, allows user precise control length output length argument. base R function gives user option, default.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-2","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"Replicate Elements","code":"engine_eval(~ 1:10) engine_eval(~ seq(1, 10, 2))"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-3","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"rep(x, times) -- Replicate column vector number times, repeatedly stacking top . rep_each -- yet developed. rep_length -- yet developed.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-3","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- scalar-valued variable repeat. times -- scalar-valued integer variable giving number times repeat x.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-3","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"Column vector times copies x stacked top .","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-3","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~ rep(1, 10))"},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-4","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"x %*% y -- Standard matrix multiplication. x %x% y -- Kronecker product","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-4","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix. standard product, x must many columns y rows. y -- matrix. standard product, y must many rows x columns.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-4","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix product x y.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-4","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~ (1:10) %*% t(1:10)) engine_eval(~ (1:10) %x% t(1:10))"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"parenthesis","dir":"Reference","previous_headings":"","what":"Parenthesis","title":"Engine Functions — engine_functions","text":"order operations can enforced usual way round parentheses, (.","code":""},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-5","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"c(...) -- Stack columns arguments single column vector. cbind(...) -- Create matrix containing columns group matrices number rows. rbind(...) -- Create matrix containing rows group matrices number columns. matrix(x, rows, cols) -- Reshape matrix rows rows cols columns. input x must rows * cols elements. t(x) -- Standard matrix transpose.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-5","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"... -- number dimensionally consistent matrices. definition dimensionally consistent depends function. x -- Can matrix t, matrix must rows * cols elements. rows -- Scalar integer giving number rows output. cols -- Scalar integer giving number columns output.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-5","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"combined reshaped matrix.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details-2","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"number column vectors can combined bigger column vector. Column row vectors length can combined using cbind rbind functions respectively matrix function can used redefine numbers rows columns use arranging values matrix. works similarly base R matrix function takes arguments. hand, function differs substantially base R version must filled column byrow option. Matrices can transposed usual function, t.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-5","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~ c(a, b, c), a = 1, b = 10:13, c = matrix(20:25, 3, 2)) engine_eval(~ cbind(a, 10 + a), a = 0:3) engine_eval(~ rbind(a, 10 + a), a = t(0:3)) engine_eval(~ matrix(1:12, 4, 3)) engine_eval(~ t(1:3))"},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-6","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"to_diag(x) -- Create diagonal matrix setting diagonal column vector, x. from_diag(x) -- Extract diagonal matrix, x, return diagonal column vector.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-6","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix (from_diag) column vector (to_diag). common assume x square from_diag required.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-6","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"to_diag(x) -- Diagonal matrix x diagonal. from_diag(x) -- Column vector containing diagonal x. value considered diagonal row index equal column index.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details-3","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"to_diag function can used produce diagonal matrix setting column vector equal desired diagonal. from_diag (almost) opposite, get column vector containing diagonal existing matrix.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-6","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~from_diag(matrix(1:9, 3, 3))) engine_eval(~to_diag(from_diag(matrix(1:9, 3, 3)))) engine_eval(~from_diag(to_diag(from_diag(matrix(1:9, 3, 3)))))"},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-7","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"sum(...) -- Sum elements matrices passed .... colSums(x) -- Row vector containing sums column. rowSums(x) -- Column vector containing sums row. groupSums(x, f, n) -- Column vector containing sums groups elements x. groups determined integers f order sums output determined integers.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-7","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"... -- number matrices shape. x -- matrix dimensions, except groupSums expects x column vector. f -- column vector length x containing integers 0 n-. n -- Length output column vector.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-7","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix containing sums various groups elements x.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details-4","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"standard rowSums colSums can used, slightly different behaviour base R versions. particular, rowSums function returns column vector colSums function returns row vector. specific shape required transpose t function must explicitly used.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-7","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"x = 1 y = 1:3 A = matrix(1:12, 4, 3) engine_eval(~ sum(y), y = y) engine_eval(~sum(x, y, A), x = x, y = y, z = z) engine_eval(~ colSums(A), A = A) engine_eval(~ rowSums(A), A = A) engine_eval(~ groupSums(x, f, n), x = 1:10, f = rep(0:3, 1:4), n = 4)"},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-8","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"x[,j] -- Matrix containing subset rows columns x. block(x,,j,n,m) -- Matrix containing contiguous subset rows columns x https://eigen.tuxfamily.org/dox/group__TutorialBlockOperations.html","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-8","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix. -- integer column vector ([) integer scalar (block) containing indices rows extract ([) index first row extract (block). j -- integer column vector ([) integer scalar (block) containing indices columns extract ([) index first column extract (block). n -- Number rows block return. m -- Number columns block return.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-8","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix containing subset rows columns x.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details-5","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"Note zero-based indexing used first row/column gets index, 0, etc.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-8","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"engine_eval(~ A[c(3, 1, 2), 2], A = matrix(1:12, 4, 3))"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"accessing-past-values-in-the-simulation-history","dir":"Reference","previous_headings":"","what":"Accessing Past Values in the Simulation History","title":"Engine Functions — engine_functions","text":"matrices simulation history saved, possible bind rows columns past versions matrices single matrix.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-9","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"rbind_lag(x, lag, t_min) -- Bind rows versions x recorded end simulation iterations corresponding time lags given integers lag. rbind_time(x, t, t_min) -- Bind rows versions x recorded end simulation iterations corresponding integers t. cbind_lag(x, lag, t_min) -- Bind columns versions x recorded end simulation iterations corresponding time lags given integers lag. (TODO -- cbind_lag developed yet) cbind_time(x, t, t_min) -- Bind columns versions x recorded end simulation iterations corresponding integers t. (TODO -- cbind_lag developed yet)","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-9","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix saved history number columns (rbind_*) rows (cbind_*) change throughout simulation. lag -- Column vector integers giving numbers time steps current step obtain past values x. t -- Column vector integers giving time steps obtain past values x. t_min -- Minimum time step allowed accessed. time-steps t implied lag t_min ignored.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-9","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix containing values x past times.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"time-indexing","dir":"Reference","previous_headings":"","what":"Time Indexing","title":"Engine Functions — engine_functions","text":"Get index current lagged time step index current time group. time group contiguous set time steps defined two change points.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-10","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"time_step(lag): Get time-step associated particular lag current time-step. lagged time-step less zero, function returns zero. time_group(index, change_points): Update index associated current time group. current group defined minimum elements change_points greater current time step. time group index index associated element. Please see examples , easier understand explanation.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-10","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"lag: Number time-steps look back time-step return. index: Index associated current time group. change_points: Increasing column vector time steps giving lower bound time group.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-10","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"1--1 matrix time-step lag steps ago, zero t+1 < lag","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-9","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"simple_sims(   iteration_exprs = list(x ~ time_step(0)),   time_steps = 10,   x = empty_matrix ) sims = simple_sims(   iteration_exprs = list(     j ~ time_group(j, change_points),     time_varying_parameter ~ time_variation_schedule[j]   ),   time_steps = 10,   j = 0,   change_points = c(0, 4, 7),   time_variation_schedule = c(42, pi, sqrt(2)),   time_varying_parameter = empty_matrix )"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"convolution","dir":"Reference","previous_headings":"","what":"Convolution","title":"Engine Functions — engine_functions","text":"One may take convolution element matrix, x, simulation time using kernel, k. two arguments function.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-11","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"convolution(x, k)","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-11","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- matrix containing elements convolved. k -- column vector giving convolution kernel.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-11","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"matrix size x convolutions, \\(y_{ij}\\), element, \\(x_{ij}\\), given following. $$y_{ij} = \\sum_{\\tau = 0} x_{ij}(t-\\tau) k(\\tau)$$ unless \\(t < \\tau\\), case, $$y_{ij} = $$ \\(y_{ij}\\) convolution, \\(x_{ij}(t)\\) value \\(x_{ij}\\) time step, \\(t\\), \\(k(\\tau)\\) value kernel lag, \\(\\tau\\), \\(\\lambda\\) length kernel.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"details-6","dir":"Reference","previous_headings":"","what":"Details","title":"Engine Functions — engine_functions","text":"empty matrices encountered looking back time, treated matrices zeros. Similarly, matrices encounte x","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"clamp","dir":"Reference","previous_headings":"","what":"Clamp","title":"Engine Functions — engine_functions","text":"Smoothly clamp elements matrix get closer 0 tolerance, eps, default 1e-12. output clamp function follows.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-12","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"clamp(x, eps)","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-12","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x : matrix elements remain positive. eps : small positive number giving theoretical minimum elements returned matrix.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"probability-densities","dir":"Reference","previous_headings":"","what":"Probability Densities","title":"Engine Functions — engine_functions","text":"probability densities first two arguments. observed simulated simulated argument gives matrix means observed values densities evaluated. Additional arguments distributional parameters standard deviation dispersion parameter. densities given log-densities, like density must pass result exp function. simulated matrix additional parameter matrices either single row single column, singleton rows columns repeated match number rows columns observed matrix. feature allows one things like specify single common mean several values.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-13","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"dpois(observed, simulated) -- Log Poisson density based dpois TMB function. dnbinom(observed, simulated, over_dispersion) -- Log negative binomial density based dnbinom TMB function. get variance function requires use expression, simulated + simulated^2/over_dispersion, following p.165 book dnorm(observed, simulated, standard_deviation) -- Log normal density based dnorm TMB function.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-13","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"observed -- Matrix observed values density evaluated. simulated -- Matrix distributional means, singleton rows columns recycled match numbers rows columns observed. over_dispersion -- -dispersion parameter given (simulated/standard_deviation)^2 - simulated). standard_deviation -- Standard deviation parameter.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"pseudo-random-number-generators","dir":"Reference","previous_headings":"","what":"Pseudo-Random Number Generators","title":"Engine Functions — engine_functions","text":"random number generator functions mean first argument. Subsequent arguments give additional distributional parameters. Singleton rows columns matrices passed additional distributional parameters recycled arguments number rows columns. functions return matrix shape mean pseudo-random numbers deviating mean mean matrix.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-14","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"rpois(mean) -- Pseudo-random Poisson distributed values. rnbinom(mean, over_dispersion) -- Pseudo-random negative binomially distributed values. rnorm(mean, standard_deviation) -- Pseudo-random normal values.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-14","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"mean -- Matrix means simulate pseudo-random variation. over_dispersion -- Matrix -dispersion parameters given (simulated/standard_deviation)^2 - simulated). standard_deviation -- Matrix standard deviation parameters.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"assign","dir":"Reference","previous_headings":"","what":"Assign","title":"Engine Functions — engine_functions","text":"Assign values subset elements matrix.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-15","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"assign(x, , j, v)","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-15","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- Matrix elements updated values v. -- Column vector row indices pointing elements x updated. indices paired v. length equal v, must single index gets paired every element v. j -- Column vector column indices pointing elements x updated. indices paired v. length j equal v, must single index gets paired every element v. v -- Column vector values replace elements x locations given j.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-12","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"assign function called return value, empty_matrix, rather modify x replacing components v.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-10","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"","code":"x = matrix(1:12, 3, 4) engine_eval(~ x + 1, x = x) engine_eval(~ x + 1, x = x, .matrix_to_return = \"x\") engine_eval(~ assign(x, 2, 1, 100), x = x, .matrix_to_return = \"x\") engine_eval(~ assign(x   , c(2, 1, 0)   , 0   , c(100, 1000, 10000) ), x = x, .matrix_to_return = \"x\")"},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"unpack","dir":"Reference","previous_headings":"","what":"Unpack","title":"Engine Functions — engine_functions","text":"Unpack elements matrix smaller matrices.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"functions-16","dir":"Reference","previous_headings":"","what":"Functions","title":"Engine Functions — engine_functions","text":"unpack(x, ...)","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"arguments-16","dir":"Reference","previous_headings":"","what":"Arguments","title":"Engine Functions — engine_functions","text":"x -- Matrix elements distributed matrices passed .... ... -- Matrices elements replaced values elements x column-major order.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"return-13","dir":"Reference","previous_headings":"","what":"Return","title":"Engine Functions — engine_functions","text":"unpack function called return value, empty_matrix, rather modify matrices ... replacing least components x.","code":""},{"path":"https://canmod.github.io/macpan2/reference/engine_functions.html","id":"examples-11","dir":"Reference","previous_headings":"","what":"Examples","title":"Engine Functions — engine_functions","text":"fill matrix integers 1 12 unpack one---time two column vectors, x y. returning y see integers first three used x.","code":"engine_eval(~unpack(matrix(1:12, 3, 4), x, y)   , x = rep(0, 3)   , y = rep(1, 5)   , .matrix_to_return = \"y\" )"},{"path":"https://canmod.github.io/macpan2/reference/finalizer.html","id":null,"dir":"Reference","previous_headings":"","what":"Finalizers — finalizer","title":"Finalizers — finalizer","text":"Finalizers","code":""},{"path":"https://canmod.github.io/macpan2/reference/finalizer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Finalizers — finalizer","text":"","code":"finalizer_char(x)  finalizer_index(x)"},{"path":"https://canmod.github.io/macpan2/reference/finalizer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Finalizers — finalizer","text":"x Raw parsed expression.","code":""},{"path":"https://canmod.github.io/macpan2/reference/finalizer.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Finalizers — finalizer","text":"finalizer_char(): Finalize parsed expression parse table little human readable. finalizer_index(): Finalize parsed expression parse table can passed C++ engine.","code":""},{"path":"https://canmod.github.io/macpan2/reference/initial_valid_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Initial Valid Variables — initial_valid_vars","title":"Initial Valid Variables — initial_valid_vars","text":"Initial Valid Variables","code":""},{"path":"https://canmod.github.io/macpan2/reference/initial_valid_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Initial Valid Variables — initial_valid_vars","text":"","code":"initial_valid_vars(valid_var_names)"},{"path":"https://canmod.github.io/macpan2/reference/initial_valid_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Initial Valid Variables — initial_valid_vars","text":"valid_var_names Character vector variable names.","code":""},{"path":"https://canmod.github.io/macpan2/reference/macpan2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"macpan2 — macpan2-package","title":"macpan2 — macpan2-package","text":"R package -McMasterPandemic package compartmental epidemic modelling forecasting analysis infectious diseases.","code":""},{"path":[]},{"path":"https://canmod.github.io/macpan2/reference/macpan2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"macpan2 — macpan2-package","text":"Maintainer: Steve Walker swalk@mcmaster.ca Authors: Darren Flynn-Primrose Weiguang Guan Ben Bolker contributors: Michael Li [contributor] Irena Papst [contributor]","code":""},{"path":"https://canmod.github.io/macpan2/reference/make_expr_parser.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate an Arithmetic Expression Parser — make_expr_parser","title":"Generate an Arithmetic Expression Parser — make_expr_parser","text":"Generate Arithmetic Expression Parser","code":""},{"path":"https://canmod.github.io/macpan2/reference/make_expr_parser.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate an Arithmetic Expression Parser — make_expr_parser","text":"","code":"make_expr_parser(parser_name = \"parse_expr\", finalizer = force)"},{"path":"https://canmod.github.io/macpan2/reference/make_expr_parser.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate an Arithmetic Expression Parser — make_expr_parser","text":"parser_name Name parsing function character string. finalizer Function used post-process parsed formula. default identity finalizer, returns parsed formula .  good choices finalizer_char, can used understand formula parsed, finalizer_index, can passed C++ engine. result function another function takes single argument, x.  resulting function recursive.  x argument one-sided formula first time recursive function called.  subsequent evaluations recursion, x list following structure.  x formula, must contain named list functions called valid_funcs named list variables called valid_vars. x list names numeric objects represent leaf parse tree n integer vector length x give number arguments associated functions x 0 otherwise index identifying element x corresponding first argument associated function 0 function valid_funcs named list valid functions extracted environment formula parsed valid_vars named list default values valid variables extracted environment formula parsed input_expr_as_string input formula stored string","code":""},{"path":"https://canmod.github.io/macpan2/reference/make_expr_parser.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate an Arithmetic Expression Parser — make_expr_parser","text":"","code":"parser = make_expr_parser('parser', finalizer_char) foi = ~ beta * I / 100 valid_funcs = setNames(   list(`*`, `/`),   c(\"*\", \"/\") ) valid_vars = list(beta = 0.1, I = 30) parser(foi) #> Error in get(parser_name, parent.frame()): object 'parser' not found"},{"path":"https://canmod.github.io/macpan2/reference/model_starter.html","id":null,"dir":"Reference","previous_headings":"","what":"Model Starter — model_starter","title":"Model Starter — model_starter","text":"Create directory template model definition.","code":""},{"path":"https://canmod.github.io/macpan2/reference/model_starter.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model Starter — model_starter","text":"","code":"model_starter(starter_name, dir_name)"},{"path":"https://canmod.github.io/macpan2/reference/model_starter.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model Starter — model_starter","text":"starter_name Currently can sir. dir_name String giving path directory copying template model definition.","code":""},{"path":"https://canmod.github.io/macpan2/reference/nlist.html","id":null,"dir":"Reference","previous_headings":"","what":"Self Naming List — nlist","title":"Self Naming List — nlist","text":"Self Naming List","code":""},{"path":"https://canmod.github.io/macpan2/reference/nlist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Self Naming List — nlist","text":"","code":"nlist(...)"},{"path":"https://canmod.github.io/macpan2/reference/nlist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Self Naming List — nlist","text":"... Objects put list","code":""},{"path":"https://canmod.github.io/macpan2/reference/parse_expr_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse Expression List — parse_expr_list","title":"Parse Expression List — parse_expr_list","text":"Parse list one-sided formulas representing expressions compartmental model.","code":""},{"path":"https://canmod.github.io/macpan2/reference/parse_expr_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse Expression List — parse_expr_list","text":"","code":"parse_expr_list(   expr_list,   valid_vars,   valid_literals = numeric(0L),   offset = 0L )"},{"path":"https://canmod.github.io/macpan2/reference/parse_expr_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse Expression List — parse_expr_list","text":"expr_list List one-sided formulas. valid_vars Named list numerical matrices can referred formulas. valid_literals optional existing numeric vector valid literals related expression list. offset zero-based row index first row table. useful combining tables.","code":""},{"path":"https://canmod.github.io/macpan2/reference/rbf.html","id":null,"dir":"Reference","previous_headings":"","what":"Radial Basis Functions — rbf","title":"Radial Basis Functions — rbf","text":"Radial Basis Functions","code":""},{"path":"https://canmod.github.io/macpan2/reference/rbf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Radial Basis Functions — rbf","text":"","code":"rbf(time_steps, dimension, scale = time_steps/dimension)"},{"path":"https://canmod.github.io/macpan2/reference/rbf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Radial Basis Functions — rbf","text":"time_steps number time steps model dimension number gaussians basis scale width gaussians","code":""},{"path":"https://canmod.github.io/macpan2/reference/reader_spec.html","id":null,"dir":"Reference","previous_headings":"","what":"Reader Spec — reader_spec","title":"Reader Spec — reader_spec","text":"Bundle file path Reader.","code":""},{"path":"https://canmod.github.io/macpan2/reference/reader_spec.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reader Spec — reader_spec","text":"","code":"reader_spec(file, reader, optional = FALSE)"},{"path":"https://canmod.github.io/macpan2/reference/reader_spec.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reader Spec — reader_spec","text":"file Path single file. reader One functions documented Readers. optional file optional ?","code":""},{"path":"https://canmod.github.io/macpan2/reference/reader_spec.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reader Spec — reader_spec","text":"function takes path find file returns named list one element giving instantiated Reader object name given file name extension removed. path may optionally broken path components, assembled using file.path.","code":""},{"path":"https://canmod.github.io/macpan2/reference/reader_spec.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reader Spec — reader_spec","text":"Typically function used defining object inherits Files.","code":""},{"path":"https://canmod.github.io/macpan2/reference/show_models.html","id":null,"dir":"Reference","previous_headings":"","what":"Print a table of contents of available models — show_models","title":"Print a table of contents of available models — show_models","text":"Collects information headers README files model directories returns results data frame","code":""},{"path":"https://canmod.github.io/macpan2/reference/show_models.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print a table of contents of available models — show_models","text":"","code":"show_models(   dir = system.file(\"starter_models\", package = \"macpan2\"),   show_missing = FALSE )"},{"path":"https://canmod.github.io/macpan2/reference/show_models.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print a table of contents of available models — show_models","text":"dir directory list show_missing (logical) include entries models README information?","code":""},{"path":"https://canmod.github.io/macpan2/reference/show_models.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print a table of contents of available models — show_models","text":"data frame containing entries dir (model directory), title (model title), index_entry (short description)","code":""},{"path":"https://canmod.github.io/macpan2/reference/show_models.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print a table of contents of available models — show_models","text":"","code":"show_models(show_missing = TRUE) #>              dir                                title #> 1            age                   basic ageing model #> 2  flow_examples                     Flow types model #> 3    macpan_base                          MacPan base #> 4           seir                           basic SEIR #> 5      seir_symp                  Advanced SEIR model #> 6  seir_symp_vax Advanced SEIR model with vaccination #> 7       seir_vax               SEIR vaccination model #> 8            sir                            basic SIR #> 9       sir_demo                    SIR demonstration #> 10       sir_vax                SIR vaccination model #> 11    sir_waning             SIR with waning immunity #> 12       testing                        Testing model #> 13           vax              Basic vaccination model #> 14            ww                     Wastewater model #> 15   SI_products                                 <NA> #>                                                     index_entry #> 1            aging model with six age groups and vital dynamics #> 2                         A model to demonstrate all flow types #> 3      re-implementation of the McMaster group's COVID-19 model #> 4                  vanilla epidemic model with an exposed class #> 5         An SEIR model with stratification by symptom severity #> 6  An SEIR model including severity of symptoms and vaccination #> 7        An SEIR model that includes the effects of vaccination #> 8                                  a very simple epidemic model #> 9                             An SIR model with birth and death #> 10                       an SIR model that includes vaccination #> 11               a basic SIR model with a flow from R back to S #> 12                             A simple model of testing status #> 13                    A simple vaccination model without waning #> 14          Macpan base with an additional wastewater component #> 15                                                         <NA>"},{"path":"https://canmod.github.io/macpan2/reference/simple_sims.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple Iterated Simulation — simple_sims","title":"Simple Iterated Simulation — simple_sims","text":"Simple Iterated Simulation","code":""},{"path":"https://canmod.github.io/macpan2/reference/simple_sims.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple Iterated Simulation — simple_sims","text":"","code":"simple_sims(iteration_exprs, time_steps, ...)"},{"path":"https://canmod.github.io/macpan2/reference/simple_sims.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple Iterated Simulation — simple_sims","text":"iteration_exprs List expressions pass engine. expressions allowed use valid engine_functions. time_steps Number time steps iterate. ... Named list numeric objects can coerced numeric matrix objects. matrices can referred name expressions iteration_exprs.","code":""},{"path":"https://canmod.github.io/macpan2/reference/simple_sims.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple Iterated Simulation — simple_sims","text":"data frame simulation results returned $report() method TMBSimulator.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_labels.html","id":null,"dir":"Reference","previous_headings":"","what":"To Labels — to_labels","title":"To Labels — to_labels","text":"Convert objects labels, vectors can dotted.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_labels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To Labels — to_labels","text":"","code":"to_labels(x)"},{"path":"https://canmod.github.io/macpan2/reference/to_labels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"To Labels — to_labels","text":"x Object convert labels.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_labels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"To Labels — to_labels","text":"Character vector can used labels.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_name.html","id":null,"dir":"Reference","previous_headings":"","what":"To Name — to_name","title":"To Name — to_name","text":"Convert objects name, scalar string can dotted.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_name.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To Name — to_name","text":"","code":"to_name(x)"},{"path":"https://canmod.github.io/macpan2/reference/to_name.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"To Name — to_name","text":"x Object convert labels.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_name.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"To Name — to_name","text":"Character string can used name.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_names.html","id":null,"dir":"Reference","previous_headings":"","what":"To Names — to_names","title":"To Names — to_names","text":"Convert objects names, character vectors following restrictions:  (1) dots, (2) values must start letter, (3) characters must letters, numbers, underscores.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"To Names — to_names","text":"","code":"to_names(x)"},{"path":"https://canmod.github.io/macpan2/reference/to_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"To Names — to_names","text":"x Object convert names.","code":""},{"path":"https://canmod.github.io/macpan2/reference/to_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"To Names — to_names","text":"Character vector can used names.","code":""},{"path":"https://canmod.github.io/macpan2/reference/union_vars.html","id":null,"dir":"Reference","previous_headings":"","what":"Union of Variables — union_vars","title":"Union of Variables — union_vars","text":"Take union set variable lists, represented Partition object.","code":""},{"path":"https://canmod.github.io/macpan2/reference/union_vars.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Union of Variables — union_vars","text":"","code":"union_vars(...)"},{"path":"https://canmod.github.io/macpan2/reference/union_vars.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Union of Variables — union_vars","text":"... Partition objects combine.","code":""},{"path":"https://canmod.github.io/macpan2/news/index.html","id":"macpan2-003","dir":"Changelog","previous_headings":"","what":"macpan2 0.0.3","title":"macpan2 0.0.3","text":"Optimize C++ simulation history storage avoiding unnecessary allocations Use state flow names expression inserters Chattier validity checking Radial basis functions macpan-base – re-implementation McMaster group’s COVID-19 model macpan2 ww – wastewater model (doesn’t yet readme) new readme clean previous models Report expression broke C++ side Developer tools switching different C++ files working directories Package reference organization cleanup (thanks @bbolker ) Time-varying parameters vignette","code":""},{"path":"https://canmod.github.io/macpan2/news/index.html","id":"macpan2-002","dir":"Changelog","previous_headings":"","what":"macpan2 0.0.2","title":"macpan2 0.0.2","text":"Interface optimization TMB simulation objects TMB simulation model updating caching Parameter transformations Get initial values matrices TMB simulation objects State flow variable names can used expressions contexts Example model indexing (thank @bbolker!) Engine function rbind_time defaults row binding full simulation history Fix bug entire model inflows outflows Fix bugs symbolic R-side manipulation expressions Fix previously broken argument_dots option model definition files (thank @Flynn-Primrose )","code":""},{"path":"https://canmod.github.io/macpan2/news/index.html","id":"macpan2-001","dir":"Changelog","previous_headings":"","what":"macpan2 0.0.1","title":"macpan2 0.0.1","text":"Initial release.","code":""}]
