% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mp_tmb_calibrator.R
\name{mp_optimize}
\alias{mp_optimize}
\alias{mp_optimize.TMBCalibrator}
\title{Optimize Simulation Model}
\usage{
mp_optimize(model, optimizer, ...)

\method{mp_optimize}{TMBCalibrator}(
  model,
  optimizer = c("nlminb", "optim", "DEoptim", "optimize", "optimise"),
  ...
)
}
\arguments{
\item{model}{A model object capable of being optimized. Typically
this object will be produced using \code{\link{mp_tmb_calibrator}}.}

\item{optimizer}{Name of an implemented optimizer. See below for the
options and details on using each option.}

\item{...}{Arguments to pass to the \code{optimizer}.Details on Using Each Type of Optimizer
\subsection{\code{nlminb}}{

The default optimizer is \code{\link{nlminb}}. This optimizer uses
gradients and Hessians computed by the
\href{https://kaskr.github.io/adcomp/_book/Introduction.html}{template model builder}
engine of \code{macpan2}. This optimizer is efficient at local optimization
by exploiting the Hessian matrix of second derivatives, which gives
the optimizer information about how far to step during each iteration.
However, this optimzer can struggle if the objective function has
multiple optima.

To set control parameters (e.g., maximum number of iterations), one
may use the following.

\if{html}{\out{<div class="sourceCode">}}\preformatted{mp_optimize(model, "nlminb", control = list(iter.max = 800))
}\if{html}{\out{</div>}}

See the \code{\link{nlminb}} help page for the complete list of
control parameters and what the output means.
}

\subsection{\code{optim}}{

The \code{\link{optim}} optimizer does not use second derivatives
(compare with the description of \code{\link{nlminb}}), and so
could be less efficient at taking each step. However, we
find that it can be somewhat better at getting out of local optima,
although the \code{"DEoptim"} optimizer is designed for objective functions
with multiple optima (see description below).

To set control parameters (e.g., maximum number of iterations), one
may use the following.

\if{html}{\out{<div class="sourceCode">}}\preformatted{mp_optimize(model, "nlminb", control = list(maxit = 800))
}\if{html}{\out{</div>}}

See the \code{\link{optim}} help page for the complete list of
control parameters and what the output means.

Note that if your model is parameterized by only a single parameter,
you will get a warning asking you to use "Brent" or \code{optimize()}
directly. You can ignore this warning if you are happy with your
answer, or can do either of the suggested options as follows.

\if{html}{\out{<div class="sourceCode">}}\preformatted{mp_optimize(model, "optim", method = "Brent", lower = 0, upper = 1.2)
mp_optimize(model, "optimize", c(0, 1.2))
}\if{html}{\out{</div>}}

Note that we have to specify the upper and lower values, between
which the optimizer searches for the optimum.
}

\subsection{\code{DEoptim}}{

The \code{DEoptim} optimizer is a function in the \code{DEoptim} package, and
so you will need to have this package installed to use this option.
It is designed for objective functions with multiple optima. Use
this method if you do not believe the fit you get by other methods.
The downsides of this method is that it doesn't use gradient or
Hessian information, and so it is likely to be inefficient when
the default starting values are close to the optimum, and it just
generally will be slower because it utilizes multiple starting points
to try to get out of local optima.

Because this optimizer starts from multiple places on the parameter
space, you need to specify upper and lower values for the parameter
vector -- between which different starting values will be chosen.
Here is how that is done.

\if{html}{\out{<div class="sourceCode">}}\preformatted{mp_optimize(model, "DEoptim", lower = c(0, 0), upper = c(1.2, 1.2))
}\if{html}{\out{</div>}}

Note that in this example we have two parameters, and therefore need
to specify two \code{lower} and two \code{upper} sets of values.
}

\subsection{\code{optimize} and \code{optimise}}{

This optimizer can only be used for models parameterized with one
parameter, and it is necessary to specify upper and lower values for
this parameter using the following approach.

\if{html}{\out{<div class="sourceCode">}}\preformatted{mp_optimize(model, "optimize", c(0, 1.2))
}\if{html}{\out{</div>}}
}}
}
\value{
The output of the \code{optimizer}. The \code{model} object is modified
and saves the history of optimization outputs. These outputs can be
obtained using \code{\link{mp_optimizer_output}}.
}
\description{
Calibrate a model that has been parameterized, typically by using
\code{\link{mp_tmb_calibrator}} to produce such a model.
}
\details{
The \code{\link{mp_tmb_calibrator}} models that get passed to
\code{mp_optimize} will remember both their original default parameters
set at the time the model was created, and their currently best
parameters that get the updated when \code{mp_optimize} is run. The
optimization is started from the currently best parameter set.
Therefore, if you find yourself in a local minimum you might need
to either recreate the model using \code{\link{mp_tmb_calibrator}}
or use \verb{optimzer = "DEoptim}, which is more robust to objective
functions with multiple optima.
}
\section{Methods (by class)}{
\itemize{
\item \code{mp_optimize(TMBCalibrator)}: Optimize a TMB calibrator.

}}
\examples{
spec = ("starter_models"
  |> mp_tmb_library("seir", package = "macpan2")
  |> mp_tmb_update(default = list(beta = 0.6))
)
sim = mp_simulator(spec, 50, "infection")

## simulate data to fit to, but remove the start of the
## simulated epidemic in order to make it more difficult
## to fit.
data = mp_trajectory(sim)
data = data[data$time > 24, ]
data$time = data$time - 24

## time scale object that accounts for the 24-steps of
## the epidemic that are not captured in the data.
## in real life we would need to guess at this number 24.
time = mp_sim_offset(24, 0, "steps")

## model calibrator with one transmission parameter to calibrate
cal = mp_tmb_calibrator(spec
  , data = data
  , traj = "infection"
  , par = "beta"
  , default = list(beta = 1)
  , time = time
)

## this takes us into a local optimum at beta = 0.13,
## which is far away from the true value of beta = 0.6.
mp_optimize(cal)

## this gets us out of the optimum and to the true value.
mp_optimize(cal, "optimize", c(0, 1.2))

}
