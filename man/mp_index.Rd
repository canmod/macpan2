% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mp_index.R
\name{mp_index}
\alias{mp_index}
\alias{print.Index}
\alias{names.Index}
\alias{labelling_column_names.Index}
\alias{to_labels.Index}
\alias{labels.Index}
\title{Model Quantity Index Table}
\usage{
mp_index(..., labelling_column_names)

\method{print}{Index}(x, ...)

\method{names}{Index}(x)

\method{labelling_column_names}{Index}(x)

\method{to_labels}{Index}(x)

\method{labels}{Index}(x, ...)
}
\arguments{
\item{...}{Character vectors to combine to produce an index. Alternatively,
any number of data frames of character-valued columns. If data frames are
supplied, their rows will be bound and the result converted to an index if
possible.}

\item{labelling_column_names}{A \code{\link{character}} vector of the names
of the index that will be used to label the model components (i.e. rows)
being described. The \code{labelling_column_names} cannot have duplicates
and must contain at least one name. The index given by the
\code{labelling_column_names} must uniquely identify each row.
The default \code{NULL} gives the set of columns, in order starting with
the first column, that are required to uniquely identify each row.}
}
\description{
Make an index table to enumerate model quantity labels by category. These
objects generalize and wrap \code{\link{data.frame}}s, where each column is a
label category and each row is an index. Indices must contain
only letters, numbers, and underscores. Blank empty string entries are
allowed, but missing values (\code{NA}s) are not.
}
\details{
For example, the following index table describes the state variables of the
model:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sir = mp_index(Epi = c("S", "I", "R"))
print(sir)
#>  Epi
#>    S
#>    I
#>    R
}\if{html}{\out{</div>}}

Here, the column \code{Epi} denotes that the category of these labels is
epidemiological. There is nothing special about this specific choice of
category name; we could have also used another name like \code{Compartment}.

However, in more complicated models, it is good to think carefully about
choosing descriptive category names. For example, in an age-structured SIR
model, we could add an \code{Age} column to generate an index table as follows:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sir_age = mp_index(
 Epi = rep(c("S", "I", "R"), 2),
 Age = rep(c("young", "old"), each = 3)
)
print(sir_age)
#>  Epi   Age
#>    S young
#>    I young
#>    R young
#>    S   old
#>    I   old
#>    R   old
}\if{html}{\out{</div>}}

Here, having the first column in the index table labeled \code{Compartment} would
be somewhat misleading, as the compartments aren't actually just "S", "I",
and "R", they are each of the epidemiological states stratified by the age
groups "young" and "old".

This index table could also be generated by first specifying individual index
tables for the \code{Epi} and \code{Age} columns, and then using a \code{macpan2} product
function that combines the tables into a single index table:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{sir = mp_index(Epi = c("S", "I", "R"))
age = mp_index(Age = c("young", "old"))
prod = mp_cartesian(sir, age)
prod
#>  Epi   Age
#>    S young
#>    I young
#>    R young
#>    S   old
#>    I   old
#>    R   old
}\if{html}{\out{</div>}}

The \code{\link[=mp_cartesian]{mp_cartesian()}} function will produce a table with entries that are all
possible combinations of the individual index tables. The "See Also" section
of the \code{\link[=mp_cartesian]{mp_cartesian()}} help page catalogues all available product functions.

We can produce the full labels of model quantities, which are simply
dot-concatenated indices, one for each entry in the index table, using the
\code{labels()} function:

\if{html}{\out{<div class="sourceCode">}}\preformatted{#> [1] "S.young" "I.young" "R.young" "S.old"   "I.old"   "R.old"
}\if{html}{\out{</div>}}

Dots are not allowed in indices so that the labels can be inverted to
reproduce the original index table (provided that the column names can be
retrieved).

It is recommended to use UpperCamelCase for the columns of index tables
and single uppercase characters ("S", "I"), all lowercase character
strings ("gamma"), and/or snake_case strings ("aging_rate") for indices. This
convention helps when reading code that contains references to both column
names and indices.
}
\section{Functions}{
\itemize{
\item \code{print(Index)}: Print an index.

\item \code{names(Index)}: Get the names of the columns of an index.

\item \code{labelling_column_names(Index)}: Retrieve the \code{labelling_column_names} of
an index. These are the names of the columns that are used to label
the model components.

\item \code{to_labels(Index)}: Convert an index into
a character vector giving labels associated with each model component
(i.e. row) being described.

\item \code{labels(Index)}: Convert an index into
a character vector giving labels associated with each model component
(i.e. row) being described.

}}
\examples{
state = mp_index(
  Epi = c("S", "I", "S", "I"),
  Age = c("young", "young", "old", "old")
)
print(state)
labels(state)
mp_cartesian(state, mp_index(City = c("hamilton", "toronto")))

}
\seealso{
\code{\link[=mp_structured_vector]{mp_structured_vector()}}

\code{\link[=mp_set_numbers]{mp_set_numbers()}}

Other functions that return index tables
\code{\link{mp_cartesian}()},
\code{\link{mp_rename}()},
\code{\link{mp_subset}()},
\code{\link{mp_union}()}
}
\concept{indexes}
