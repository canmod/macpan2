---
title: "Model Definitions in McMasterPandemic"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Model Definitions in McMasterPandemic}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
library(macpan2)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Prerequisites

This document assumes knowledge of compartmental epidemic models. We will not be defining terms and symbols that we consider to be widely understood by mathematical epidemiologists.

## Document Goals

This document describes a specification for a data structure to represent compartmental models. The goal of this document is not to define a spec for a user interface for constructing compartmental models. Instead, we define the data structure here so that interfaces for creating instances of compartmental models can be designed without needing to grapple with issues of how to represent and store model definitions.

## User Stories

This spec design has been guided by several high-level user stories, which we outline briefly.

> As a modeller, I want to use software that provides an
> extensive set of modelling capabilities, so that I can
> address specific and changing public health needs.

> As a modeller, I want to build complex models out of
> simpler -- easier to understand -- modular sub-models,
> so that I can more easily modify the structure of my
> model as public health needs change.

> As a developer, I want to be able to quickly add a new
> modelling capability, so that I can support public
> health modellers in as timely a manner as possible.

These and other [user-stories](https://canmod.github.io/macpan-book/index.html#vision-and-direction) were developed by working with public-health modellers during the COVID-19 pandemic in Canada.


## Compartmental Models

A compartmental model is a named list of the following three components.

1. `variables` -- A data frame describing the variables in the model.
2. `derivations` -- A list of instructions on how to update the `variables` at each iteration of a model simulation.
3. `flows` -- A data frame describing what variables are state variables and the magnitudes of flows to and from compartments.
4. `settings` -- A named list of elements the determine how components 1-3 are used by the software.

The following sections describe each of these components in more detail.

## Variables and Partitions

The `variables` component is a data frame with one row for each variable in the model and one column for each labelled partition of the variables. A labelled partition is a character vector of labels that describes the variables. Each row of this data frame must be unique so that it uniquely identifies each variable.

For example, here is a standard SEIR model list of variables.

```{r, echo = FALSE}
Epi = data.frame(Epi = c("S", "E", "I", "R", "beta", "alpha", "gamma"))
Epi
```

This example has a single labelled partition, `Epi`. This partition uniquely identifies each variable and so we do not need other partitions to comply with the uniqueness requirement.  Still, it is often convenient to add other partitions to refer to multiple variables at the same time. For example it might help to distinguish between state variables and parameters and also between infected states and non-infected states.

```{r, echo = FALSE}
data.frame(
  Type = c(
    rep("state", 4), 
    rep("param", 3)
  ),
  Infect = c(
    "not_infected", "infected", "infected", "not_infected", 
    "", "", ""
  ),
  Epi = c(
    "S", "E", "I", "R", 
    "beta", "alpha", "gamma"
  )
)
```

We emphasize that the list with the single `Epi` partition did not violate this spec, as it is not required to add a partition to make a distinction between state variables and parameters. The spec makes this distinction in the [Edge Variables and Flow Rates] component. In this example, the addition of the `Type` and `Infect` partitions are for convenience. The point is that the user is free to add any number of partitions even if they are not required for uniqueness.

Note that we do not provide a column for the numeric quantity of each variable because this is a spec for a compartmental model data structure. By working with pure model structure objects, we can combine different atomic models to more easily produce models with more structure. When it comes time to use a model, the [computational engine](https://canmod.net/misc/cpp_side) can be used to associate model variables with numerical quantities.

Non-empty labels must contain only letters, numbers, underscores, and must start with a letter. Empty labels are zero-length strings that can be used to indicate that some partitions are not applicable to some variables. The purpose for these naming rules is to facilitate the construction of [Variable Names] that can be inverted to reproduce the `variables` list.

By convention we use [UpperCamelCase](https://en.wikipedia.org/wiki/Camel_case) for partition names and a modified form of  [snake_case](https://en.wikipedia.org/wiki/Snake_case) for labels. Our modification of snake case allows for single uppercase letters in order to accommodate the convention in epidemiology for using single uppercase letters to refer to state variables. For example, `S`, `I`, and `R`, as well as `I_mild` and `I_severe`, would be consistent with our modified snake case style.

## Required Partitions

There is a component, `settings$required_partitions`, which is a character vector of the names of the partitions that are used to uniquely identify each variable. In the previous example with `Type`, `Infect`, and `Epi` partitions we have `settings$required_partitions == "Epi"`. We refer to the labels associated with required partitions as required labels. Every variable must have at least one non-empty required label. The required partitions are used to generate [Variable Names].


## Atomic and Non-Atomic Models

We refer to models with exactly one required partition as atomic. One may combine two atomic models to get another model with two required labelled partitions. An example combination of atomic models is the SEIR model stratified by the states of an atomic vaccination model with required partition, `Vax`.

```{r, echo = FALSE}
Vax = data.frame(Vax = c("unvax", "vax", "dose_rate"))
Vax
```

In this atomic model `unvax` and `vax` are state variables representing the numbers of individuals who are unvaccinated and vaccinated. The `dose_rate` variable is a parameter giving the proportion of unvaccinated individuals who receive a vaccination each day.

We combine these two atomic models to produce a non-atomic model with required partitions, `Epi` and `Vax`.

```{r, echo = FALSE}
seir_vax = data.frame(
  Epi = c(rep(c("S", "E", "I", "R", "beta"), 2), "alpha", "gamma", ""),
  Vax = c(rep(c("unvax", "vax"), each = 5), "", "", "dose_rate")
)
seir_vax
```

Note here that the state variables, `S`, `E`, `I`, and `R`, as well as the transmission rate, `beta`, are stratified by vaccination status, but the latency and recovery parameters, `alpha` and `gamma`, are not stratified indicating that latency and recovery is not influenced by vaccination status. Similarly the `dose_rate` is also not stratified by epidemiological state.

Consider one more example with different symptomatic statuses, where infectious individuals have either mild or severe symptoms and these different statuses recover at different rates.

```{r, echo = FALSE}
EpiSympVax = data.frame(
  Epi = c(rep(c("S", "E", "I", "I", "R", "beta"), 2), "alpha", "gamma", "gamma", ""),
  Symp = c(rep(c("", "", "mild", "severe", "", ""), 2), "", "mild", "severe", ""),
  Vax = c(rep(c("unvax", "vax"), each = 6), "", "", "", "dose_rate")
)
EpiSympVax
```


## Variable Names

Although each row of the `variables` list provides a unique identifier for each variable, it is convenient to be able to combine the required labels into a single string. We call this string the variable name.

The name of a variable is the dot-delimited concatenation of the partitions in `settings$required_partitions` associated with the variable. For example, the following table contains the labelled partitions of the `Epi`-by-`Symp`-by-`Vax` variable list with a fourth column giving the variable names.
```{r, echo = FALSE}
m = data.frame(
  Epi = c(rep(c("S", "E", "I", "I", "R", "beta"), 2), "alpha", "gamma", "gamma", ""),
  Symp = c(rep(c("", "", "mild", "severe", "", ""), 2), "", "mild", "severe", ""),
  Vax = c(rep(c("unvax", "vax"), each = 6), "", "", "", "dose_rate")
)
m$variable_names = Namer()$names(m)
m
```
This choice of a dot delimiter leads to syntactically valid R names even if the name begins with one or more dot. Because dots are not allowed in the labels themselves, this delimiter also makes parsing the labels into their respective partitions unambiguous. Note that it is impossible to have names with all dots because all variables must have at least one non-blank label. 

The biggest downside to the choice of a dot delimiter is that it conflicts with the [tidyverse style](https://style.tidyverse.org/syntax.html), which requires using dots only to specify S3 method dispatch. The reason for this guideline is to reduce the chances of ambiguity when the S3 machinery searches for methods. This disadvantage is in our opinion outweighed by the advantages that we list above, because model variables will not be involved in S3 dispatch.

Variable names are invertible, in that a vector of variable names can be combined with a vector of partition names to reproduce the associated labelled partitions. This fact allows us to choose either the labelled partitions or names representation depending on convenience or necessity.


## Partition Sets

The `required_paritions` component is a set of partitions that are used to uniquely identify each variable and to generate invertible variable names. The user is free to define other `partition_sets` so that they can refer to groups of variables by name. These sets can be used to filter the variables for a specific purpose. Such `partition_sets` are useful when combining models.

Variable names can be used with respect to a particular partition set. Variable names with respect to some partition sets do not uniquely identify each variable. For example, `Epi.Symp == "I.mild"` occurs twice in the following example.
```{r echo = FALSE}
m = data.frame(
  Epi = c(rep(c("S", "E", "I", "I", "R", "beta"), 2), "alpha", "gamma", "gamma", ""),
  Symp = c(rep(c("", "", "mild", "severe", "", ""), 2), "", "mild", "severe", ""),
  Vax = c(rep(c("unvax", "vax"), each = 6), "", "", "", "dose_rate")
)
m$Epi.Symp = paste(m$Epi, m$Symp, sep = ".")
m$Epi.Vax = paste(m$Epi, m$Vax, sep = ".")
m
```

The ability to refer to multiple variables with a single name is useful in many circumstances. Typically such non-unique names are unique within groups of variables. For example, `Epi.Symp == `"I.mild"` is unique within `Vax == "vax"` and within `Vax == "unvax"`.

As the examples above have illustrated, the name of a partition set is the dot-delimited concatenation of the names of the partitions in the set. For example, `Epi.Symp` is the name of the partition set containing the `Epi` and `Symp` partitions.


## Derived Variables

Now that we have a solid mechanism for representing, referring to, and grouping model variables, we can begin to consider defining [Flow between Compartments]. When the rate of flow from one compartment to another is given by a model parameter (e.g. recovery rate, `gamma`), then it is straightforward to describe the flow between those compartments (e.g. `I` to `R`). However, when the flow rate is a function of parameters and state variables (e.g. force of infection), we first need to define how to compute such a rate.

In this section we describe a data structure for representing mathematical expressions for deriving model variables that must be recomputed at each iteration of a simulation. Flow rates such as the force of infection is an example of such a derived variable. There are many other examples, including sums of groups of (e.g. vaccinated) compartments, model summaries such as $\mathcal{R}_0$, and convolutions of infected compartments for modelling under-reporting and reporting delays.

Each derived variable must be represented by a row in the `variables` list. Derived variables are distinguished from input variables by being associated with an element in a list, `derivations`. This list contains objects that describe how to compute each derived variable. Each object contains the following components.

* `group_partition` [optional] -- The name of a partition set to use for filtering and grouping the variables so that (1) only a subset of variables are utilized in order to produce the derived variables and (2) a set of derived variables can be produced at the same time by producing one derived variable per group. When `group_partition` is missing, all variables are potentially utilized by a single derived variable.
* `group_names` [required if `group_partition` is not missing] -- A vector of variable names with respect to the `group_partition`, each of which will define a single group. The `group_names` also determine the labels of variables that distinguish groups from each other. There are three use cases.
    * `group_names` and `group_partition` are both missing -- All variables are potentially utilized by a single derived variable
    * `length(group_names) == 1L` -- A filtered subset of variables get utilized by a single derived variable
    * `length(group_names) == n` -- The variables in each of `n` groups are used to produce one of `n` derived variables
* `output_partition` [required] -- The name of a partition set to use for declaring the labels of the derived variables within each group (see `group_partition` and `group_names` for producing one derived variable per group). 
* `output_names` [required] -- A vector of variable names with respect to the `output_partition`, each of which will determine the labels associated with the `output_partition` of each derived variable within its group. If `group_names` are missing then `output_names` must be a single variable name with respect to the `output_partition` for determining the labels for the derived variable. Otherwise, the `i`th element of `output_names` determines the labels for the derived variable produced by the `i`th element of `group_names`.
* `input_partition` [required] -- The name of a partition set to use for matching variables to arguments in the `math_function`. Every variable name with respect to the `input_partition` must be both unique and exist within each group.
* `input_names_dots` [required if `math_function` has a `...` argument] -- A vector of variable names with respect to the `input_partition` for finding variables to pass to a `...` argument in `math_function`, if it exists.
* `math_function` [required] -- A mathematical function for producing one derived variable per group. The names of the arguments of this function are a subset of variable names with respect to the `input_partition` and optionally a `...` argument.

The spec for this component will be hard to understand on first reading. To understand it better we provide several examples designed to justify and clarify the description in the above bullet list.

We begin with defining the force of infection for an SEIR model with the following variable list.
```{r echo = FALSE}
Epi
```
The force of infection for this model can be represented as follows.
```{r eval = FALSE}
list(
  output_partition = "Epi",
  output_names = "foi",
  input_partition = "Epi",
  math_function = function(S, E, I, R, beta) {
    I * beta / sum(S, E, I, R)
  }
)
```
Because this is an [atomic model](#atomic-and-non-atomic-models), by specifying `output_partition = "Epi"` and `output_names "foi"`, we are really just saying that the name of the output variable is `"foi"`. More technically we would say that the derived variable will have the label `"foi"` in the `"Epi"` partition. The `input_partition` and `math_function` go together. The `math_function` describes how to compute the derived variable, `foi`, in terms of other variables. The `input_partition` gives the name of a [partition set](#partition-sets) to use for matching model variables to the arguments of this function. For example, the argument list contains `S`, which is a label in the `Epi` partition set.

This description may seem unnecessarily complex, but it is useful for representing more complex models as we will see. Also remember that this is a spec for a data structure and not a user interface -- it is likely that a user interface for specifying this component would make it much simpler to do so.

Updating derived variable specifications when taking model products is reasonably straightforward with this data structure. For example, consider stratifying `S`, `E`, `I`, `R`, and `beta` by geographic location.
```{r echo = FALSE}
seir_vax = data.frame(
  Epi = c(rep(c("S", "E", "I", "R", "beta"), 2), "alpha", "gamma", ""),
  Location = c(rep(c("montreal", "toronto"), each = 5), "", "", "dose_rate")
)
```
In this new model, the functional form of the force of infection remains constant and we simply update and add some of the [partition sets and variable names](#partition-sets).
```{r eval = FALSE}
list(
  group_partition = "Location",
  group_names = c("montreal", "toronto"),
  output_partition = "Epi",
  output_names = c("foi", "foi"),
  input_partition = "Epi",
  math_function = function(S, E, I, R, beta) I * beta / sum(S, E, I, R)
)
```
This will define expressions to produce derived variables called `foi.montreal` and `foi.toronto`. To get this list we did the following.

1. Added geographical grouping information to specify how to stratify the force of infection.
2. Repeat the entry in `output_names` once for each location.

This model product assumes that individuals in Toronto cannot be infected by individuals in Montreal. This is a reasonable assumption for this spatial stratification, but in models where the stratification does not isolate compartments from each other we need to add an additional derived variable that sums the force of infection components over the strata. Consider for example the SEIR model stratified by vaccination status.
```{r echo = FALSE}
seir_vax
```
We can compute the force of infection components just as we did for the spatial model.
```{r eval = FALSE}
list(
  group_partition = "Vax",
  group_names = c("unvax", "vax"),
  output_partition = "Epi",
  output_names = c("foi", "foi"),
  input_partition = "Epi",
  math_function = function(S, E, I, R, beta) I * beta / sum(S, E, I, R)
)
```
But to complete the model product we must add a derived variable that takes the sum of all of the `Epi == "foi"` variables.
```{r eval = FALSE}
list(
  grouping_partition = NULL,
  grouping_names = NULL,
  output_partition = "epi.vax",
  output_names = "foi.total",
  input_partition = "epi.vax",
  input_names_dots = c("foi.unvax", "foi.vax"),
  math_function = function(...) sum(...)
)
```
This will produce a single derived variable called `foi.total`, which can be used as the force of infection for all vaccination strata.

There are other operations on model space besides model products. Another such operation is to convert a single compartment into several compartments. An example of this operation is breaking the infectious compartment into several symptomatic states.
```{r echo = FALSE}
EpiSympVax
```

```{r eval = FALSE}
list(
  group_partition = "epi",
  group_names = "C", ## group is effectively acting as a filter here
  output_partition = "shape",
  output_names = "vec",
  input_partition = "symp",
  input_names_dots = c("mild", "severe"),
  math_function = function(...) c(...)
)
list(
  group_partition = "epi.symp.vax",
  group_names = c("I.mild.unvax", "I.mild.vax", "I.severe.unvax", "I.severe.vax"),
  output_partition = "epi.matrix",
  output_names = "I.matrix",
  input_partition = "epi.symp.vax.shape",
  input_names_dots = c("I.mild.unvax.", "I.mild.vax.", "I.severe.unvax.", "I.severe.vax."),
  math_function = function(C.vec, ...) {
    data = unlist(list(...))
    matrix(data, nrow = length(C.vec))
  }
)
```

```{r eval = FALSE}
list(
  grouping_partition = "epi.vax",
  grouping_names = c("I.unvax", "I.vax"),
  output_partition = "epi.symp",
  output_names = "I.effective",
  input_partition = "epi.symp",
  input_names_dots = c("I.mild", "I.severe", "C.mild", "C.severe"),
  math_function = function(...) sum(...)
)
```

```{r eval = FALSE}
list(
  grouping_partition = "vax",
  grouping_names = c("unvax", "vax"),
  output_partition = "epi.vax",
  output_names = c("foi.unvax", "foi.vax"),
  input_partition = "epi.symp",
  math_function = function(S., E., I.any, R., beta.) I.any * beta. / sum(S., E., I.any, R.)
)
```


that take input variables and other derived variables as arguments and return a derived variable either numerically or symbolically. The numerical version is required when running simulations or fitting models to data, whereas the symbolic version is required when combining models.


The ordering of the `expressions` list must be topologically sorted so that the dependencies of each expression must appear earlier in the list. This topological sorting requirement presents a technical challenge when models are combined, as it becomes necessary to be able to merge lists of `expressions` so that they remain topologically sorted.


One could use such an `expressions` list to update a symbolic expression for the atomic SEIR model so that applies to a single stratum in an `epi`-by-`vax` model. For example, here we find the component of the force of infection due to the unvaccinated individuals.
```{r eval=FALSE}
expressions$foi$symbolic$evaluate(
  I = "I.unvax",
  N = expressions$N$symbolic$evaluate(
    S = "S.unvax",
    E = "E.unvax",
    I = "I.unvax",
    R = "R.unvax"
  ),
  beta = "beta.unvax"
)
```


## Flow between Compartments

We have another data frame, `flows`, describing which variable pairs are connected by flows. There are two columns in this data frame, `from` and `to`, and the rows give pairs of variable names. The variable identified by the `i`th row of `from` flows into `to` in model simulations.

For example, consider this SIR model.

```{r, echo = FALSE}
data.frame(epi = c("S", "I", "R", "beta", "gamma"))
```

We would have the following `flows` component.

```{r, echo = FALSE}
data.frame(from = c("S", "I"), to = c("I", "R"))
```

Notice that all state variables appear in this table, and that it contains no parameters. This is the mechanism for encoding whether a model component is a state variables or a parameter.

A more interesting example is an `epi`-by-`vax` model.

```{r, echo = FALSE}
data.frame(
  from = c("S.unvax", "I.unvax", "S.vax", "I.vax", "S.unvax", "I.unvax", "R.unvax"),
  to = c("I.unvax", "R.unvax", "I.vax", "R.vax", "S.vax", "I.vax", "R.vax")
)
```

## Model of Flow along Edges (nowhere near comprehensible)

The flow for each edge of an atomic model is given by an atomic flow function, which take model variables as arguments. For example, 

The flow for each edge is given by the inner product of two vectors ...

In the SEIR model there are three edges -- exposure, symptom expression, and recovery.

Each model has a set of atomic functions of model variables. These atomic functions are applied to compute the flow along model edges.

Each edge is associated with an atomic flow function


## Operations on Model Space

### Example Atomic Models

```{r}
sir = list(
  variables = data.frame(
    type = c("state", "state", "state", "params", "params", "derived", "derived"),
    epi = c("S", "I", "R", "beta", "gamma", "N", "foi")
  ),
  expressions = list(
    N = list(
      arguments = c(".state"),
      expression = "sum(.state)"
    )
  )
)
sir
```

```{r}
seir = list(
  variables = data.frame(
    epi = c(
      "S", "E", "I", "R", 
      "beta", "alpha", "gamma", 
      "state", "N", "foi"
    )
  ),
  expressions = list(
    state = function(S, E, I, R) c(S, E, I, R),
    N = function(state) sum(state),
    foi = function(I, beta, N) I * beta / N
  ),
  edges = data.frame(
    from = c("S", "E", "I"),
    to = c("E", "I", "R"),
    flow_component = c("foi", "alpha", "gamma"),
    component_type = c("rate", "rate", "rate")
  )
)
seir
```

```{r}
vaccination = list(
  variables = data.frame(vax = c("unvax", "vax", "dose_rate")),
  expressions = list(),
  edges = data.frame(
    from = "unvax", 
    to = "vax",
    flow_component = "dose_rate",
    component_type = "rate"
  )
)
vaccination
```

```{r}
symptom_level = list(
  variables = data.frame(
    sev = c("mild", "severe", "effective", "Cm", "Cs")
  ),
  expressions = list(
    effective = function(mild, severe, Cm, Cs) {
      Cm * mild + Cs * severe
    }
  ),
  edges = list()
)
symptom_level
```

### Types of Operations

#### Product

1. All states get the Cartesian product
2. The user can decide what parameters to stratify (or not stratify?)
3. Derived variables are checked in order to make sure that either all of their arguments are stratified or none of them are
    a. If all (any??) arguments are stratified, then the derived variable is stratified
    b. Else if no arguments are stratified, then the derived variable is not stratified
    c. Otherwise throw an error
4. Edges are stratified
5. If the `flow_component` is stratified, the user must choose between one of the following
    a. Sum over the strata to get a total `flow_component` that is used for each stratum of the edge
    b. Match the strata of the edges to the strata of the flow components

A product of `seir` and `vaccination` is the following.

```{r}
epi_states = c("S", "E", "I", "R")
vax_states = c("unvax", "vax")
epi_params_var = "beta"
epi_params_const = c("alpha", "gamma")
vax_params_const = "dose_rate"
epi_derived_var = c("state", "N", "foi")
seir_x_vaccination = list(
  variables = data.frame(
    epi = c(
      rep(epi_states, times = length(vax_states)),
      rep(epi_params_var, times = length(vax_states)),
      epi_params_const,
      rep("", length(vax_params_const)),
      rep(epi_derived_var, times = length(vax_states))
    ),
    vax = c(
      rep(vax_states, each = length(epi_states)),
      rep(vax_states, each = length(epi_params_var)),
      rep("", length(epi_params_const)),
      vax_params_const,
      rep(vax_states, each = length(epi_derived_var))
    )
  ),
  expressions = list(
    ## each of these expressions is actually two expressions,
    ## one for each vaccination stratum.
    state. = function(S., E., I., R.) c(S., E., I., R.),
    N. = function(state.) sum(state.),
    foi. = function(I., beta., N.) I. * beta. / N.
  ),
  edges = data.frame(
    from = c(
      "S.unvax", "S.vax",
      "E.unvax", "E.vax", 
      "I.unvax", "I.vax", 
      "S.unvax", "E.unvax", "I.unvax", "R.unvax"
    ),
    to = c(
      "E.unvax", "E.vax",
      "I.unvax", "I.vax", 
      "R.unvax", "R.vax",
      "S.vax", "E.vax", "I.vax", "R.vax"
    ),
    flow_component = c(
      "foi.sum", "foi.sum", ## note use of the special 'sum' label
      "alpha.", "alpha.",
      "gamma.", "gamma.",
      ".dose_rate", ".dose_rate", ".dose_rate", ".dose_rate"
    ),
    component_type = "rate"
  )
)
seir_x_vaccination
```


#### Compartment expansion

* A compartment in one model is selected
* Another model of compartment sub-types is used to expand this compartment
* 




