---
title: "Quickstart part 1: understanding model specification in `macpan2`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Quickstart Guide: specifying and simulating a simple compartmental model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

[![status](https://img.shields.io/badge/status-working%20draft-red)](https://canmod.github.io/macpan2/articles/vignette-status#working-draft)

```{r setup, echo = FALSE, message = FALSE}
library(macpan2)
library(ggplot2)
library(dplyr)
```

[

- change "link_data" to "ledgers" in `mp_*()` API
- consolidate spec in examples with steve's presentation

]

# Motivation

One of the main goals of `macpan2` is to provide a flexible grammar for model specification that reduces friction when build upon and expanding an existing model. This goal complements the standard approach of modelling, which is to start simply and add complexity as needed. 

There is a trade-off between the flexibility and the simplicity of the model grammar: specifying a simple model may not always be very concise, and there is a learning curve to the model grammar. However, it can be very powerful when it comes to specifying **structured** models, such as models including:

- age-structure
- multiple locations (a metapopulation model)
- strain replacement
- testing processes to identify infections
- vaccination status
- infection types (asymptomatic, symptomatic)

[add links to papers with these?]

This vignette seeks to explain `macpan2`'s model specification grammar and in particular how one could take a simple model and expand it with additional structure. The package also comes with a model library (see `vignette("example_models")`) to get users started with commonly used basic models, and to demonstrate some more complex cases. 

# Amuse bouche: a structured SIR model {#amuse-bouche}

A key to `macpan2`'s flexible model grammar is the use of **archetypes** to repeat the same kinds of calculation across model structures. For instance, consider an SIR model that has two pathogen strains (without co-infections):

[insert diagram of SIR with two strains]

Here, 

- $S$, $I_A$, $I_B$, and $R$ are the number of individuals that are susceptible, infectious with strain A, infectious with strain B, and recovered, respectively,
- $\beta_A$ and $\beta_B$ are the transmission rates for strains A and B, respectively,
- $\gamma$ is the recovery rate for all infecteds.

We can cast this model as a system of difference equations:

\begin{align}
S_{t+1} &= - [\beta_a (I_A)_t/N + \beta_s (I_B)_t/N] S_t, \\ 
(I_A)_{t+1} &= \beta_A (I_A)_t/N - \gamma (I_A)_t, \\ 
(I_B)_{t+1} &= \beta_B (I_B)_t/N - \gamma (I_B)_t, \\ 
R_{t+1} &= \gamma (I_A)_t + \gamma (I_B)_t.
\end{align}

where $N$ is the total population size ($S + I_A + I_B + R$). We notice that each force of infection, $\lambda_A = \beta_A (I_A)/N$ and  $\lambda_B = \beta_B (I_B)/N$ has the same **form**, that is, using an expression like $\lambda = \beta I / N$.

When numerically simulating this model, it doesn't take much effort to write out each calculation separately as something like:

```
lambda.A = beta.A I.A/N
lambda.B = beta.B I.B/N
```

However, in `macpan2`, we can specify a single calculation archetype for it, for instance something like,
```
lambda = beta * I / N
```

and then attach a **ledger** to the model object that tabulates which specific calculations to do under this archetype, that is, a record of which specific `lambda`, `beta`, and `I` to use each time we invoke this archetype during the simulation. 

Here, there would only be two calculations in the force of infection ledger (one calculation per strain), but one can easily imagine a more complicated case. For instance, consider an age-structured metapopulation model with 10 age groups within each of the 11 patches: there would be 10x10x11 = `r 10*10*11` force of infection terms of the same form (one per combination of age groups to capture the options for susceptible and infected interaction, repeated in each of the 11 patches).

By using calculation **archetypes** and **ledgers**, the modeller can focus on the modelling (designing model structure, choosing an expression for the forces of infection), while `macpan2` will handle the bookkeeping (matching stratified variables with each other each time the expression must be calculated). This approach cuts down on rote repetition when setting up model calculations, which in turn reduces the opportunity for bugs in the simulation code. It also means that expanding a model can be as simple as updating the calculation ledger, as opposed to directly editing specific calculations in the simulation code. 

# Appetizer: specifying the basic SIR model

Let's start with specifying the basic SIR model in `macpan2`, which is the foundation of the two-strain model above:

\begin{align}
S_{t+1} &= -\beta S_t I_t/N, \\ 
I_{t+1} &= \beta S_t I_t/N - \gamma I_t, \\ 
R_{t+1} &= \gamma I_t.
\end{align}

It will be helpful to set $\lambda = \beta I/N$ and recast the equations as:

\begin{align}
S_{t+1} &= -\lambda S_t, \\ 
I_{t+1} &= \lambda S_t - \gamma I_t, \\ 
R_{t+1} &= \gamma I_t.
\end{align}

Since the focus of this quickstart guide is `macpan2`'s model specification grammar, we have defined an `SIR_starter()` function to sweep some of the details of initializing a model object under the rug (for now, though we will revisit it [later](#dessert)). All you need to know about `SIR_starter()` at this stage is that we will pass it some inputs to define the model using the model grammar and it will output a model object from which we can build a simulator. Our focus for the remainder of this vignette will be how the inputs to `SIR_starter()` are created.

```{r SIR-starter, echo = FALSE}
## helper function to simplify the exposition in this vigette -----------
SIR_starter = function(
  # indices for model quantities
  state,
  rate,
  # ledgers for calculation archetypes
  flow, # list of individual ledgers
  force_of_infection
){
  
  ## Set up expressions list for each calculation archetype --------------
  expr_list = mp_expr_list(
    before = list(
      ## aggregations
        N ~ sum(state)
    ),
    during = list(
      ## force of infections
        rate[infection_flow_rates] ~
          state[infectious_states] * rate[transmission_rates] / N
  
      ## unsigned individual flows
      , flow_per_time ~ state[from_states] * rate[flow_rates]
  
      ## state update
      , total_inflow ~ groupSums(flow_per_time, to_states, state)
      , total_outflow ~ groupSums(flow_per_time, from_states, state)
      , state ~ state + total_inflow - total_outflow
    )
  )
  
  ## Ledgers for each specific calculation --------------
  link_data = list(
    flow = mp_link_data(flow[[1]], flow[[2]]),
    force_of_infection = mp_link_data(force_of_infection)
  )
  
  ## Initialize indexed vectors (to all zeros) --------------
  # used as placeholders for user input
  init_vecs = list(
    state = mp_vector(state),
    rate = mp_vector(rate)
  )
  
  ## Initialize model object -----------------
  DynamicModel(
    expr_list = expr_list,
    link_data = link_data,
    init_vecs = init_vecs
  )
}
```

The inputs to `SIR_starter()` are of two types:

- **indices** (labels) for model quantities, 
- **ledgers** that tabulate specific calculations required to simulate the model equations (based on the included calculation archetypes).

The **indices** we need to specify fall into two groups:

- `state`: state names, $S$, $I$, and $R$ from the model equations
- `rate`: rate names, $\beta$, $\gamma$, and the derived rate $\lambda$

We have identified two useful calculation archetypes that we have baked into `SIR_starter()`. In this case, we're thinking of calculation archetypes not as repeated calculations in this particular model, but as calculations that a modeller may want to repeat down the line, as they expand this simple model with additional structure (as we will do [below](#main-course)). The archetypes are:

- `flow`: Flows from one class to another, where the flow takes the form $rX$, with $r$ being the flow rate and $X$ being the state from which the flow originates. This calculation is repeated for all terms on the right-hand side of the recast system of difference equations above.
- `force_of_infection`, the prevalence-dependent per capita rate of flow from susceptible classes to infectious classes, used in calculating the `infection` flow

In this case, the `flow` archetype is repeated within the model equations but the `force_of_infection` archetype is only used once. However, we've identified the force of infection as an archetype since we will want to repeat it later when [expanding into the two-strain model](#main-course). In either case, these archetypes are already baked into `SIR_starter()`, so our task will be creating a calculation **ledger** for each of these archetypes.  

We start by creating the `state` and `rate` indices:

```{r}
## indices (labels) for model quantities -------------------------
state = mp_index(Epi = c("S", "I", "R"))
rate = mp_index(Epi = c("beta", "gamma", "lambda"))
```

You can think of the `mp_index()` function a setting up data frames tabulating the model quantity labels:

```{r}
state
```

```{r}
rate
```

The `Epi` column name is not really useful in this simple model, but it will be key to stratifying model quantities with different features (such as epidemiological status, infection type, age group, location) in more complicated models.

For the `flow` archetype, we will create two ledgers: `infection` for the flow from $S$ to $I$ and `recovery` for the flow from $I$ to $R$. We specify flows using a from state (`from_states`), a to state (`to_states`), and a flow rate name (`flow_rates`).

We use the `mp_join()` function to create the `infection` ledger like so:

```{r}
# infection ledger
infection = mp_join(
  from_states = mp_subset(state, Epi = "S"),
  to_states = mp_subset(state, Epi = "I"), 
  flow_rates = mp_subset(rate, Epi = "lambda")
)
```

The `mp_join()` function takes the options provided in each argument `from_states`, `to_states`, and `flow_rates`, namely

```{r}
mp_subset(state, Epi = "S")
```

```{r}
mp_subset(state, Epi = "I")
```

and

```{r}
mp_subset(rate, Epi = "lambda")
```

and by default creates one entry in the ledger for each combination of these values (_i.e._, a "[full join](https://dplyr.tidyverse.org/reference/mutate-joins.html#outer-joins)"). However, since there is only one value in each column, there is only one entry in the resulting ledger in this case!

```{r}
infection
```

As a side note, the names of the arguments in the `mp_join()` function are tied to the calculation archetypes baked into `SIR_starter()`, but in general they are completely up to the modeller and how they choose to specify their calculation archetypes.^[There is only one `mp_join()` argument name that is not available to the user, and that is `by`, which has a special role that we will see [later](#main-course).]

We create the `recovery` ledger in a similar way:

```{r}
# recovery
recovery  = mp_join(
  from_states = mp_subset(state, Epi = "I"),
  to_states = mp_subset(state, Epi = "R"),
  flow_rates = mp_subset(rate, Epi = "gamma")
)

recovery
```

Finally, the `force_of_infection` ledger is slightly different as it corresponds to a different calculation archetype in `SIR_starter()` (so the `mp_join()` argument names are different):

```{r}
# infection additionally involves the calculation of a force of infection
force_of_infection = mp_join(
  infectious_states = mp_subset(state, Epi = "I"),
  transmission_rates = mp_subset(rate, Epi = "beta"),
  infection_flow_rates = mp_subset(rate, Epi = "lambda")
)
```

For this calculation archetype, we need to specify the `transmission_rates` and `infectious_states` involved in computing the force of infection, as well as the names where we want to store the results of this calculation (`infection_flow_rates`) for use in the `infection` flow calculations. 

Now we can use the `SIR_starter()` function to initialize our model object:

```{r}
sir = SIR_starter(
  # indices
  state = state,
  rate = rate,
  # ledgers
  flow = list(
    infection,
    recovery
  ),
  force_of_infection = force_of_infection
)
```

We can create a model simulator using `mp_tmb_simulator()`, provided we give it the model object (`model`), initial values for the indices (`vectors`), as well as the number of total time steps in the simulation (`time_steps`):

```{r}
sir_simulator = mp_tmb_simulator(
  sir,
  vectors = list(
    state = c(S = 999, I = 1, R = 0),
    rate = c(beta = 0.25, gamma = 0.1, lambda = NA)
  ),
  time_steps = 100L
)
```

Note that we've specified `NA` for `lambda` as it will be calculated internally using the `force_of_infection` archetype.

Then we can actually simulate the model by passing our model simulator to `mp_report()`:

```{r}
sir_results = mp_report(sir_simulator)
```

The output of the simulation is a [long data frame](https://r4ds.had.co.nz/tidy-data.html#longer) that can easily be manipulated and plotted with standard tools, like `dplyr` and `ggplot2`:

```{r}
(sir_results
  |> filter(matrix == "state") # keep state variables at each point in time
  |> mutate(state = factor(row, levels = c("S", "I", "R"))) # to enforce logical state ordering in plot
  |> ggplot(aes(time, value, colour = state))
  +  geom_line()
)
```

(Above, we used the [base R pipe operator](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/#pipes), `|>`.)

If you want to use base R for plotting, you can convert the long format data to wide format:

```{r pivot_wider}
sir_results_wide <- (sir_results
    |> dplyr::filter(matrix == "state") # keep state variables at each point in time
    ## drop 'matrix' (has only a single value) and 'col' (empty)
    |> dplyr::select(-c(matrix, col))
    |> tidyr::pivot_wider(id_cols = time, names_from = row)
)

head(sir_results_wide, n = 3)
```

```{r base_plot_ex, fig.width = 6}
with(sir_results_wide,
     plot(x = time,
          y = I)
)
```

or

```{r base_matplot_ex, fig.width = 6}
par(las = 1) ## horizontal y-axis ticks
matplot(sir_results_wide[, 1],
        sir_results_wide[,-1],
        type = "l",
        xlab = "time", ylab = "")
legend("bottom", col = 1:3, lty = 1:3, legend = state$labels())
```

# Main course: expanding the basic SIR with additional structure {#main-course}

As previously noted, we created a `force_of_infection` archetype of the form $\beta I / N$ despite it only being used once to define the SIR model. However, if we consider the two-strain model from [before](#amuse-bouche), we see this calculation is repeated for each strain:

\begin{align}
\lambda_A &= \beta_A I_A/N \\ 
\lambda_B &= \beta_B I_B/N
\end{align}

Since we already have an archetype for the force of infection, we can easily expand our basic SIR with the strain-related structure to get the two-strain SIR model.

We start by creating a new index for the strains:

```{r}
Strain_indices = c("A", "B")
```

Now we expand the states and rates associated with different strains. For the state, we want to cross $I$ with the different strains to create one $I$ compartment per strain. We can do so easily using the `mp_cartesian()` function, which takes the Cartesian product of indices (all possible combinations across sets):

```{r}
I_index = mp_cartesian(
  mp_subset(state, Epi = "I"),
  mp_index(Strain = Strain_indices)
)

I_index
```

We then combine the newly-stratified $I$ indices with the other states that remain unchanged using the `mp_union()` function:

```{r}
state = mp_union(
  mp_subset(state, Epi = "S"),
  I_index, 
  mp_subset(state, Epi = "R")
)

state
```

We update the rates similarly:

```{r}
rate = 
  mp_union(
  # stratify rates involved in the infection process by strain
  mp_cartesian(
    mp_subset(rate, Epi = c("beta", "lambda")),
    mp_index(Strain = Strain_indices)
  ),
  # recovery rate will be the same across strains
  mp_subset(rate, Epi = "gamma")
)

rate
```

It may seem like overkill to use `mp_subset()`, `mp_cartesian()`, and `mp_union()` here to define the indices using the original ones from the SIR when they could be written out by hand quickly as

```{r eval = FALSE}
state = mp_index(
  Epi = c("S", rep("I", 2), "R"),
  Strain = c("", Strain_indices, "")
)

rate = mp_index(
  Epi = c(rep(c("beta", "lambda"), 2), "gamma"),
  Strain = c(rep(c("A", "B"), each = 2), "")
)
```

but you can imagine if you're building off of an existing, working model and you want to stratify many states into many new categories, the first way of building the indices might be preferred, which is why we demonstrated it above.

For the `infection` ledger, let's see what our previous code for generating it yields now that we have some stratification by `Strain`:

```{r}
# infection ledger from before
mp_join(
  from_states = mp_subset(state, Epi = "S"),
  to_states = mp_subset(state, Epi = "I"), 
  flow_rates = mp_subset(rate, Epi = "lambda")
)
```

As before, the default in `mp_join()` is to give all possible combinations for the indices (the full join). However, for this model, we want only two of these flows:

- a flow between `S` and `I.A` with flow rate `lambda.A`
- a flow between `S` and `I.B` with flow rate `lambda.B`

In other words, we want the `Strain` index on `I` to match with the `Strain` index on `lambda`. We can specify this within `mp_join()` when building the ledger like so:

```{r}
# new infection ledger
infection = mp_join(
  from_states = mp_subset(state, Epi = "S"),
  to_states = mp_subset(state, Epi = "I"), 
  flow_rates = mp_subset(rate, Epi = "lambda"),
  by = list(
    to_states.flow_rates = "Strain"
  )
)

infection
```

Note the syntax of the `by` argument here. Each `by` list element will correspond to a pairwise join of two index tables passed to `mp_join()`. Which indices are involved in the join will correspond to the dot concatenated list name (`to_states.flow_rates`), with the names coming from argument names in `mp_join()` (`to_states`, `flow_rates`). The value should be a character name of the index type upon which to match. In this case, the value is `"Strain"` because we want the to state labels and the flow rate labels to match based on the strain label (`I.A` with `lambda.A` and `I.B` with `lambda.B`.

For the recovery ledger, we haven't stratified `gamma` or `R`, so the default full join with the `I` labels yields exactly the flows we want:

```{r}
recovery = mp_join(
    from_states = mp_subset(state, Epi = "I"),
    to_states = mp_subset(state, Epi = "R"),
    flow_rates = mp_subset(rate, Epi = "gamma")
)
recovery
```

For the force of infection ledger, the full join yields all sorts of combinations that we don't want:

```{r}
mp_join(
  infection_flow_rates = mp_subset(rate, Epi = "lambda"),
  infectious_states = mp_subset(state, Epi = "I"),
  transmission_rates = mp_subset(rate, Epi = "beta")
)
```

We want the `lambda`, `I`, and `beta` labels all matched on the stain index. But recall that `mp_join()` only performs pairwise joins, so we cannot specify a three-way join. Instead, we will specify two pairwise joins:

```{r}
force_of_infection = mp_join(
  infection_flow_rates = mp_subset(rate, Epi = "lambda"),
  infectious_states = mp_subset(state, Epi = "I"),
  transmission_rates = mp_subset(rate, Epi = "beta"),
  by = list(
    infection_flow_rates.infectious_states = "Strain",
    infectious_states.transmission_rates = "Strain"
  )
)

force_of_infection
```

Now we're ready to build the two-strain model object and simulate it:

```{r}
two_strain_model = SIR_starter(
  # indices
  state = state,
  rate = rate,
  # ledgers
  flow = list(
    infection,
    recovery
  ),
  force_of_infection = force_of_infection
)

two_strain_simulator = mp_tmb_simulator(
  two_strain_model,
  vectors = list(
    state = c(S = 998, I.A = 1, I.B = 1, R = 0),
    rate = c(beta.A = 0.25, lambda.A = NA, beta.B = 0.2, lambda.B = NA, gamma = 0.1)
  ),
  time_steps = 100L
)

two_strain_results = mp_report(two_strain_simulator)

(two_strain_results
  |> filter(matrix == "state") # keep state variables at each point in time
  |> mutate(state = factor(row, levels = c("S", "I.A", "I.B", "R"))) # to enforce logical state ordering in plot
  |> ggplot(aes(time, value, colour = state))
  +  geom_line()
)
```

# Dessert: understanding model simulation in `macpan2` {#desert}

- follow up vignette, tentative title: "Quickstart part 2: understanding model simulation in `macpan2`"
- set of ledgers are associated with a set of archetypes, column names need to match across these paired sets of ledgers and archetypes, but between the paired sets, columns names to be unique 

explain that we will explain:

```{r}
<<SIR-starter>>
```



