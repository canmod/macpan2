---
title: "Quickstart part 1: understanding model specification in `macpan2`"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Quickstart Guide: specifying and simulating a simple compartmental model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

[![status](https://img.shields.io/badge/status-stub-red)](https://canmod.github.io/macpan2/articles/vignette-status#stub)

```{r setup, echo = FALSE}
library(macpan2)
```


# Motivation

A common approach to modelling is to start with a simple model and then expand and/or stratify as further complexity is needed. In reality, this process can be full of friction as one implements and re-implements the model for numerical simulation. One of the goals of `macpan2` is to provide a grammar for model specification that streamlines model expansion.

# Amuse bouche: a (simple) metapopulation SIR model

- define model used in slides (ignoring contact matrices???)
- point out that there is a lot of repetition
- introduce the idea of calculation archetypes (formulas? patterns?) that get repeated

`macpan2`'s flexibility is derived from the ability to identify calculation archetypes that may or may not be repeated throughout the model. For instance, consider the following simple metapopulation SIR model, cast as a system of difference equations (as is often the case when numerically simulating ordinary differential equation models): 

[insert diagram with three cities and the same set of SIR difference equations within. note that we've simplified the usual metapop model by not considering movement between cities... does that make it an overly simple stratified model?? ugh, i dont know. maybe we would be better off with a model that has two forces of infection and explain calculation archetypes with that ??]

[define states and rates with this diagram
- $S$, $I$, and $R$ are the number of susceptible, infected, and recovered individuals, respectively,
- $N$ is the total population size ($S + I + R$),
- $\beta$ is the transmission rate,
- $\gamma$ is the recovery rate.
]

Each city has an infection flow, a recovery flow, and a force of infection that need to be computed for each time step in the numerical simulation of the model. But the **form** of each of these calculations is essentially the same! Instead of manually writing out each calculation, for instance as 

```
S.calgary[t+1] = - lambda.calgary * S.calgary[t]
S.hamilton[t+1] = - lambda.hamilton * S.hamilton[t]
S.quebec[t+1] = - lambda.quebec * S.quebec[t]
```
we will specify a single calculation archetype for it, for instance something like,
```
S[t+1] = -lambda * S[t]
```
and then attach information to the model object about which specific calculations to do under this archetype (one per city).

# Appetizer: specifying the basic SIR model {#SIR}

Let's start with the basic epidemic model being repeated across cities and learn how to specify that in `macpan2`. We will start with the SIR model, which is the simplest epidemic model that is routinely used as a basis for much more complicated epidemic models:

\begin{align}
S_{t+1} &= -\beta S_t I_t/N, \\ 
I_{t+1} &= \beta S_t I_t/N - \gamma I_t, \\ 
R_{t+1} &= \gamma I_t.
\label{eqn:SIR-difference}
\end{align}

It will be helpful to set $\lambda = \beta I_t/N$ and recast the equations as:

\begin{align}
S_{t+1} &= -\lambda S_t, \\ 
I_{t+1} &= \lambda S_t - \gamma I_t, \\ 
R_{t+1} &= \gamma I_t.
\label{eqn:SIR-difference}
\end{align}

(In epidemic modelling, $\lambda$ is chosen suggestively as it models the [force of infection](https://en.wikipedia.org/wiki/Force_of_infection) denoted by the same character.)

The focus of this quickstart guide is to help a user begin to understand how models are specified using `macpan2`. The following function has been created to sweep some of the details of initializing an SIR model object under the rug (for now). Please ignore this function's definition on your first read and just understand that it will output a model object from which we can then build a simulator. In order to do that, we have to create each of the inputs of this function, which is what the rest of this section will be about.

```{r}
## links between entries in the indexes -----------
SIR_starter = function(
  # indices for model quantities
  state,
  flow_rates,
  # ledgers for calculation archetypes
  infection,
  recovery,
  force_of_infection
){
  
  ## Set up expressions list for each calculation archetype --------------
  expr_list = mp_expr_list(
    before = list(
      ## aggregations
        N ~ sum(state)
    ),
    during = list(
      ## force of infections
        flow_rates[infection_flow] ~
          state[infectious_state] * flow_rates[rate] / N
  
      ## unsigned individual flows
      , flows_per_time ~ state[from] * flow_rates[rate]
  
      ## state update
      , total_inflow ~ groupSums(flows_per_time, to, state)
      , total_outflow ~ groupSums(flows_per_time, from, state)
      , state ~ state + total_inflow - total_outflow
    )
  )
  
  ## Ledgers for each specific calculation --------------
  link_data = list(
    flows = mp_link_data(infection, recovery),
    fois = mp_link_data(force_of_infection)
  )
  
  ## Initialize indexed vectors (to all zeros) --------------
  # used as placeholders for user input
  init_vecs = list(
    state = mp_vector(state),
    flow_rates = mp_vector(flow_rates)
  )
  
  ## Initialize model object -----------------
  DynamicModel(
    expr_list = expr_list,
    link_data = link_data,
    init_vecs = init_vecs,
    unstruc_mats = list()
  )
}
```

Now that we have our equations, we can start by naming the main quantities used in specifying and simulating the model. Quantities are named using "indices", which you can think of for now as labels for each quantity:

```{r}
## indices (labels) for model quantities -------------------------

state = mp_index(Epi = c("S", "I", "R"))
flow_rates = mp_index(Epi = c("beta", "gamma", "lambda"))
```

You can think of the `mp_index()` fuction a setting up data frames with model quantity labels:

```{r}
state
```

```{r}
flow_rates
```

(Ignore the column name `Epi` for now.)

In this model, we have three main calculation archetypes. In this case, we're thinking of calculation archetypes not as repeated calculations, but as calculations that a modeller may want to repeat down the line, as they expand the model. The archetypes are:

1. infection: flows between susceptible and infected classes
2. recovery: flows between infected and recovered classes
3. force of infection: prevalence-dependent rates involved in calculating infection flows

For each of these calculation archetypes, we need to write down a ledger cataloguing each specific calculation that uses each archetype. (Note that the SIR model is so simple that there will only be one infection flow calculation, one recovery flow calculation, and one force of infection calculation, but we will see later with a structured model that these ledgers give us the flexbility to easily expand a model without being redundant.)

We start by creating the infection ledger:

```{r}
# infection ledger
infection = mp_join(
  from = mp_subset(state, Epi = "S"),
  to = mp_subset(state, Epi = "I"), 
  rate = mp_subset(flow_rates, Epi = "lambda")
)
```

- explain what the `mp_join()` function is doing (at a high level)... mention that the argument names are flexible an depend on how the calculation archetypes are specified, but we should ignore this for now.

Then we create the remaining ledgers:

```{r}
# recovery
recovery  = mp_join(
  from = mp_subset(state, Epi = "I"),
  to = mp_subset(state, Epi = "R"),
  rate = mp_subset(flow_rates, Epi = "gamma")
)

# infection additionally involves the calculation of a force of infection
force_of_infection = mp_join(
  infection_flow = mp_subset(flow_rates, Epi = "lambda"),
  infectious_state = mp_subset(state, Epi = "I"),
  rate = mp_subset(flow_rates, Epi = "beta")
)
```

Now we can use the `SIR_starter()` function to initialize our model object:

```{r}
model = SIR_starter(
  state,
  flow_rates,
  infection,
  recovery,
  force_of_infection
)
```

```{r}
sir_simulator = mp_tmb_simulator(model
  , vectors = list(
      state = c(S = 999, I = 1, R = 0),
      flow_rates = c(beta = 0.25, gamma = 0.1, lambda = NA)
    )
  , time_steps = 100L
)

sim_report = mp_report(sir_simulator)
```

# Main course: expanding the basic SIR into a metapopulation SIR

- here is where we see the power of macpan

# Desert: understanding model simulation in `macpan2`

- follow up vignette, tentative title: "Quickstart part 2: understanding model simulation in `macpan2`"
