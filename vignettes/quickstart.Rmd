---
title: "Quickstart Guide: specifying and simulating a simple compartmental model"
output: 
  rmarkdown::html_vignette:
    toc: true
vignette: >
  %\VignetteIndexEntry{Quickstart Guide: specifying and simulating a simple compartmental model}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

[![status](https://img.shields.io/badge/status-working%20draft-red)](https://img.shields.io/badge/status-working%20draft-red)

```{r pkgs, include = FALSE}
library(macpan2)
library(macpan2helpers)
library(dplyr)
library(ggplot2)
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
cat_file = function(...) {
  cat(readLines(file.path(...)), sep = "\n")
}
```

```{r show_visnet, echo = FALSE}
# function to get around issues with displaying visNetwork objects in an html vignette 
show_visnet <- function(vn){
  visNetwork::visSave(vn, file = paste0("visnet.html"))
  hh <- htmltools::includeHTML("visnet.html") |>
      ## https://stackoverflow.com/questions/47577894/r-markdown-visnetwork-not-displayed-in-html-output-when-using-for-loops-or-fun
      gsub(pattern = "<!DOCTYPE html>", replacement = "", fixed = TRUE) |>
      sub(pattern = "\n", replacement = "")
  cat(hh)
  invisible(file.remove("visnet.html"))
}
```

This quickstart guide is meant to show a new user how to specify and simulate a simple compartmental model in `macpan2`. 

`macpan2` is extremely flexible in how models are specified, and so there can be several equivalent ways of specifying the same model. This feature is important to keep in mind when trying to understand or build more complicated models, such as the one demonstrated in Quickstart Guide, part 2 (see `vignette('quickstart2', package = 'macpan2')`).

## Model Definition Files

Models are defined by a set of four [model definition files](https://canmod.github.io/macpan2/articles/model_definitions), all housed in the same directory:

```
model_name
├── variables.csv
├── derivations.json
├── settings.json
└── flows.csv
```

Installations of `macpan2` contain several starter models:

```{r list_starters}
list.files(system.file("starter_models", package = "macpan2"))
```

(TODO: add a link to a reference doc with short descriptions of each starter model... also write this doc :) ideally it would have diagrams to illustrate each model)

The simplest is [the SIR model](https://en.wikipedia.org/wiki/Compartmental_models_in_epidemiology#The_SIR_model), which can be found in this directory:

```{r sir_model_path}
print(sir_dir <- system.file("starter_models", "sir", package = "macpan2"))
```

In this article, we work through the specification and simulation of the SIR sample model.

### variables.csv {#variables}

`variables.csv` includes a list of the model variables:

```{r vars, echo=FALSE, eval=TRUE}
cat_file(sir_dir, "variables.csv")
```

(The first row of this file is a header row, which classifies the variables below. More on this later.)

In `macpan2`, we use "variables" as a general term to refer to

- **State variables**, such as:
  - `S`: the number of susceptible individuals at each point in time;
  - `I`: the number of infectious individuals;
  - `R`: the number of removed individuals.
- **Flow variables**, such as:
  - `beta`: the contact rate (transmission per time per susceptible per infective);
  - `gamma`: the per-capita recovery rate of infectious individuals.
- **Derived variables**, to be calculated using state and/or flow variables, such as:
  - `N`: population size, calculated by summing all of the state variables `S + I + R`.
  - `foi`: the force of infection, `beta * I / N` in this model.
  
Formulas for the derived quantities are defined in [derivations.json](#derivations).

In simple models like this one, `variables.csv` is a single-column `.csv` file. The header row contains one column name, `Epi`, which labels the variables below it as epidemiological variables. Such variable category labels, or **variable partitions**, aren't useful for simple models like the basic SIR, which have only a single variable category. However, partitions are essential as part of ["product" models](https://canmod.github.io/macpan2/articles/hello_products.html) that combine multiple model structures into more complex models (for example, an SEIR model where the infectious class is divided by level of symptoms: see `vignette('quickstart2', package = 'macpan2')`.

### derivations.json {#derivations}

`derivations.json` includes expressions for computing derived variables:

```{r, echo=FALSE, eval=TRUE}
cat_file(sir_dir, "derivations.json")
```

In this example, the derived variables are the total population size, `N`, and the force of infection, `foi`. Each derived variable is defined in a [JSON](https://en.wikipedia.org/wiki/JSON) object. Each such JSON object contains several key-value pairs. Here the keys are:

- `output_names`: The name(s) of the derived variable(s); in this simple model, each JSON object only defines a single derived variable.
- `simulation_phase`: The phase during which this derived variable is calculated; Here we have:
    - `before`, which means the variable is calculated from the initial variable values, before the simulation begins;
    - `during_pre_update`, which means the variable is calculated at each simulation step, before the state variables are updated for the next time step.
- `arguments`: An array of the variables (delimited by brackets `[]`) used to calculate the derived variable.
- `expression`: A string storing a mathematical expression  used to calculate the derived variable using the `arguments`.

The keys described above have more options; supplementary keys are used for defining more complicated models. These are fully catalogued in the [model definitions](https://canmod.github.io/macpan2/articles/model_definitions.html#flow-between-compartments) article. Mathematical operations and functions available to use in the `expression` string are listed in the  [engine functions](https://canmod.github.io/macpan2/reference/engine_functions.html) reference article.

In the example above, we could have defined `foi` as `beta * I / (S + I + R)`. However, this expression is harder to read, and less computationally efficient. As defined above, `N` is computed once, before the simulation begins (`"simulation_phase": "before"`), since the population size is fixed in this model. `foi` is computed from its arguments at each simulation time step (`"simulation_phase": "during_pre_update"`) in order to update the numerator `I` using the latest prevalence. The denominator `(S + I + R)` would then also be re-computed needlessly during each time step. 

### settings.json

`settings.json` gives information about how to interpret the variables defined in [variables.csv](#variables). 

```{r, echo=FALSE, eval=TRUE}
cat_file(sir_dir, "settings.json")
```

This file contains a single JSON object, with several key-value pairs. The mandatory keys are:

- `required_partitions`: An array of variable partition names (from the header row of [variables.csv](#variables)) required to uniquely identify each variable.
- `null_partition`: Leave this entry as `"Null"`; this key may be used to expand `macpan2`'s functionality in the future, but it is currently unused.
- `state_variables`: An array of state variables.
- `flow_variables`: An array of flow variables.

### flows.csv

`flows.csv` defines flows between state variable compartments:

```{r, echo=FALSE, eval=TRUE}
cat_file(sir_dir, "flows.csv")
```

This file also starts with a header row, including the following columns:

- `from`: The name of the flow origin compartment.
- `to`: The name of the flow destination compartment.
- `flow`: The variable name storing the value of the flow rate.
- `type`: The type of the flow.

Here, the flow type is `per_capita`: i.e., the flow at time step $t+1$ equals `flow` times the number of individuals in the `from` compartment at time $t$. In the example above, the flow from `S` to `I` equals `foi * S` (referring back to the derivations file, this is equal to `beta * S * I/ N`).

All available flow types are given in the [model definitions](https://canmod.github.io/macpan2/articles/model_definitions.html#flow-between-compartments) article.

## Side-Note: `macpan2` is Object-Oriented

Before we demonstrate how to import and use a model into R, it is helpful to note that `macpan2` is [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming). If you are new to object-oriented programming, what you need to know is that when using `macpan2`, we routinely create ("initialize") special R objects that will have specific functions ("methods") attached that can operate on these objects. These objects are generally just named lists, where some of the list elements are actually methods. Here is a sketch of what that looks like:

```
myObject <- functionToIntializeObject(argumentsToSetUpMyObject)
names(myObject)
> [1] "objectInfo" "objectMethod"
myObject$objectMethod(argumentsForUsingObjectMethod)
```

We make this more concrete in the next section.

## Getting Model Definitions into R

Now that we have a directory that completely defines a compartmental model, we can use it to create a **model structure** object in R using the `Compartmental()` function. `Compartmental()` is a function that initializes objects whose class includes `Compartmental`, a `macpan2` custom object class.

```{r Compartmental}
sir = Compartmental(sir_dir)
class(sir)
```

`Compartmental` objects can then be visualized with the help of the [macpan2helpers](https://github.com/canmod/macpan2helpers) package:

```{r make_visnet}
vn = macpan2helpers::visCompartmental(sir, label_flows = TRUE)
```

```{r show_visnet_sir, results = 'asis', echo = FALSE}
show_visnet(vn)
```

We can easily see the components of and methods for operating on `Compartmental` objects by looking at the names of a `Compartmental` object, in this case the `sir` object:

```{r}
names(sir)
```

These list elements are fully catalogued in the documentation for `Compartmental` objects (`?Compartmental()`), but for the next section, we focus on `sir$simulators`.

## Inputting Values to Create Model Simulators

Model structure objects, like `sir`, are very general: they don't contain any specific values for their variables, such as initial conditions for the state variables or values for flow rates. In order to simulate a model, we need to create a **model simulator** object by combining a model structure object with numerical values for its variables. 

The `sir$simulators` list element contains methods for generating model simulators. In this article, we use the `sir$simulators$tmb()` method, which is currently the only simulation engine available. 

We attach specific values for model variables when initializing the model simulator, `sir_simluator`, using the `sir$simulators$tmb()` function:

```{r sim_values}
sir_simulator = sir$simulators$tmb(
  time_steps = 100,
  state = c(S = 99, I = 1, R = 0),
  flow = c(foi = 0, gamma = 0.1),
  beta = 0.2,
  N = empty_matrix # explained below
)
```

The simulator initializer function, `sir$simulators$tmb()`, will use `sir` as the model structure, and then additionally take the following arguments:

- `time_steps`: How many time steps should the epidemic simulator run for? 
- `state`: A named vector containing the initial values of the state variables defined in `settings.json`. In this example, we are simulating states in numbers of individuals.
- `flow`: A named vector containing the values of the flow variables defined in `settings.json`. Here, those are just `foi` and `gamma`.
- `...`: Any other named variables that are required for your model definition, _i.e._, variables used in  `derivations.json` that are not included in `settings.json`. Here,  `beta` and `N` are used in expressions for derived variables but not explicitly as flow variables.

(IP: are the units of the time steps determined implicitly from the units of the flow rates? For instance, if the flow rates are specified per day, the time step is 1 day? We should clarify that here.)

In our example, we use the `empty_matrix` placeholder value to initialize a value for the population size `N`. `N` will be computed before the simulation starts using the given initial conditions, as specified in `derivations.json` with `"simulation_phase": "before"`. In order to create a model simulator object, we must give a value for every variable in the model definition. `macpan2` does not check ahead of time whether `N` will be pre-computed. Thus, we initialize `N` with the placeholder value `macpan2::empty_matrix`, which is simply an empty matrix. (Although `N` is a scalar value, `macpan2` represents all varibles as [matrices](https://canmod.github.io/macpan2/articles/cpp_side#matrices), including scalars, also known as 1 x 1 matrices.)

What if we had specified a hard-coded value for `N` above? For instance: 

```{r sim_values2, eval = FALSE}
sir_simulator2 = sir$simulators$tmb(
  time_steps = 100,
  state = c(S = 99, I = 1, R = 0),
  flow = c(foi = 0, gamma = 0.1),
  beta = 0.2,
  N = 100
)
```

There is actually no problem with this specification; `macpan2` will compute `N` using the expression `S + I + R` from `derivations.json` and the initial conditions from the `state` argument above before the simulation and overwrite the user-input value of 100. Thus, if one were to change the initial condition to `state = c(S = 999, I = 1, R = 0)` without updating the population to `N = 1000`, the simulator would still use the correct population size. However, the code is more readable if you explicitly use `N = empty_matrix`, because it reminds the user that `N` will be computed by the simulator and so it does not have to be updated by the user.

## Simulation

Now that we have a simulation engine object,  `sir_simulator`, we use it to generate simulation results using one of its methods: `report()`. The results come out in [long (or "narrow") format](https://en.wikipedia.org/wiki/Wide_and_narrow_data), where there is exactly one value per row:

```{r run_sims}
sir_results = sir_simulator$report()
head(sir_results, 9)
```

The simulation results are output as a data frame with the following columns:

- `matrix`: Which matrix does a value come from? By default, the simulation results will only include values for the state variables (coming from the `state` matrix). This behaviour can be changed with the `.mats_to_return` argument of `$simulators$tmb()` (see `?Simulators()`)
- `time`: The time index, where the initial conditions are returned for `time` 0.
- `row`: The name of the variable, which corresponds to the row names of the `state` matrix.
- `col`: A placeholder for variable name components in more complicated models (not covered in this article).
- `value`: The simulated value corresponding to the context provided by the other columns.

## Processing Results

There are no data manipulation or plotting tools in `macpan2`. The philosophy is to focus on the engine and modelling interface, but to provide outputs in formats that are easy to use with other data processing packages, like `ggplot2`, `dplyr`, and `tidyr`, all of which readily make use of data in long format. 

For example, we can generate a `ggplot` easily with:

```{r ggplot_ex, fig.width = 6}
(ggplot(sir_results)
  + geom_line(aes(time, value, colour = row))
  + labs(colour = "state")
  + theme_bw()
)
```

Similarly, if you want to use base plotting tools to visualize a simulation, you can readily convert the long format data to wide format:

```{r pivot_wider}
sir_results_wide <- (sir_results
    ## drop 'matrix' (has only a single value) and 'col' (empty)
    |> dplyr::select(-c(matrix, col))
    |> tidyr::pivot_wider(id_cols = time, names_from = row)
)

head(sir_results_wide, n = 3)
```

(Above, we made use of the [base pipe operator](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/#pipes), `|>`.)

```{r base_plot_ex, fig.width = 6}
with(sir_results_wide,
     plot(x = time,
          y = I)
)
```

